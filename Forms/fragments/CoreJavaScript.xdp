<?xml version="1.0" encoding="UTF-8"?>
<?xfa generator="AdobeLiveCycleDesignerES_V10.0.2.20120224.1.869952" APIVersion="3.5.12002.0"?>
<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/" timeStamp="2013-06-18T18:39:10Z" uuid="100133b1-1e09-443d-b19b-7a7e1a0c152c">
<template xmlns="http://www.xfa.org/schema/xfa-template/3.0/">
   <?formServer defaultPDFRenderFormat acrobat9.1static?>
   <?formServer allowRenderCaching 0?>
   <?formServer formModel client?>
   <subform name="script" locale="en_CA" layout="tb">
      <pageSet>
         <pageArea>
            <contentArea h="254mm" id="caMain_ID" name="caMain" w="203.2mm" x="6.35mm" y="15.875mm">
               <?templateDesigner expand 1?></contentArea>
            <medium long="279.4mm" short="215.9mm" stock="letter"/>
            <?templateDesigner expand 0?></pageArea>
         <?templateDesigner expand 0?></pageSet>
      <subform w="100mm" name="core" layout="tb">
         <bind match="none"/>
         <variables>
            <script contentType="application/x-javascript" name="System">//
/*******************************************************************************
 * This contains system level constants and functions.
 */

// Import
var cException = script.core.util.Exception;
var cFormNodeManager = script.core.model.FormNodeManager;
var cLog = script.core.util.Log;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;
var cStringUtil = script.core.util.StringUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var currentField = null;
var currentFieldPrevValue = null;

/**
 * Gets the previous (pre-edit) value for the passed field. This is typically
 * called as part of the "exit" event processing. Note that this requires that
 * the field already be recorded by calling setCurrentField() in the "enter"
 * event.
 * @param aField the Adobe field or exclusion group node that was being edited.
 * @return a String that contains the previous (pre-edit) value for the passed
 *		   field
 * @throws an UnexpectedDataType Exception if aField is undefined, null, or
 *		   isn't an Adobe Field or Exclusion Group.
 * @throws an IllegalState Exception if aField isn't the same as currentField.
 */
function getCurrentFieldPrevValue(aField)
{
	if (!cTypeChecker.isSpecificCustomObject(aField, cTypeEnforcer.FIELD_CLASS)
		&amp;&amp; !cTypeChecker.isSpecificCustomObject(aField, cTypeEnforcer
												.EXCLUSION_GROUP_CLASS))
	{
		throw cException.createInstance("System.getCurrentFieldPrevValue(" 
			  + "aField) requires a Field or ExclusionGroup value, not a " 
			  + cObjectUtil.getDescription(aField));	
	}

	if (currentField == null)
	{
		throw cException.createInstance("System.getCurrentFieldPrevValue(): "
			  + "the currentField was not set to field '" 
			  + cStringUtil.formatSomExpression(aField.somExpression) + "'",
			  "IllegalState");
	}
	if (currentField.somExpression == aField.somExpression)
	{
		return currentFieldPrevValue;
	}
	throw cException.createInstance("System.getCurrentFieldPrevValue(): "
		  + "the previously set currentField '" 
		  + cStringUtil.formatSomExpression(currentField.somExpression)
		  + "' is not the same as the passed one '" 
		  + cStringUtil.formatSomExpression(aField.somExpression) + "'",
		  "IllegalState");
}

/**
 * Gets whether the current value for the passed field has changed from its
 * previous (pre-edit) value. This is typically called as part of its "exit"
 * event processing. Note that this requires that the field already be recorded
 * by calling setCurrentField() in the "enter" event.
 * @param aField the Adobe field node that was being edited.
 * @return a Boolean - true if the current value for the passed field has
 *		   changed from its previous (pre-edit) value.
 * @throws an UnexpectedDataType Exception if aField is undefined, null, or
 *		   isn't an Adobe Field.
 * @throws an IllegalState Exception if aField isn't the same as currentField.
 */
function hasCurrentFieldValueChanged(aField)
{
	try
	{
		return getCurrentFieldPrevValue(aField) != aField.rawValue;
	}
	catch (exception) 
	{
		throw cException.createInstance("System.hasCurrentFieldValueChanged() "
			  + "encountered a problem: " + exception);
	}
}

/**
 * Handles all top level exceptions that may potentially cause data corruption
 * or form crash. This is typically called when an exception is generated from
 * event triggers on the form. Note that this function will prompt a pop-up
 * message to inform the user to do a save as on the form instead of save. It
 * will then lock the form.
 * @param anException a top level Exception that was thrown, this is logged
 *		  inside of the form.
 * @param aMessage (optional) a String message that is customized to the user.
 *					Defaults to message inform users to perform a SaveAs if no
 *					none specified.
 * @param unlockForm (optional) a Boolean that indicates if the form should be
 *					  unlocked or not. Defaults to false.
 */
function processUnhandledException(anException, aMessage, unlockForm)
{
	cLog.critical("processUnhandledException", anException);
	cLog.flushFileCache();
	if (aMessage == null)
	{
		if(anException.className == "LocalizedException")
		{
			// LocalizedExceptions provide messages that are intended for the 
			//   applicant, so they are displayed
			xfa.host.messageBox(anException.getMessage());
		}
		else
		{
			// display a generic message
			xfa.host.messageBox(cResourceManager.get("message_saveAs"));
		}
	}
	else
	{
		// display a specific message
		xfa.host.messageBox(aMessage);
	}
	if (unlockForm == null || unlockForm != true)
	{
		cFormNodeManager.getBaseNode().lock();
		xfa.host.messageBox(cResourceManager.get("message_locked"));
	}
}

/**
 * Sets the current field that the user is about to edit. This should be called
 * as part of the "enter" event processing on all fields where the value before
 * editing must be retained. This must be called as a precursor to using
 * getCurrentFieldPrevValue() and hasCurrentFieldValueChanged().
 * @param aField the Adobe field or exclusion group node that is about to be
 *		  edited. Note that it makes more sense to register the radio button
 *		  group (known as an exclusion group) as a whole rather than its
 *		  individual radio buttons.
 * @throws an UnexpectedDataType Exception if aField is undefined, null, or
 *		   isn't an Adobe Field or Exclusion Group.
 */
function setCurrentField(aField)
{
	if (!cTypeChecker.isSpecificCustomObject(aField, cTypeEnforcer.FIELD_CLASS)
		&amp;&amp; !cTypeChecker.isSpecificCustomObject(aField, cTypeEnforcer
												.EXCLUSION_GROUP_CLASS))
	{
		throw cException.createInstance("System.setCurrentField(aField) " 
			  + "requires a Field or ExclusionGroup value, not a " 
			  + cObjectUtil.getDescription(aField));	
	}

	currentField = aField;
	currentFieldPrevValue  = aField.rawValue;
}

</script>
            <script contentType="application/x-javascript" name="dataStore">var oJSUtil = Pla.script.core.util.js; 
var oDebug = Pla.script.core.util.debug;

/**
* save XML to data
* @param some the parent node's som expression
* @param keyPath the object's name (or som expression part)
* @param o the xml to save
*/
function setXML(some, keyPath, o)
{
	xfa.resolveNode(some + "." + keyPath).loadXML(o);
}

/**
* save an object to data
* @param some the parent node's som expression
* @param keyPath the object's name (or som expression part)
* @param o the object to save
*/
function setObject(some, keyPath, o)
{
	for(var key in o)
	{		
		var newKeyPath = keyPath + "." + key;
		var value = o[key];
		
		setInstanceVar(some, newKeyPath, value);
	}
}

/**
* save an array to data
* @param some the parent node's som expression
* @param keyPath the object's name (or som expression part)
* @param o the array to save
*/
function setArray(some, keyPath, o)
{
	setInstanceVar(some, keyPath + ".objectType", "array");
	
	for(var i = 0; i &lt; o.length; i++)
	{
		var newKeyPath = keyPath + ".item[" + i + "]";
		var value = o[i];			
	
		setInstanceVar(some, newKeyPath, value);
	}
}

/**
* save a variant to data (where a variant is variable of unknown type)
* @param some the parent node's som expression
* @param keyPath the object's name (or som expression part)
* @param o the variant to save
*/
function setInstanceVar(some, keyPath, o)
{
	if(o === null)
	{			
		var path = getPath(some, keyPath);
		removeNode(path);
	}
	else if(o instanceof Function)
	{			
		// don't save
	}
	else if(o instanceof Array)
	{						
		setArray(some, keyPath, o);
	}
	else if(o instanceof Object)
	{			
		setObject(some, keyPath, o);
	}
	else 
	{
		setString(some, keyPath, o);
	}
}

/**
* recreate a variant from data and it's class
* @param some the parent node's som expression
* @param keyPath the object's name (or som expression part)
* @return variant This can be an Object, Array or String (floats and integers are stored as strings)
*/
function getInstanceVar(some, keyPath)
{
	// get node
	var oNode;
	
	if(arguments.length == 1) // oNode passed in
	{
		oNode = arguments[0];
	}	
	else if(arguments.length == 2) // somExpression and key passed in
	{
		var some = arguments[0];
		var keyPath = arguments[1];
		oNode = getDataNode(some, keyPath);
	}

	var msg = "";

	// determine data type, then extract data
	if(oNode &amp;&amp; oNode.className == "dataGroup")
	{	
		//var oObjectType = oNode.resolveNode("objectType");
		var oObjectType = xfa.resolveNode(oNode.somExpression + ".objectType[0]");
		
		if(oObjectType &amp;&amp; oObjectType.value == "array") // Array
		{			
			var a = [];
			
			for(var i = 0; i &lt; oNode.nodes.length; i++)
			{
				var oItem = oNode.nodes.item(i);
				
				if(oItem.name == "item")
				{			
					a[a.length] = getInstanceVar(oItem);
				}				
			}		

			return a; // return the array
		}
		else // Object
		{
			var o = {};
			
			for(var i = 0; i &lt; oNode.nodes.length; i++)
			{
				var oItem = oNode.nodes.item(i);
				o[oItem.name] = getInstanceVar(oItem);
			}
			
			return o; // return the object
		}
	}
	else // Leaf node
	{
		return (oNode &amp;&amp; oNode.value)? oNode.value : ""; // return the value
	}
}


function getDataNode(som, key)
{
	var path = getPath(som, key);
	return xfa.datasets.resolveNode(path);
}

/**
* Usage:
* getVar(key)
* getVar(parent_key, key)
*/
function getVar()
{
	if(arguments.length == 1)
	{		
		return getInstanceVar(Pla.somExpression, "variables." + arguments[0]);
	}
	else if(arguments.length == 2)
	{	
		return getInstanceVar(Pla.somExpression, "variables." + arguments[0] + "." + arguments[1]);
	}
	
}

/**
* Usage:
* setVar(key, value)
* setVar(parent_key, key, value)
*/
function setVar(som, value)
{
	if(arguments.length == 2)
	{
		path = "variables." + arguments[0];
		setInstanceVar(Pla.somExpression, "variables." + arguments[0], arguments[1]);		
	}
	else if(arguments.length == 3)
	{
		setInstanceVar(Pla.somExpression, "variables." + arguments[0] + "." + arguments[1], arguments[2]);
	}	
}

function setString(som, key, value)
{
	var path = getPath(som, key);
	
	if(path === false) 
	{
		oDebug.dbg("setInstanceVar: not a node:" + som + "," + key + "," + value);
	}	
	else
	{		
		setValue(path, value);						
	}
}

function hasInstanceVar(som)
{
	var path;
	
	if(arguments.length &gt; 1)
	{
		path = getPath(som, arguments[1]);
	}
	else
	{
		path = getPath(som);
	}

	if(path === false) 
	{
		return false;
	}
	else
	{	
		var oNode = xfa.datasets.resolveNode(path);			

		if(oNode) 
		{		
			return true;		
		}		
		return false;
	}		
}

function formatSom(som)
{
	var aRequested = som.split(".");
	var formattedSOM = "xfa[0].datasets[0]";
	for(var i = 0; i &lt; aRequested.length; i++)
	{		
		var s = aRequested[i];
		if(s.match(/\[\d+\]/))
		{
			formattedSOM += "." + s;
		}
		else
		{
			formattedSOM += "." + s + "[0]";
		}		
	}
	return formattedSOM;
}

/**
* getPath
* Find the SOM expression for data associated with a SOM node
* @param som a node's som expresion
* @param key a path for data relating to a node
* @return string the data's path, or false on failure
*/
function getPath(som, key)
{
	var oNode = xfa.resolveNode(som);

	if(oNode)
	{
		// sections that may have a data node
		if(oNode.className == "subform" 
		|| oNode.className == "field" 
		|| oNode.className == "exclGroup")
		{		
			var oDataNode = oNode.dataNode;
			var isGlobal = (oNode.bind &amp;&amp; oNode.bind.match == "global");
			var needle = "xfa[0].datasets[0].data[0].";	
			
			// If it's globally bound we need to keep the variable data seperate, so use the som node
			// If there isn't a data node, use the som node
			if(!oDataNode || isGlobal)
			{				
				// There's no data node.  Use somNode instead.
				oDataNode = oNode;		
				needle = "xfa[0].form[0].";	
			}
							 	
			// build the path
			if(oNode.parent.className == "exclGroup")
			{
				var oParentNode = oDataNode.parent;
				var grandParentSom = oParentNode.parent.somExpression.replace(needle, "data[0]."); 				
			 				
				som = grandParentSom + "." + oParentNode.name + "Var[" + oParentNode.index + "]." + oNode.name;
			}
			else if(oNode.className == "exclGroup"
			|| oNode.className == "field")
			{		
				// remove the datasets ancestry, it's added later
			 	var parentSom = oDataNode.parent.somExpression.replace(needle, "data[0]."); 	
			 				
				som = parentSom + "." + oNode.name + "Var[" + oNode.index + "]";
			}
			else // subform
			{			
			 	som = oDataNode.somExpression.replace(needle, "data[0]."); 			 			 		 				
			}
		}
		else // draw - won't have a data node
		{			
			var parentSom = oNode.parent.somExpression.replace("xfa[0].form[0].", "data[0]."); 	
			som = parentSom + "." + oNode.name + "Var[" + oNode.index + "]";		 		 				
		}
		
	}
	else
	{
		return false;
	}
	
	if(key)
	{
		return som + "." + key;
	}
	else
	{
		return som;
	}
	
}

function setValue(som, value)
{
	//var oNode = makePath(som);
	//oNode.value = oJSUtil.string(value);
	xfa.datasets.assignNode(som, oJSUtil.string(value), 0);	
}

/**
* makePath
* creates nodes required to complete "som", if they're not already made
* 
* @param som The som expression to create, if needed* 
* @return the node of the som expression
*/
function makePath(som)
{	
	var aSection = som.split(".");
	var oSection = xfa.datasets;
	var len = aSection.length;
	var reInstance = /\[(\d+)\]/;

	for(var i = 0; i &lt; len; i++)
	{		
		var oTmpSection = xfa.resolveNode(oSection.somExpression + "." + aSection[i]);
	
		if(!oTmpSection)
		{				
			var sectionSome = aSection[i];
			var nodeName = sectionSome;
			var aMatch = sectionSome.match(reInstance)
			var inst = 0;
			var nodeClassName = ((i+1) == len)? "dataValue" : "dataGroup";
			
			// requesting a specific instance
			if(aMatch &amp;&amp; aMatch.length &gt; 0)
			{
				nodeName = sectionSome.replace(/\[\d+\]/, "");
				inst = aMatch[0];	
			}
			
			oTmpSection = makePathInstances(oSection, nodeName, inst, nodeClassName);			
		}
		oSection = oTmpSection;
	}
	
	return oSection;
}

/**
* makePathInstances
* makes instances required for a given node instance
* i.e. given sfInst[4], creates sfInst[0] through sfInst[4] if they don't already exist
* this function assumes that sfInst[4] doesn't exist
*
* @param oSection The parent node
* @param nodeName The to-be-created-node's name, i.e. sfInst
* @param inst The requested instance, i.e. 4
* @param nodeClassName The className of the node to be created, options include dataGroup or dataValue
* @return oTmpSection the requested instance, i.e. the node of sfInst[4]
*/
function makePathInstances(oSection, nodeName, inst, nodeClassName)
{
	var prevInst = inst-1;
	
	if(inst &gt; 0)
	{
		var oPrevSection = xfa.resolveNode(oSection.somExpression + "." + nodeName + "[" + prevInst + "]");
		
		if(!oPrevSection)
		{
			makePathInstances(oSection, nodeName, prevInst, nodeClassName);
		}
	}
	
	// add an instance
	var oTmpSection = xfa.datasets.createNode(nodeClassName, nodeName);
	if(nodeClassName == "dataGroup")
	{
		//oTmpSection.setAttribute("It Works", "test");
	}
	oSection.nodes.append(oTmpSection);
	
	return oTmpSection;
}

// debugging function to see if make path is behaving
function testMakePath(som, oSection)
{
	if(formatSom(som) != oSection.somExpression)
	{
		oDebug.dbg("makeSOM: " + requested + "\n\t--&gt;" + oSection.somExpression);
		debugMakePath(som);
	}
}

function debugMakePath(som)
{
	var aSection = som.split(".");
	var oSection = xfa.datasets;
	var len = aSection.length;
	
	for(var i = 0; i &lt; len; i++)
	{		
		var oTmpSection = oSection.resolveNode(aSection[i]);
		oDebug.dbg("\t" + aSection[i] + "-&gt;" + oTmpSection.somExpression);		

		if(!oTmpSection)
		{							
			oTmpSection = xfa.datasets.createNode(((i+1) == len)? "dataValue" : "dataGroup",aSection[i]);
			oDebug.dbg("\tCREATE:" + oTmpSection.somExpression);	
			oSection.nodes.append(oTmpSection);
		}
		oSection = oTmpSection;
	}

	oDebug.dbg("PATH:" + oSection.somExpression);	

	return oSection;
}

function removeNode(som)
{
	var oNode = xfa.datasets.resolveNode(som);
	if(oNode)
	{
		oNode.parent.nodes.remove(oNode);
	}
}
</script>
            <script contentType="application/x-javascript" name="fieldState">
var oDataStore = Pla.script.core.dataStore;
var oJSUtil = Pla.script.core.util.js; 
var oXFAUtil = Pla.script.core.util.xfaUtil;
var oDebug = Pla.script.core.util.debug; 

function debugState(oNode, key, title)
{
	//var s = oDataStore.getInstanceVar(oNode.somExpression, key + ".debug");
	//oDataStore.setInstanceVar(oNode.somExpression, key + ".debug", s + "\n\t" + title + ":" + oNode.somExpression);
}

function saveState(oNode)
{
	var state = (arguments.length &gt; 1)? arguments[1] : "save"; // save or lock
	
	var oState = {};

	if(oNode.access)
	{
		oState["access"] = oNode.access;		
	}
	
	if(oNode.border.fill.presence)
	{
		oState["fillpres"] = oNode.border.fill.presence;	
	}
	
	if(oNode.border.edge.presence)
	{
		oState["edgepres"] = oNode.border.edge.presence;		
	}
	
	if(oNode.border.fill.color.value)
	{
		oState["fillColor"] = oNode.border.fill.color.value;		
	}
	
	if(oNode.presence)
	{
		oState["pres"] = oNode.presence;		
	}
	
	if(oNode.mandatory)
	{
		oState["required"] = (oNode.mandatory == "error")? "1" : "0";		
	}
	
	var oChoiceList = oNode.resolveNode("ui.#choiceList");
	if(oChoiceList)
	{
		oState["ddlTextEntry"] = oChoiceList.textEntry;
	}

	oDataStore.setInstanceVar(oNode.somExpression, state, oState);
}

function setFieldRequired(oNode, tf)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "required");

	oDataStore.setInstanceVar(oNode.somExpression, state + ".required", (tf)? "1" : "0");
}

function setFieldColour(oNode, s)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "fillcolor");

	oDataStore.setInstanceVar(oNode.somExpression, state + ".fillColor", s);
}

function setFillPresence(oNode, s)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "fillpres");

	oDataStore.setInstanceVar(oNode.somExpression, state + ".fillpres", s);
}

function setEdgePresence(oNode, s)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "edgepres");
	
	oDataStore.setInstanceVar(oNode.somExpression, state + ".edgepres", s);
}

function setFieldAccess(oNode, s)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "access");	

	oDataStore.setInstanceVar(oNode.somExpression, state + ".access", s);
}

function setFieldPresence(oNode, s)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "pres");

	oDataStore.setInstanceVar(oNode.somExpression, state + ".pres", s);
}

function setDDLTextEntry(oNode, s)
{
	var state = (arguments.length &gt; 2)? arguments[2] : "save"; // save or lock
	
	debugState(oNode, state, "ddlTextEntry");

	oDataStore.setInstanceVar(oNode.somExpression, state + ".ddlTextEntry", s);
}

function applyState(oNode)
{
	var state = (arguments.length &gt; 1)? arguments[1] : "save"; // save or lock

	var oState = oDataStore.getInstanceVar(oNode.somExpression, state);

	if(oState)
	{			
		var s;
		s = oJSUtil.string(oState.access);
		if(s != "") 
		{
			oNode.access = s;	
		}
		
		s = oJSUtil.string(oState.fillColor);
		if(s != "") 
		{			
			oNode.fillColor = s;							
		}
		
		s = oJSUtil.string(oState.fillpres);
		if(s != "") 
		{
			oNode.border.fill.presence = s;
		}
		
		s = oJSUtil.string(oState.edgepres);
		if(s != "") 
		{
			oNode.border.edge.presence = s;
		}
		
		s = oJSUtil.string(oState.pres);
		if(s != "") 
		{
			oNode.presence = s;		
		}
		
		s = oJSUtil.string(oState.required);
		if(s != "") 
		{
			oNode.mandatory = (s == "1")? "error" : "";		
		}
		
		s = oJSUtil.string(oState.ddlTextEntry);
		if(s != "") 
		{			
			var oChoiceList = oNode.resolveNode("ui.#choiceList");
			if(oChoiceList)
			{
				oChoiceList.textEntry = s;
			}
		}
	}
}

function clearState(oNode)
{
	var state = (arguments.length &gt; 1)? arguments[1] : "save"; // save or lock or validation
	
	debugState(oNode, state, "clear");
/*
	oDataStore.setInstanceVar(oNode.somExpression, state + ".access", null);	
	oDataStore.setInstanceVar(oNode.somExpression, state + ".fillColor", null);	
	oDataStore.setInstanceVar(oNode.somExpression, state + ".edgepres", null);
	oDataStore.setInstanceVar(oNode.somExpression, state + ".fillpres", null);
	oDataStore.setInstanceVar(oNode.somExpression, state + ".pres", null);	*/
	oDataStore.setInstanceVar(oNode.somExpression, state, null);
}

function hasStateData(oNode)
{
	var state = (arguments.length &gt; 1)? arguments[1] : "save"; // save or lock

	return oDataStore.hasInstanceVar(oNode.somExpression, state);
}

function applyFieldStateForBranch(oNode)
{
	var state = (arguments.length &gt; 1)? arguments[1] : "save"; // save or lock
	
	oXFAUtil.walkAll(oNode, applyState, state);
}

function clearFieldStateForBranch(oNode)
{
	var state = (arguments.length &gt; 1)? arguments[1] : "save"; // save or lock
	
	oXFAUtil.walkAll(oNode, clearState, state);
}
</script>
            <script contentType="application/x-javascript" name="_localization">var oEmbeddedList = Pla.script.business.da.embeddedLists;

var language = "";
var cLog = script.core.util.Log;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;

var aMsg = new Array();
aMsg["en"] = new Array();
aMsg["fr"] = new Array();

var aLbl = new Array();
aLbl["en"] = new Array();
aLbl["fr"] = new Array();

var aLblXml = new Array();
aLblXml["en"] = new Array();
aLblXml["fr"] = new Array();

var aTT = new Array();
aTT["en"] = new Array();
aTT["fr"] = new Array();

// for LTG
setMsg("STERILE", "Sterile", "Stérile");
setMsg("MERCURY_YES", "This product contains mercury (", "Ce produit contient du mercure (");
setMsg("PRODUCT_USES", "This product uses", "Ce produit utilise");
setMsg("PRESERVATIVES", "as preservatives.", "comme agent de conservation");
setMsg("PRODUCT_CONTAINS", "This product also contains", "Ce produit contient aussi");
setMsg("FLAME_PROJ", "Flame Projection Length/Flashback:", "Longueur de la projection ou retour de la flamme:");
setMsg("EXCEPT_SITUATION", "(except in situations that", "(sauf dans les siuations où");
setMsg("CONTAINS_EUCALYPTUS", "This product contains more than 25% Eucalyptus oil.", "Ce produit contient plus de 25% d'huile d'eucalyptus");
setMsg("CONTAINS_CAMPHOR", "This product contains more than 2.5% camphor.", "Ce produit contient plus de 2.5% de camphre");
setMsg("VALIDATION_SUCCESS", "Label Text Validation completed", "Validation du texte d'étiquette terminée");
setMsg("VALIDATION_NOT_DONE", "Label Text Validation not yet completed", "Validation du texte d'étiquette pas encore terminée");
setMsg("VALIDATION_FAILED", "Label Text Validation failed", "Validation du texte d'étiquette échouée");
setMsg("LT_ECW", "KEEP OUT OF REACH OF CHILDREN, NOT TO BE TAKEN ORALLY", "TENIR HORS DE PORTÉE DES ENFANTS, NE PAS INGÉRER PAR VOIE ORALE");
setMsg("LT_SECURITY", "Security feature is self-evident.", "Le dispositif de sécurité est évident par lui-même.");
setMsg("P5_VALLBLTXT", "You must validate the label text before you can continue", "Vous devez valider le texte d'étiquette avant de pouvoir continuer");
setMsg("LTG_IMPORTER_NONE_CHECKED", "At least one importer must be selected.", "Au moins un importateur devrait être sélectionné.");
setMsg("LTG_DURATION","Use of this product beyond &lt;DURATION&gt; &lt;DURATION_UNIT&gt;(s) is not recommended.", "L'utilisation de ce produit pendant plus de &lt;DURATION&gt; &lt;DURATION_UNIT&gt;(s) n'est pas recommandé.");
setMsg("GLT_QCE", "QCE", "QBE");

setMsg("HIDDEN_SECTIONS", "Some required fields have not been filled.\nPlease expand all hidden sections to find error fields!", "Certains champs requis ne sont pas remplis.  Veuillez élargir les sections cachées to pour les champs avec erreurs!");
setMsg("IMPORTER_NAME_ADDRESS", "Importer company name and address to be provided.", "Nom et adresse de l'entreprise importatrice pour être fournis.");
setMsg("TIMES_A_DAY", "times a day", "fois par jour");
setMsg("TIMES_A", " time(s) per ", " fois par ");
setMsg("NA", "N/A", "N/D");
setMsg("ORIGINAL_FIELD_EMPTY", "original field is empty!", "le champs d'origine est vide!");
setMsg("YES", "Yes", "Oui");
setMsg("NO", "No", "Non");
setMsg("EXP", "Exp: YY MM", "Exp: AA MM");

setMsg("PIS_MINMAX_NEITHER", "Otherwise, for ", "Autrement, pour ");
setMsg("PIS_MINMAX_MIN", "For minimun of ", "Pour un minimum de ");
setMsg("PIS_MINMAX_MAX", "For maximum of ", "Pour maximum de ");

// LTG
setMsg("LTG_FP1", "Caution, Flammable\r\nDo not use in presence of open flame or spark.", "Mise en garde, Inflammable\r\nNe pas utilser en présence d'étincelles.");
setMsg("LTG_FP2", "Warning, Flammable\r\nDo not use in presence of open flame or spark.", "Avertissement, Inflammable\r\nNe pas utilser en présence d'étincelles.");
setMsg("LTG_FP3", "Danger, Extremely Flammable\r\nDo not use in presence of open flame or spark.", "Danger, Extrêmement inflammable\r\nNe pas utilser en présence d'étincelles.");
setMsg("LTG_FP4", "Danger, Extremely Flammable\r\nDo not use in presence of open flame or spark.", "Danger, Extrêmement inflammable\r\nNe pas utilser en présence d'étincelles.");
setMsg("TEXT_ENTRY", "---Text Entry", "---Entrée de texte");


// messages, usually for popups (try to keep in alphabetical order)
setMsg("AGREEMENT_NOT_CHECKED", "Please read the agreement above and check \"I agree\" to proceed.", "Veuillez lire l’accord susmentionné et cocher «J’accepte» pour continuer.");
setMsg("ATF_LACTOSE", "Lactose", "Lactose");
setMsg("CHANGE_TYPE_OF_APPLICATION", "Please note that all currently entered medicinal and non-medicinal information will be removed if you change the application type to compendial. Do you wish to proceed with changing the application type?", "Veuillez noter que toute information médicinale et non médicinale indiquée sera enlevée si vous changez le type de demande à officinale. Voulez-vous continuer à changer le type de demande?");
setMsg("DOSAGE_EXTRATIO_LT_MIN", "A ratio of &lt;RULE&gt; was expected but the calculated ratio of &lt;INPUT&gt; is smaller.","Un ratio de &lt;RULE&gt; était attendu mais le ratio calculé de &lt;INPUT&gt; est plus petit.");
setMsg("DOSAGE_EXTRATIO_GT_MAX", "A ratio of &lt;RULE&gt; was expected but the calculated ratio of &lt;INPUT&gt; is larger.","Un ratio de &lt;RULE&gt; était attendu mais le ratio calculé de &lt;INPUT&gt; est plus grand.");
setMsg("DOSAGE_FREQ_OVERMAX", "The recommended dosage entered has exceeded the permitted maximum amount.  Frequency limit: &lt;RULE_MIN&gt; - &lt;RULE_MAX&gt; Actual: &lt;TEST_MIN&gt; - &lt;TEST_MAX&gt;", "La posologie indiquée a dépassée le montant maximum permis.  Limite de fréquence:  &lt;RULE_MIN&gt; - &lt;RULE_MAX&gt;   Actuel:  &lt;TEST_MIN&gt; - &lt;TEST_MAX&gt;");
setMsg("DOSAGE_FREQ_UNDERMIN", "The recommended dosage entered is less than the permitted minimum amount.   Frequency limit: &lt;RULE_MIN&gt; - &lt;RULE_MAX&gt; Actual: &lt;TEST_MIN&gt; - &lt;TEST_MAX&gt;", "La posologie indiquée est plus basse que le montant minimum permis.  Limite de fréquence:  &lt;RULE_MIN&gt; - &lt;RULE_MAX&gt;   Actuel:  &lt;TEST_MIN&gt; - &lt;TEST_MAX&gt;");
setMsg("DOSAGE_MIN_GT_MAX_DU", "The minimum dosage unit must not be greater than the maximum dosage unit.", "L'unité posologique minimum ne doit pas être plus grande que l'unité posologique maximum.");
setMsg("DOSAGE_MIN_GT_MAX_FREQ", "The minimum frequency must not be greater than the maximum frequency.", "La fréquence minimum ne doit pas être plus grande que la fréquence maximum.");
setMsg("DOSAGE_NEED_SID", "One or more required constituent is missing.", "Un ou plusieurs des constituants requises sont manquantes.");
setMsg("DOSAGE_NONE_VALID", "An incompatible or invalid selection has been made.  Please refer to the monograph.", "Une sélection qui est incompatible ou qui n'est pas valable a été faite.  Veuilllez faire référence à la monographie.");
setMsg("DOSAGE_OVERMAX", "The recommended dosage entered has exceeded the permitted maximum &lt;RESTRICTION_TYPE&gt; amount.  Dosage limit: &lt;RULE_DOSAGE&gt; Actual: &lt;TEST_DOSAGE&gt;", "La posologie indiquée a dépassée le montant maximum &lt;RESTRICTION_TYPE&gt; permis.  Limite de posologie:  &lt;RULE_DOSAGE&gt;   Actuel:  &lt;TEST_DOSAGE&gt;");
setMsg("DOSAGE_QCE_NE", "The entered Quantity Crude Equivalent amount of &lt;QCE&gt; does not equal the ingredient quantity of &lt;AMT&gt;", "La quantité brute équivalente indiquée &lt;QCE&gt; n'est pas égale à la quantité d'ingrédient &lt;AMT&gt;");
setMsg("DOSAGE_RESTRICTION_TYPE_DD","daily","journalier"); // for use with DOSAGE_OVERMAX and DOSAGE_UNDERMIN
setMsg("DOSAGE_RESTRICTION_TYPE_SD","single dose","d'unité posologique"); // for use with DOSAGE_OVERMAX and DOSAGE_UNDERMIN
setMsg("DOSAGE_SIRATIO_RANGE", "The ratio between &lt;PRIMARY_SI&gt; and &lt;SECONDARY_SI&gt; must be between &lt;MIN_RATIO&gt; and &lt;MAX_RATIO&gt;, but &lt;ENTERED_RATIO&gt; was computed.", "Le rapport entre &lt;PRIMARY_SI&gt; et &lt;SECONDARY_SI&gt; doit être entre &lt;MIN_RATIO&gt; et &lt;MAX_RATIO&gt;, mais &lt;ENTERED_RATIO&gt; a été calculé.");
setMsg("DOSAGE_UNDERMIN", "The recommended dosage entered is less than the permitted minimum &lt;RESTRICTION_TYPE&gt; amount.  Dosage limit: &lt;RULE_DOSAGE&gt; Actual: &lt;TEST_DOSAGE&gt;", "La posologie indiquée est plus basse que le montant minimum &lt;RESTRICTION_TYPE&gt; permis.  Limite de posologie:  &lt;RULE_DOSAGE&gt;   Actuel:  &lt;TEST_DOSAGE&gt;");
setMsg("MANDATORY_FIELDS", "Some required fields have not been filled.", "Certains champs requis n’ont pas été remplis.");
setMsg("INVALID_SEARCH_CRITERIA","Sorry, the characters ? ; } { \" ' are not allowed in the search keyword.","Malheureusement, les caractères ? ; } { \" ' ne sont pas permis pour la recherche.");
setMsg("MANDATORY_FIELDS", "Some required fields have not been filled.", "Certains champs requis n’ont pas été remplis.");
setMsg("NEW_ATF","An Animal Tissue Form has been appended to this document, and will require completion in order to submit the Product Licence Application form.","Un formulaire de tissu animal a été ajouté à ce document, et devra être complété pour pouvoir soumettre une Demande de Licence de Mise en Marché.");
setMsg("NONE", "none", "aucun");
setMsg("NONE_STORAGE", "None", "Aucun");
setMsg("NO_MI", "All natural health product submissions must have at least one medicinal ingredient.", "Toutes le présentations de produits de santé naturels doivent avoir au moins un ingrédient médicinal.");
setMsg("NO_RECOMMENDED_USE", "All natural health product submissions must have at least one recommended use or purpose.", "Toutes le présentations de produits de santé naturels doivent avoir au moins un usage ou fins recommandés.");
setMsg("NO_SPECIFIC_USE", "Homeopathic with specific claim submissions must have at least one recommended use or purpose.", "Les demandes homéopathiques avec usage/fin recommandés précis doivent avoir au moins un usage ou fin recommandé.");
setMsg("ONE_CONTACT_ONLY", "Only one contact may be selected to receive the licence.", "Une seule personne-ressource doit être choisie pour recevoir la licence.");
setMsg("OVERRIDE", "You have chosen to not search the NHP Ingredients Database.  Please note that a change request form has been added to the end of the Product Licence Application form.", "Vous avez choisi de ne pas faire une recherche dans la base de données PSN.  Veuillez noter qu'un formulaire de demande de changement a été ajouté à la suite du formulaire de demande de licence de mise en marché.");
setMsg("OVERRIDE_NMI_COMPENDIAL","Your choice of 'Manual Entry' for a non-medicinal ingredient in a Compendial application means that you can only add an ingredient not found in the NHP Ingredients Database with either a 'Flavor enhancer' or a 'Fragrance' Purpose.  Please note that a change request form has been added to the end of the Product Licence Application form.","Votre choix d'entrée manuelle pour un ingrédient non médicinal dans une soumission officinale résulte à un ajout d'ingrédient ne faisant pas partie de la base de données des ingrédients PSN avec une fin soit d'exhausteur de goût ou soit de parfum.  Veuillez noter qu'un formulaire de problèmes a été ajouté à la Demande de Licence de Mise en Marché.");
setMsg("OVERRIDE_RECOMMENDED_DOSE", "You have chosen to add your own subpopulation because you considered incomplete the list of Sub-population groups.  Please note that limited validation of the recommended dose associated with this subpopulation will be taking place.", "Vous avez choisi d'ajouter votre propre sous-population parce que vous considerez la liste de sous-populations comme étant incomplète.  Veuillez noter qu'il y aura une validation limitée de la posolgie recommandée pour cette sous-population.");
setMsg("P1SA_CONTACT_NE_CANADA", "The representative in Canada (Part D) must reside in Canada.", "Le représentant au Canada (Partie D) doi être un résident du Canada.");
setMsg("P4_DQNE1", "The quantity defined in fields 77a and 77b is the single dose quantity corresponding to a single dosage unit.  If millillitre is select as the dosage unit in the Recommended Dose section in Part 4 - D, then the quantity in field 77a must be 1 and the provided Quantity Crude Equivalent must be adjusted accordingly.  Alternatively, you can select another dosage unit (teaspoon, tablespoon, etc) corresponding to a single dose.","La quantité définie dans les champs 77a et 77b est pour une dose unique correspondant à une unité posologique.  Si on choisi millilitre comme unité posologique dans la section Dose recommandée de la Partie 4 - D, il se doit que la quantité du champs 77a soit 1 et que la quantité brute équivalente soit ajustée.  Une autre possibilité serait de choisir une unité posologique (cuillère à thé, cuillère à table, etc) qui correspond à une dose unique.");
setMsg("P4PI_DOU_1", "Consult a health care practitioner for prolonged use.", "Avant d'en faire un usage prolongé, consulter un praticien de soins de santé.");
setMsg("P4PI_RISK_1", "Consult a health care practitioner if symptoms persist or worsen.", "Consulter un praticien de soins de santé si les symptômes persistent ou s'aggravent. ");
setMsg("P4PI_RISK_2", "Consult a health care practitioner before use if you are pregnant or breastfeeding.", "Consulter un praticien de soins de santé avant d'en faire l'usage si vous êtes enceinte ou si vous allaitez.");
setMsg("RATIO_GT1", "The calculated ratio of &lt;RATIO&gt; is invalid because it must always be a value greater than 1", "The ratio calculé de &lt;RATIO&gt; est invalide car il doit toujours être plus grand que 1.");
setMsg("URL_LANG_PARAM", "&amp;lang=eng", "&amp;lang=fra");
setMsg("VALIDATION_SECTION_OK", "This section is complete.", "Cette section est complète.");
setMsg("WSERR_TN", "There was an error while acquiring the tracking number.  Click \"Yes\" to try again, or \"No\" to try again later.", "Il y eut une erreur lors de l'acquisition du numéro de suivi.  Cliquer \"oui\" pour essayer de nouveau, ou \"non\" pour essayer de nouveau plus tard.");

//HMLS--
setMsg("Potency Msg", "The Potency Quantity must be &lt;QUANTITY_LIST&gt; or above", "Le taux de dilution doit être &lt;QUANTITY_LIST&gt; ou plus" );
setMsg("Potency Msg1", "The Potency Quantity must be 4X,4D,4DH or above", "Le taux de dilution doit être 4X,4D,4DH ou plus" );
setMsg("Potency Msg2", "The Potency Quantity must be 2C, 2CH, 2CK or above", "Le taux de dilution doit être 2C, 2CH, 2CK ou plus" );
setMsg("Potency Msg3", "The Potency Quantity must be 24X, 24D, 24DH or above", "Le taux de dilution doit être 24X, 24D, 24DH ou plus" );
setMsg("Potency Msg4", "The Potency Quantity must be 12C, 12CH, 12CK or above", "Le taux de dilution doit être 12C, 12CH, 12CK ou plus" );
setMsg("Potency Msg5", "The Potency Quantity must be 5.06LM, 5.06Q or above", "Le taux de dilution doit être 5.06LM, 5.06Q ou plus" );
setMsg("Potency Msg6", "The Potency Quantity must be 0.004M, 0.004MK or above","Le taux de dilution doit être 0.004M, 0.004MK ou plus");
setMsg("Potency Msg7", "The Potency Quantity must be 0.8434LM, 0.8434Q or above","Le taux de dilution doit être 0.8434LM, 0.8434Q ou plus");
setMsg("Potency Msg8", "The Potency Quantity must be or 0.024M, 0.024MK or above, or above","Le taux de dilution doit être 0.024M, 0.024MK ou plus");
setMsg("LTE_DURATION", "Use of this product beyond &lt;DURATION&gt; &lt;DURATION_UNIT&gt;(s) is not recommended.", "L'utilisation de ce produit pendant plus de &lt;DURATION&gt; &lt;DURATION_UNIT&gt;(s) n'est pas recommandé.");

///////////////////////////////////////////////////////////
// alternate labels (look at the :AAAA)

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].txtNPN[0]:Default", "55. NPN:", "55. NPN :");
setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].txtNPN[0]:Homeopathic", "55. DIN-HM:", "55. DIN-HM :");

setLbl("P1SA_SOURCE", "Source", "Source");
setLbl("P1SA_SOURCE_ADD", "Add a Source", "Ajoutez une Source");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicDisclaimer[0].lblDisclaimer[0]:SpecificClaim", "Any claim indicated or implied in the brand name must be supported by evidence.", "Toute allégation indiquée ou tacite provenant de la marque nominative doit être soutenue par des preuves à l'appui.");
setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicDisclaimer[0].lblDisclaimer[0]:Default", "This product is for general homeopathic medicine claim only. The brand name must not indicate or imply a specific claim, recommended use or purpose.", "Ce produit sert seulement pour une allégation générale de médicament homéopathique. La marque nominative ne doit pas indiquer ou insinuer une allégation spécifique, un usage ou fin recommandé.");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHMPotencyMsg[0].lblHMPotencyMsg[0]:SpecificClaim", "When the Homeopathic Potency is above 30CH or below the minimum OTC limit as described in the Homeopathic Pharmacopeoias, then additional scientific rationale must be submitted.", "Lorsque le taux de dilution est supérieur à 30CH ou inférieur à la limite des produits en vente libre comme décrite dans les pharmacopées homéopathiques, une justification scientifique additionnelle doit être soumise.");
setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHMPotencyMsg[0].lblHMPotencyMsg[0]:NonSpecificClaim", "When the Homeopathic Potency is below the minimum OTC limit as described in the Homeopathic Pharmacopeoias, then additional scientific rationale must be submitted.", "Lorsque le taux de dilution est inférieur à la limite des produits en vente libre comme décrite dans les pharmacopées homéopathiques, une justification scientifique additionnelle doit être soumise.");

setLblXml("xfa[0].form[0].Pla[0].sfAttestation[0].lblAttestation[0]:Default", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;\" I attest that the natural health product that is the subject of this product license application will be manufactured, packaged, labelled,&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;distributed and stored:&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;a)&lt;span style=\"xfa-spacerun:yes\"&gt;   &lt;/span&gt;If the natural health product is imported, in accordance with the 'Good Manufacturing Practices' requirements as set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3 of the Natural Health Products Regulations or in accordance with requirements that are equivalent to those set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3, or&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;b)&lt;span style=\"xfa-spacerun:yes\"&gt;   &lt;/span&gt;If the natural health product is not imported, in accordance with the 'Good Manufacturing Practices' requirements set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3 of the Natural Health Products Regulations.&lt;/p&gt;&lt;p style=\"line-height:12pt;text-decoration:none\"&gt;I, the undersigned, certify that the information and material included in this product licence application is accurate and complete. By clicking on the ‘I Agree ’ button and generating the Attestation Code, this generated code is confirmation of my attestation and will serve as authentication of this fact in the future”.&lt;/p&gt;&lt;p style=\"line-height:12pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", 
"&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;«J'atteste que le produit de santé naturel faisant l'objet de cette demande de mise en marché sera fabriqué, emballé, étiqueté, distribué et entreposé&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt\"&gt;a) en vertu des exigences relatives aux bonnes pratiques de fabrication tel que le prescrit la partie 3 du Règlement sur les produits de santé naturels ou en vertu des exigences équivalentes à celles précisées dans la partie 3 (si le produit de santé naturel est importé);&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt\"&gt;b) en vertu des exigences relatives aux bonnes pratiques de fabrication tel que le prescrit la partie 3 du Règlement sur les produits de santé naturels (si le produit de santé naturel n'est pas importé).&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;Je, soussigné, certifie que l'information et le matériel inclus dans cette demande de licence de mise en marché sont exacts et complets. En cliquant sur  le bouton J'Accepte   et en générant le Code d'attestation, ce code généré devient une confirmation de mon attestation et servira comme authentication de ce fait dans le futur. » &lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/body&gt;");
setLblXml("xfa[0].form[0].Pla[0].sfAttestation[0].lblAttestation[0]:HMLS", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;\"I attest that the natural health product that is the subject of this product license application conforms in its entirety to the Homeopathic Medicines (HM) Labelling Standard as described above. I, the undersigned, certify that the information and material included in this product licence application is accurate and complete and that one of the following statements is true:&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;I have revised and attached all relevant pages of the Product Licence Application form and/or one or more of the following documents: Label, Finished Product Specification, and Animal Tissue Form.&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt; I have reviewed the Product Licence Application form and other required documents and confirm that no further revisions or modifications are required in order to comply with the HM Labelling Standard.\"&lt;/p&gt;&lt;/body&gt;", 
"&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;J'atteste que le produit de santé naturel faisant l'objet de la présente demande de licence de mise en marché est conforme en tout point à la Norme d'étiquetage des produits homéopathiques (PH), telle qu'elle est décrite plus haut. Je, soussigné(e), certifie que les renseignements et les documents qui accompagnent cette demande de licence de mise en marché du produit sont exacts et complets, et que l'un des énoncés suivants est vrai :&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt; &lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;J'ai revu et joint toutes les pages pertinentes du « Formulaire de demande de licence de mise en marché » et/ou l'un ou plusieurs des documents suivants : étiquette, spécifications du produit fini et Formulaire pour les tissus d'origine animale.&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;J'ai revu le « Formulaire de demande de licence de mise en marché » et les autres documents exigés, et je confirme qu'aucune autre révision ou modification ultérieure n'est requise pour assurer la conformité du produit à la Norme d'étiquetage des produits homéopathiques.&lt;/p&gt;&lt;/body&gt;");
setLblXml("xfa[0].form[0].Pla[0].sfAttestation[0].lblAttestation[0]:Homeopathic", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;\" I attest that the natural health product that is the subject of this product license application will be manufactured, packaged, labelled,&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;distributed and stored:&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;a)&lt;span style=\"xfa-spacerun:yes\"&gt;   &lt;/span&gt;If the natural health product is imported, in accordance with the 'Good Manufacturing Practices' requirements as set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3 of the Natural Health Products Regulations or in accordance with requirements that are equivalent to those set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3, or&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;b)&lt;span style=\"xfa-spacerun:yes\"&gt;   &lt;/span&gt;If the natural health product is not imported, in accordance with the 'Good Manufacturing Practices' requirements set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3 of the Natural Health Products Regulations.&lt;/p&gt;&lt;p style=\"line-height:12pt;text-decoration:none\"&gt;I, the undersigned, certify that the information and material included in this product licence application is accurate and complete. By clicking on the ‘I Agree ’ button and generating the Attestation Code, this generated code is confirmation of my attestation and will serve as authentication of this fact in the future”.&lt;/p&gt;&lt;p style=\"line-height:12pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", 
"&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;«J'atteste que le produit de santé naturel faisant l'objet de cette demande de mise en marché sera fabriqué, emballé, étiqueté, distribué et entreposé&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt\"&gt;a) en vertu des exigences relatives aux bonnes pratiques de fabrication tel que le prescrit la partie 3 du Règlement sur les produits de santé naturels ou en vertu des exigences équivalentes à celles précisées dans la partie 3 (si le produit de santé naturel est importé);&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt\"&gt;b) en vertu des exigences relatives aux bonnes pratiques de fabrication tel que le prescrit la partie 3 du Règlement sur les produits de santé naturels (si le produit de santé naturel n'est pas importé).&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;Je, soussigné, certifie que l'information et le matériel inclus dans cette demande de licence de mise en marché sont exacts et complets. En cliquant sur  le bouton J'Accepte   et en générant le Code d'attestation, ce code généré devient une confirmation de mon attestation et servira comme authentication de ce fait dans le futur. » &lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/body&gt;");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].txtNPN[0]:Default", "Natural Product Number (NPN):", "Numéro du produit naturel (NPN) :");
setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].txtNPN[0]:Homeopathic", "DIN-HM:", "DIN-HM :");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfFrontPanel[0].txtNPN[0]:Default", "Natural Product Number (NPN):", "Numéro du produit naturel (NPN) :");
setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfFrontPanel[0].txtNPN[0]:Homeopathic", "DIN-HM:", "DIN-HM :");

///////////////////////////////////////////////////////////
// Master Page Captions
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].FormPage[0].lblVersion[0]","VERSION","VERSION");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].FormPage[0].lblMandatory[0]","* - denotes mandatory","* - indique obligatoire");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].FormPage[0].lblAnimalTissue[0]","** - if yes, complete Animal Tissue Form","** - si oui, veuillez compléter un formulaire de tissu animal");
setLblXml("xfa[0].form[0].Pla[0].#pageSet[0].FormPage[0].Pages[0]","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField022986\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt; of&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField003483\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt;&lt;/p&gt;&lt;/body&gt;","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField022986\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt; de&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField003483\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt;&lt;/p&gt;&lt;/body&gt;");
setLblXml("xfa[0].form[0].Pla[0].#pageSet[0].FormPage[0].lblProtected[0]","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Protected When Completed&lt;/p&gt;&lt;p&gt;Protégé une fois rempli&lt;/p&gt;&lt;/body&gt;","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Protected When Completed&lt;/p&gt;&lt;p&gt;Protégé une fois rempli&lt;/p&gt;&lt;/body&gt;");

setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnPrint1[0]","Print","Imprimer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnClose1[0]","Close","Fermer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnPrint2[0]","Print","Imprimer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnClose2[0]","Close","Fermer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnPrint3[0]","Print","Imprimer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnClose3[0]","Close","Fermer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnPrint4[0]","Print","Imprimer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].btnClose4[0]","Close","Fermer");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].lblVersion[0]","VERSION","VERSION");
setLblXml("xfa[0].form[0].Pla[0].#pageSet[0].part4Summary[0].Pages[0]","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField022986\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt; of&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField003483\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt;&lt;/p&gt;&lt;/body&gt;","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField011478\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt; de&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField015724\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt;&lt;/p&gt;&lt;/body&gt;");

setLbl("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].lblVersion[0]","Version","Version");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].lblCopyForm[0]","Copy this form as necessary","Veuillez copier ce formulaire lorsque c'est requis");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].btViewText[0]","View Label Text","Voir le texte de l'étiquette");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].btValidate[0]","Validate","Valider");
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].btClose[0]","Close","Fermer");
setLblXml("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].Pages[0]","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField018467\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt; of&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField006334\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt;&lt;/p&gt;&lt;/body&gt;","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField018467\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt; de&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embed=\"#floatingField006334\" xfa:embedMode=\"raw\" xfa:embedType=\"uri\"/&gt;&lt;/p&gt;&lt;/body&gt;");
setLblXml("xfa[0].form[0].Pla[0].#pageSet[0].tool[0].lbltextMsg[0]","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;&lt;span xfa:embedType=\"uri\" xfa:embedMode=\"raw\" xfa:embed=\"#floatingField000041\"/&gt;&lt;/p&gt;&lt;/body&gt;","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;&lt;span xfa:embedType=\"uri\" xfa:embedMode=\"raw\" xfa:embed=\"#floatingField000041\"/&gt;&lt;/p&gt;&lt;/body&gt;");
 
setLbl("xfa[0].form[0].Pla[0].#pageSet[0].labelPage[0].lblVersion[0]","Version","Version");
setLblXml("xfa[0].form[0].Pla[0].#pageSet[0].labelPage[0].Pages[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embedType=\"uri\" xfa:embedMode=\"raw\" xfa:embed=\"#floatingField026500\"/&gt; of&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embedType=\"uri\" xfa:embedMode=\"raw\" xfa:embed=\"#floatingField019169\"/&gt;&lt;/p&gt;&lt;/body&gt;","&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Page&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embedType=\"uri\" xfa:embedMode=\"raw\" xfa:embed=\"#floatingField026500\"/&gt; de&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span xfa:embedType=\"uri\" xfa:embedMode=\"raw\" xfa:embed=\"#floatingField019169\"/&gt;&lt;/p&gt;&lt;/body&gt;");

///////////////////////////////////////////////////////////
// Caption and Tooltip configuration
// - this can be refreshed using the "Mr. XDP" tool

setLblXml("xfa[0].form[0].Pla[0].sfFMWSMsg[0].lblBody[0]", "&lt;body xmlns='http://www.w3.org/1999/xhtml' xmlns:xfa='http://www.xfa.org/schema/xfa-data/1.0/' xfa:APIVersion='2.4.5277.0'&gt;&lt;/body&gt;", "&lt;body xmlns='http://www.w3.org/1999/xhtml' xmlns:xfa='http://www.xfa.org/schema/xfa-data/1.0/' xfa:APIVersion='2.4.5277.0'&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfFMWSMsg[0].lblBody[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfFMWSMsg[0].btnUrl[0]", "Download the latest form", "Download the latest form _FR");
setTT("xfa[0].form[0].Pla[0].sfFMWSMsg[0].btnUrl[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValid[0].lblHeader[0]", "The form has been completed. Please save your form and submit it to the NHPD via mail or using PosteCS.", "Le formulaire a été complété. Veuillez sauvegarder votre formulaire et le soumettre à la DPSN soit par courrier ou soit en utilisant PosteCS.");
setTT("xfa[0].form[0].Pla[0].sfMsgValid[0].lblHeader[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValid[0].btnModify[0]", "Modify", "Modifier");
setTT("xfa[0].form[0].Pla[0].sfMsgValid[0].btnModify[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValid[0].btnNew[0]", "New Application", "Nouvelle demande");
setTT("xfa[0].form[0].Pla[0].sfMsgValid[0].btnNew[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValid[0].btnPLChange[0]", "Post-Licence Change", "Changements après délivrance de la licence");
setTT("xfa[0].form[0].Pla[0].sfMsgValid[0].btnPLChange[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfHeader[0].lblProtected[0]", "Protected When Completed", "Protégé une fois rempli");
setTT("xfa[0].form[0].Pla[0].sfHeader[0].lblProtected[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfHeader[0].lblTitle[0]", "PRODUCT LICENCE APPLICATION FORM\r\nNatural Health Products Directorate", "FORMULAIRE DE DEMANDE DE LICENCE DE MISE EN MARCHÉ\nDirection des produits de santé naturels");
setTT("xfa[0].form[0].Pla[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfHeader[0].lblTrackingNumber[0]", "1. Tracking Number", "1. Numéro de suivi");
setTT("xfa[0].form[0].Pla[0].sfHeader[0].lblTrackingNumber[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfHeader[0].txtBrandName[0]", "Primary Brand Name *", "Marque nominative principale");
setTT("xfa[0].form[0].Pla[0].sfHeader[0].txtBrandName[0]", "", "");

//setLbl("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]", cResourceManager.get("ENGLISH"), cResourceManager.get("ENGLISH"));
//setLbl("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]", "English", "English");
//setTT("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkFrancais[0]", "Français", "Français");
setTT("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkFrancais[0]", "", "");

/*
setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfHeading[0].lblHeading[0]", "PART 1 - APPLICANT AND CONTACT INFORMATION", "PARTIE 1 - DEMANDEUR ET COORDONNÉES");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].lblHeading[0]", "A. - APPLICANT OR LICENSEE (This is the product licence holder)", "A. – DEMANDEUR OU TITULAIRE (qui sera le détenteur de la licence)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtApplicantName[0]", "4. Applicant/Company Name *", "4. Nom du demandeur/de l’entreprise");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtApplicantName[0]", "Indicate the full legal name of the\r\napplicant/company in whose name the subject NHP\r\napplication is being filed. Do not abbreviate the\r\napplicant/company name.  ", "Indiquez le nom légal complet du demandeur ou de la\r\nsociété pour lequel ou laquelle on dépose la\r\ndemande de PSN. N’utilisez pas d’abréviations du\r\nnom du demandeur ou de la société.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtCompanyCode[0]", "5. Company Code (if known)", "5. Code de l'entreprise (s'il est connu)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtCompanyCode[0]", "The number assigned to each applicant company by\r\nthe NHPD. This number will be indicated in the\r\nacknowledgement letter sent by the NHPD to\r\nacknowledge the receipt of a submission. This\r\ninformation need only be provided if the company\r\ncode is known. If not known, leave blank.", "Le numéro attitré à chaque société demanderesse par\r\nla DPSN. Ce numéro sera indiqué dans l’accusé de\r\nréception envoyé par la DPSN pour accuser réception\r\nd’une présentation. Cette information ne doit être\r\nfournie que si le code de la société est connu. Si\r\ninconnu, laissez blanc.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtAddress[0]", "6. Address: Street/Suite/Land Location *", "6. Adresse Rue/bureau/ B.P.");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtAddress[0]", "Provide the full mailing address of the\r\napplicant/company identified in Section 4. If a\r\nstreet address is used, provide the suite/unit\r\nnumber (if applicable) in addition to the street\r\nand street number (6), the city/town (7), the\r\nprovince/state (9), the country (8) and the postal\r\nor zip code (10). Include the PO Box number (6) if\r\na post office box is used.", "Fournissez l’adresse postale complète de la société (p. ex. : non pas l’emplacement de l’activité en question). Si vous utilisez une adresse de bureau, fournissez le numéro de la suite/unité (s’il y a lieu) en plus de la rue et du numéro de la rue (64), la ville (65), la province/état (67), le pays (66) et le code postal ou le code de zone (68). Ajoutez le numéro de B.P. (64) si une boîte postale est utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtCity[0]", "7. City - Town *", "7. Ville");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtCity[0]", "Provide the full mailing address of the\r\napplicant/company identified in Section 4. If a\r\nstreet address is used, provide the suite/unit\r\nnumber (if applicable) in addition to the street\r\nand street number (6), the city/town (7), the\r\nprovince/state (9), the country (8) and the postal\r\nor zip code (10). Include the PO Box number (6) if\r\na post office box is used.", "Fournissez l’adresse postale complète de la société (p. ex. : non pas l’emplacement de l’activité en question). Si vous utilisez une adresse de bureau, fournissez le numéro de la suite/unité (s’il y a lieu) en plus de la rue et du numéro de la rue (64), la ville (65), la province/état (67), le pays (66) et le code postal ou le code de zone (68). Ajoutez le numéro de B.P. (64) si une boîte postale est utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].ddlProvince[0]", "9. Province - State", "9. Province/état");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].ddlProvince[0]", "Provide the full mailing address of the\r\napplicant/company identified in Section 4. If a\r\nstreet address is used, provide the suite/unit\r\nnumber (if applicable) in addition to the street\r\nand street number (6), the city/town (7), the\r\nprovince/state (9), the country (8) and the postal\r\nor zip code (10). Include the PO Box number (6) if\r\na post office box is used.", "Fournissez l’adresse postale complète de la société (p. ex. : non pas l’emplacement de l’activité en question). Si vous utilisez une adresse de bureau, fournissez le numéro de la suite/unité (s’il y a lieu) en plus de la rue et du numéro de la rue (64), la ville (65), la province/état (67), le pays (66) et le code postal ou le code de zone (68). Ajoutez le numéro de B.P. (64) si une boîte postale est utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].ddlCountry[0]", "8. Country *", "8. Pays");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].ddlCountry[0]", "Provide the full mailing address of the\r\napplicant/company identified in Section 4. If a\r\nstreet address is used, provide the suite/unit\r\nnumber (if applicable) in addition to the street\r\nand street number (6), the city/town (7), the\r\nprovince/state (9), the country (8) and the postal\r\nor zip code (10). Include the PO Box number (6) if\r\na post office box is used.", "Fournissez l’adresse postale complète de la société (p. ex. : non pas l’emplacement de l’activité en question). Si vous utilisez une adresse de bureau, fournissez le numéro de la suite/unité (s’il y a lieu) en plus de la rue et du numéro de la rue (64), la ville (65), la province/état (67), le pays (66) et le code postal ou le code de zone (68). Ajoutez le numéro de B.P. (64) si une boîte postale est utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtPostalCode[0]", "10. Postal/ZIP Code", "10. Code postal/code de zone");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].txtPostalCode[0]", "Provide the full mailing address of the\r\napplicant/company identified in Section 4. If a\r\nstreet address is used, provide the suite/unit\r\nnumber (if applicable) in addition to the street\r\nand street number (6), the city/town (7), the\r\nprovince/state (9), the country (8) and the postal\r\nor zip code (10). Include the PO Box number (6) if\r\na post office box is used.", "Fournissez l’adresse postale complète de la société (p. ex. : non pas l’emplacement de l’activité en question). Si vous utilisez une adresse de bureau, fournissez le numéro de la suite/unité (s’il y a lieu) en plus de la rue et du numéro de la rue (64), la ville (65), la province/état (67), le pays (66) et le code postal ou le code de zone (68). Ajoutez le numéro de B.P. (64) si une boîte postale est utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlLanguage[0]", "13. Language preferred:", "13. Langue de choix");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlLanguage[0]", "Provide the Language Preference of the Senior\r\nOfficial", "Fournissez la  préférence linguistique du principal\r\nresponsable");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].lblHeading[0]", "B. - SENIOR OFFICIAL (This is the name of the principal contact person for the applicant/company)", "B. – CADRE SUPÉRIEUR (Ce sera le nom de la personne-ressource principale pour le demandeur/de l’entreprise)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].lblHeading[0]", "", "");

//setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtSurname[0]", cResourceManager.get("SURNAME"), cResourceManager.get("SURNAME"));
setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtSurname[0]", "Surname *", "Nom de famille");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtSurname[0]", "Provide the Surname of the Senior Official ", "Fournissez le nom de famille du cadre supérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtTitle[0]", "12. Title", "12. Titre");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtTitle[0]", "Provide the Title of the Senior Official ", "Fournissez le titre du cadre supérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtGivenName[0]", "Given Name *", "Prénom");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtGivenName[0]", "Provide the Given Name of the Senior Official ", "Fournissez le prénom du cadre supérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].lblName[0]", "11. Name", "11. Nom");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].lblName[0]", "", "Fournissez le nom du cadre supérieur en entier.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtCompanyName[0]", "14. Company Name (* if different from Applicant / Licensee)", "14. Nom de l'entreprise (*s'il diffère de celui du demandeur/titulaire)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtCompanyName[0]", "Provide the company name (if different than\r\napplicant/licensee)", "Fournissez le nom de la société (si différent du\r\ndemandeur/licencié)");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlSameAddressAsA[0]", "15. Address same as Applicant/Licensee", "15. Même adresse que le Demandeur/Titulaire");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlSameAddressAsA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtAddress[0]", "16. Street/Suite/PO Box *", "16. Rue/bureau/ B.P.");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtAddress[0]", "Provide the full mailing address of the Senior\r\nOfficial", "Fournissez l'adresse postale complète du principal\r\nresponsible");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtCity[0]", "17. City - Town *", "17. Ville");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtCity[0]", "Provide the full mailing address of the Senior\r\nOfficial", "Fournissez l'adresse postale complète du principal\r\nresponsible");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlProvince[0]", "19. Province - State", "19. Province/état");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlProvince[0]", "Provide the full mailing address of the Senior\r\nOfficial", "Fournissez l'adresse postale complète du principal\r\nresponsible");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlCountry[0]", "18. Country *", "18. Pays");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlCountry[0]", "Provide the full mailing address of the Senior\r\nOfficial", "Fournissez l'adresse postale complète du principal\r\nresponsible");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtPostalCode[0]", "20. Postal/ZIP Code", "20. Code postal/code de zone");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtPostalCode[0]", "Provide the full mailing address of the Senior\r\nOfficial", "Fournissez l'adresse postale complète du principal\r\nresponsible");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtTelephone[0]", "21. Telephone No. *", "21. Numéro de téléphone");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtTelephone[0]", "Provide the Telephone Number of the Senior Official", "Fournissez le numéro de téléphone du cadre\r\nsupérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtExtension[0]", "Ext.", "Poste");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtExtension[0]", "Provide the Telephone Number of the Senior Official", "Fournissez le numéro de téléphone du cadre\r\nsupérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtFax[0]", "22. Fax No.", "22. Numéro de télécopieur");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtFax[0]", "Provide the Fax Number of the Senior Official", "Fournissez le numéro de télécopieur du cadre\r\nsupérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtEmail[0]", "23. E-mail", "23. Courriel");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtEmail[0]", "Provide the email address of the Senior Official", "Fournissez le courriel du cadre supérieur");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfHeader[0].lblHeading[0]", "C. - CONTACT FOR THIS APPLICATION (This is the contact person for product-specific questions)", "C. – PERSONNE-RESSOURCE POUR CETTE DEMANDE (Ce sera le nom de la personne-ressource qui répondra aux questions précises portant sur le produit)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfHeader[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfHeader[0].btnAdd[0]", "Add a Contact", "Ajoutez une personne-resource");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfHeader[0].btnAdd[0]", "", "La personne-ressource recevra les questions de la\r\nDPSN spécifiques au produit.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtSurname[0]", "Surname *", "Nom de famille");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtSurname[0]", "Provide the Surname of the contact for this\r\napplication ", "Fournissez le nom de famille de la\r\npersonne-ressource pour cette demande.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtTitle[0]", "26. Title", "26. Titre");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtTitle[0]", "Provide the Title of the contact for this\r\napplication ", "Fournissez le titre de la personne-ressource pour\r\ncette demande.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtGivenName[0]", "Given Name *", "Prénom");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtGivenName[0]", "Provide the Given Name of the contact for this\r\napplication ", "Fournissez le prénom de la personne-ressource pour\r\ncette demande.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].lblName[0]", "25. Name", "25. Nom");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].lblName[0]", "", "Fournissez le nom de la personne-ressource pour\r\ncette demande");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtCompanyName[0]", "28. Company Name (* if different from Applicant / Licensee)", "28. Nom de l'entreprise (* s'il diffère de celui du demandeur/titulaire)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtCompanyName[0]", "Provide the company name (if different than\r\napplicant/licensee) ", "Fournissez le nom de la société (si différent du\r\ndemandeur/licencié)");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSameAddressAsA[0]", "29. Address same as Applicant/Licensee", "29. Même adresse que le Demandeur/Titulaire");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSameAddressAsA[0]", "", "Fournissez l'adresse postale complète du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtAddress[0]", "30. Street/Suite/PO Box *", "30. Rue/bureau/ B.P. *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtAddress[0]", "Provide the full mailing address of the Contact", "Fournissez l'adresse postale complète du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtCity[0]", "31. City - Town *", "31. Ville *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtCity[0]", "Provide the full mailing address of the Contact", "Fournissez l'adresse postale complète du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlProvince[0]", "33. Province - State", "33. Province/état");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlProvince[0]", "Provide the full mailing address of the Contact", "Fournissez l'adresse postale complète du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlCountry[0]", "32. Country *", "32. Pays *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlCountry[0]", "Provide the full mailing address of the Contact", "Fournissez l'adresse postale complète du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtPostalCode[0]", "34. Postal/ZIP Code", "34. Code postal/code de zone");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtPostalCode[0]", "Provide the full mailing address of the Contact", "Fournissez l'adresse postale complète du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtTelephone[0]", "35. Telephone No. *", "35. Numéro de téléphone *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtTelephone[0]", "Provide the Telephone Number of the Contact", "Fournissez le numéro de téléphone du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtExtension[0]", "Ext.", "Poste");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtExtension[0]", "Provide the Telephone Number of the Contact", "Fournissez le numéro de téléphone du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtFax[0]", "36. Fax No.", "36. Numéro de télécopieur");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtFax[0]", "Provide the Fax Number of the Contact", "Fournissez le numéro de télécopieur du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtEmail[0]", "37. E-mail", "37. Courriel");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].txtEmail[0]", "Provide the email address of the Contact", "Fournissez le courriel du contact");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlLanguage[0]", "27. Language preferred:", "27. Langue de choix");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlLanguage[0]", "Provide the Language Preference of the contact for\r\nthis application ", "Fournissez  préférence linguistique de la\r\npersonne-ressource pour cette demande");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSameAsSeniorOfficial[0]", "24. Contact same as Senior Official", "24. Personne-ressource même que le cadre supérieur");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSameAsSeniorOfficial[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].btnAdd[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfHeader[0].lblHeading[0]", "D. - REPRESENTATIVE IN CANADA (Only required where Address in \"A\" is not in Canada)", "D. – REPRÉSENTANT AU CANADA (Requis seulement si l’adresse « A » n’est pas au Canada)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfHeader[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlSameAsContact[0]", "38. Representative in Canada same as Contact", "38. Représentant au Canada même que la personne-ressource");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlSameAsContact[0]", "", "Le représentant au Canada est la personne à qui la\r\nDPSN enverra le courrier réglementaire et qui est\r\nresponsable de la vente de ce produit au Canada.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtSurname[0]", "Surname *", "Nom de famille *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtSurname[0]", "Provide the Surname of the representative in Canada\r\n", "Fournissez le nom de famille de la\r\npersonne-ressource pour cette demande.");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtTitle[0]", "40. Title", "40. Titre");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtTitle[0]", "Provide the Title of the representative in Canada ", "Fournissez le titre du représentant au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtGivenName[0]", "Given Name *", "Prénom *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtGivenName[0]", "Provide the Given name of the representative in\r\nCanada ", "Fournissez le prénom du représentant au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].lblName[0]", "39. Name", "39. Nom");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].lblName[0]", "", "Fournissez le nom du responsable au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtCompanyName[0]", "42. Company Name (* if different from Applicant / Licensee)", "42. Nom de l'entreprise (*s'il diffère de celui du demandeur/titulaire)");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtCompanyName[0]", "Provide the company name (if different from\r\napplicant/licensee) ", "Fournissez le nom de la société (si différent du\r\ndemandeur/licencié)");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtAddress[0]", "44. Street/Suite/PO Box *", "44. Rue/bureau/ B.P. *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtAddress[0]", "Provide the full mailing address of the\r\nrepresentative in Canada ", "Fournissez l’adresse postale complète du\r\nresponsable au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtCity[0]", "45. City - Town *", "45. Ville *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtCity[0]", "Provide the full mailing address of the\r\nrepresentative in Canada ", "Fournissez l’adresse postale complète du\r\nresponsable au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlProvince[0]", "47. Province - State", "47. Province/état");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlProvince[0]", "Provide the full mailing address of the\r\nrepresentative in Canada ", "Fournissez l’adresse postale complète du\r\nresponsable au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtCountry[0]", "46. Country", "46. Pays");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtCountry[0]", "Provide the full mailing address of the\r\nrepresentative in Canada ", "Fournissez l’adresse postale complète du\r\nresponsable au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtPostalCode[0]", "48. Postal/ZIP Code", "48. Code postal/code de zone");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtPostalCode[0]", "Provide the full mailing address of the\r\nrepresentative in Canada ", "Fournissez l’adresse postale complète du\r\nresponsable au Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtTelephone[0]", "49. Telephone No. *", "49. Numéro de téléphone *");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtTelephone[0]", "Provide the Telephone Number of the representative\r\nin Canada ", "Fournissez le numéros de téléphone du responsable\r\nau Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtExtension[0]", "Ext.", "Poste");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtExtension[0]", "Provide the Telephone Number of the representative\r\nin Canada ", "Fournissez le numéros de téléphone du responsable\r\nau Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtFax[0]", "50. Fax No.", "50. Numéro de télécopieur");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtFax[0]", "Provide the Fax Number of the representative in\r\nCanada ", "Fournissez le numéros de télécopieur du responsible\r\nau Canada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtEmail[0]", "51. E-mail", "51. Courriel");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].txtEmail[0]", "Provide the Email Address of the representative in\r\nCanada ", "Fournissez l'adresse électronique du responsible au\r\nCanada");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlLanguage[0]", "41. Language preferred:", "41. Langue de choix");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlLanguage[0]", "Provide the Language Preference of the\r\nrepresentative in Canada ", "Fournissez  préférence linguistique de la\r\npersonne-ressource pour cette demande");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].lblHeading[0]", "E. - CONTACT TO WHOM THE PRODUCT LICENCE IS TO BE SENT", "E. – PERSONNE-RESSOURCE À QUI L’ON DOIT ENVOYER LA LICENCE DE MISE EN MARCHÉ");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].ddlContactToReceiveLicence[0]", "52. Contact to Whom Product Licence is to be Sent *", "52. Personne-ressource à qui l'on doit envoyer la licence de mise en marché");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].ddlContactToReceiveLicence[0]", "Once a product licence is granted by the NHPD, the\r\nlicence and an issuance letter will be mailed (and\r\nfaxed) to a single individual indicated in section\r\n52. This individual may be the senior official of\r\nthe company (indicated in Part 1, Block B), the\r\ncontact for the application (indicated in Part 1,\r\nBlock C) or the Canadian representative (indicated\r\nin Part 1, Block D). If the individual to whom the\r\nproduct licence should be sent is not listed in\r\nBlock B, C, or D (i.e. may be one of the additional\r\ncontacts provided on an additional page) please\r\ncheck \"not applicable\" and indicate the name beside\r\nthe box. The person identified must be someone on\r\nthe product licence application form or on the\r\nattached list of other submission contacts for the\r\napplication, and must have a Canadian mailing\r\naddress. The term \"not applicable\" may also apply\r\nin cases where the product licence application form\r\nis used, but no licence will be issued (e.g. some\r\ntypes of notifications, etc.). If this section is\r\nnot filled out or is filled out incorrectly (e.g.\r\nis a person not indicated on the product licence\r\napplication form or the attached list, etc.) the\r\nperson to whom the product licence and issuance\r\nletter will be sent by default will be the senior\r\nofficial indicated in Part 1, Block B if the\r\naddress provided is located in Canada or the\r\nrepresentative in Canada indicated in Part 1, Block\r\nD if the senior official indicated is located\r\noutside of Canada.   Please note that only one copy\r\nof the licence will be issued. If a copy of the\r\nlicence is desired to be sent to multiple contacts,\r\nit is the responsibility of the individual to whom\r\nthe licence is sent to distribute additional\r\ncopies. Please see the Submission Management\r\nguidance document for further information on the\r\nlicence issuance process.", "Lorsque la licence de mise en marché est délivrée par la DPSN, la licence et la lettre de délivrance seront postées (et télécopiées) à une seule personne indiquée dans la section 52. Cette personne peut être le principal responsable de la société (indiquée dans la partie 1, bloc B), la personne-ressource pour la demande (indiquée dans la partie 1, bloc C) ou le représentant au Canada (indiqué dans la partie 1, bloc D). Si la personne à qui l’on envoie la licence de mise en marché n’est pas indiquée dans le bloc B, C ou D (p. ex. : peut être l’une des autres personnes-ressources présentées sur une autre page), veuillez cocher « sans objet » et indiquez le nom à côté de la case. La personne identifiée doit être une personne incluse sur le formulaire de demande de licence de mise en marché ou sur la liste jointe contenant les autres personnes-ressources de présentation de la demande, et doivent avoir une adresse postale canadienne. Le terme « sans objet » peut aussi s’appliquer dans les cas où l’on utilise le formulaire de demande de licence de mise en marché, mais qu’aucune licence ne sera délivrée (p. ex. : certains types de notifications, etc.). Si cette section n’est pas remplie ou n’est pas remplie correctement (p. ex. : référence à une personne non indiquée sur le formulaire de demande de licence de mise en marché ou sur la liste connexe, etc.), la personne par défaut à qui l’on enverra la licence du produit et la lettre de délivrance sera le principal responsable indiqué dans la partie 1, bloc B si l’adresse fournie se trouve au Canada ou le représentant au Canada indiqué dans la partie 1, bloc D si le principal responsable se trouve à l’extérieur du Canada. Veuillez noter qu’une seule copie de la licence sera délivrée. Si l’on veut qu’une copie de la licence soit envoyée à plusieurs personnes-ressources, la personne à qui l’on envoie la licence est responsable de la distribution des copies supplémentaires. ");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].txtName[0]", "Name if Not Applicable", "Nom si sans objet");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].txtName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfValidate[0].btnSubmit[0]", "Continue", "Continuer");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfValidate[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart1[0].sfModify[0].btnSubmit[0]", "Modify Form", "Modifier formulaire");
setTT("xfa[0].form[0].Pla[0].sfPart1[0].sfModify[0].btnSubmit[0]", "", "");
*/
setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfHeading[0].lblHeading[0]", "PART 2 - APPLICATION TYPE", "PARTIE 2 - TYPE DE PRÉSENTATION");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].lblHeading[0]", "A. - PRODUCT LICENCE APPLICATION", "A. – DEMANDE DE LICENCE DE MISE EN MARCHÉ");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].ddlHypotheticalFormulation[0]", "54. Hypothetical Formulation", "54. Est-ce une formulation hypothétique?");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].ddlHypotheticalFormulation[0]", "Hypothetical formulations are those which have been\r\ndescribed in the Product Licence Application form\r\nbut are only at the planning stage and have not\r\nreached the manufacturing stage. For that reason,\r\ncertain types of evidence that would be available\r\nfor a product already manufactured, such as batch\r\nrecords, may not be available. Alternative sources\r\nof evidence for the quality information needed to\r\nmeet the regulatory requirements are described in\r\nthe Evidence for the Quality of Finished Natural\r\nHealth Products guidance document.", "licence de mise en marché, mais qui ne sont pas à\r\nla phase de fabrication, seulement à la phase de\r\nplanification. Pour cette raison, certains types de\r\npreuve qui seraient disponibles pour un produit\r\ndéjà fabriqué, comme des dossiers de lots de\r\nfabrication, pourraient ne pas être disponibles.\r\nLes sources alternatives de preuves pour\r\nl’information de qualité nécessaire pour répondre\r\naux exigences réglementaires sont décrites dans le\r\ndocument de référence Preuves attestant de la\r\nqualité des produits de santé naturels finis.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].ddlTypeOfApplication[0]", "53. Type of Application *", "53. Type de demande");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].ddlTypeOfApplication[0]", "There are seven different types of applications: \r\ncompendial, traditional, non-traditional,\r\nhomeopathic, TPD category IV/labelling standard,\r\nhomeopathic DIN and transitional DIN.  Please see\r\nChapter 2 of the Product Licensing guidance\r\ndocument for a definition of each type of\r\nsubmission and their related submission\r\nrequirements. Please indicate only one type of\r\nsubmission. ", "Il y a sept types différents de demandes :\r\nofficinale, traditionnelle, non traditionnelle,\r\nhoméopathique, norme d’étiquetage/catégorie IV TPD,\r\nDIN homéopathique et DIN transitoire. Veuillez vous\r\nreporter au chapitre 2 du document de référence\r\nLicence de mise en marché pour une définition de\r\nchaque type de présentation et exigences de\r\nprésentation connexes. Indiquez seulement un type\r\nde présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].txtDIN[0]", "53a. Drug Identification Number", "53a. Identification numérique de drogue");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].txtDIN[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].lblHeading[0]", "B. POST-LICENCE CHANGE", "B. CHANGEMENTS APRÈS DÉLIVRANCE DE LA LICENCE");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].chkPLChange[0]", "Post-Licence Change", "Changements après délivrance de la licence");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].chkPLChange[0]", "", "");

//setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].txtNPN[0]", "NPN:", "NPN :");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionB[0].txtNPN[0]", "Indicate the number of supporting documents\r\nincluded with this submission.", "Indiquez le nombre de documents à l’appui inclus avec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sfHeading[0].lblHeading[0]", "E. - SUBMISSION CONTENT", "E. – CONTENU DE LA PRÉSENTATION");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sfHeading[0].lbl59[0]", "59. Type of supporting documents, by volume:  indicate the volume in which the document is submitted", "Type de documents à l’appui, par volume : cochez le type applicable et indiquez le volume de présentation du document.");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sfHeading[0].lbl59[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59a[0].txt59a1[0]", "59a-1. Count of Mail-in Designated Party Authorization Attachments *", "59a-1. Nombre de formulaires d'autorisation de la partie désignée postées");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59a[0].txt59a1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59a[0].lbl59a[0]", "59a. Designated Party Authorization", "59a. Autorisation de la partie désignée");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59a[0].lbl59a[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].txt59b1[0]", "59b-1. Count of Mail-in Label Text Attachments *", "59b-1. Nombre d'étiquettes postées");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].txt59b1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].txt59b2[0]", "59b-2. Count of Generated Label Text Attachments *", "59b-2. Nombre d'étiquettes générées par ordinateur");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].txt59b2[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].txt59b3[0]", "59b-3. Count of Label Text Attachments *", "59b-3. Nombre d'étiquettes annexées en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].txt59b3[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].lbl59b[0]", "59b. Label Text", "59b. Texte de l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59b[0].lbl59b[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59c[0].lbl59c[0]", "59c. TPD Label Text ", "59c. Texte de l'étiquette TPD");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59c[0].lbl59c[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59c[0].txt59c1[0]", "59c-1. Count of Mail-in TPD Label Text Submissions *", "59c-1. Nombre de textes d'étiquette TPD postés");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59c[0].txt59c1[0]", "Indicate the number of supporting documents\r\nincluded with this application.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59c[0].txt59c2[0]", "59c-2. Count of TPD Label Text Submissions *", "59c-2. Nombre de textes d'étiquette TPD annexés en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59c[0].txt59c2[0]", "Indicate the number of supporting documents\r\nincluded with this application.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59d[0].lbl59d[0]", "59d. Evidence Summary Report", "59d. Rapport de synthèse sur les preuves");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59d[0].lbl59d[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59d[0].txt59d1[0]", "59d-1. Count of Mail-in Evidence Summary Report Attachments *", "59d-1. Nombre de rapports de synthèse sur les preuves postés");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59d[0].txt59d1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59d[0].txt59d2[0]", "59d-2. Count of Evidence Summary Report Attachments *", "59d-2. Nombre de rapports de synthèse sur les preuves annexés en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59d[0].txt59d2[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59e[0].txt59e1[0]", "59e-1. Count of Mail-in References Attachments *", "59e-1. Nombre de références postées");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59e[0].txt59e1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59e[0].txt59e2[0]", "59e-2. Count of References Attachments *", "59e-2. Nombre de références annexées en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59e[0].txt59e2[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59e[0].lbl59e[0]", "59e. References", "59e. Références");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59e[0].lbl59e[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59f[0].lbl59f[0]", "59f. Safety Summary Report", "59f. Rapport de synthèse sur l’innocuité");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59f[0].lbl59f[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59f[0].txt59f1[0]", "59f-1.Count of Mail-in Safety Summary Report Attachments *", "59f-1. Nombre de rapports de synthèse sur l'innocuité postés");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59f[0].txt59f1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59f[0].txt59f2[0]", "59f-2. Count of Safety Summary Report Attachments *", "59f-2. Nombre de rapports de synthèse sur l'innocuité annexés en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59f[0].txt59f2[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59g[0].lbl59g[0]", "59g. Finished Product Specification", "59g. Spécifications du produit fini");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59g[0].lbl59g[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59g[0].txt59g1[0]", "59g-1. Count of Mail-in Quality Summary Report Attachments *", "59g-1. Nombre de rapports de synthèse sur la qualité postés");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59g[0].txt59g1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59g[0].txt59g2[0]", "59g-2. Count of Quality Summary Report Attachments *", "59g-2. Nombre de rapports de synthèse sur la qualité annexés en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59g[0].txt59g2[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59h[0].txt59h1[0]", "59h-1. Count of Mail-in Other Claim Evidence Attachments *", "59h-1. Nombre d'autres preuves sur les allégations postées");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59h[0].txt59h1[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59h[0].txt59h2[0]", "59h-2. Count of Other Claim Evidence Attachments *", "59h-2. Nombre d'autres preuves sur les allégations annexées en pièces jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59h[0].txt59h2[0]", "Indicate the number of supporting documents\r\nincluded with this attachment.", "Indiquez le nombre de documents à l’appui inclus\r\navec cette présentation.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59h[0].lbl59h[0]", "59h. Other Claim Evidence", "59h. Autres preuves sur les allégations");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionE[0].sf59h[0].lbl59h[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfHeader[0].lblHeading[0]", "F. - REFERENCE SUBMISSION ", "F. – PRÉSENTATION DE RÉFÉRENCE");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfHeader[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfHeader[0].btnAdd[0]", "Add a Reference", "Ajouter une référence");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtCompanyNo[0]", "60a. Company Number *", "60a. N° de l’entreprise");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtCompanyNo[0]", "\"Where related NHP submissions are referenced in\r\nthe subject submission, provide the company code\r\n(see Section 5 above), the file number, the\r\nsubmission number, and the NPN/DIN-HM number (if\r\navailable). Indicate the summary report being\r\nreferenced by checking the appropriate box for\r\nsafety, efficacy, quality, or complete\r\nsubmission.When an applicant wishes to reference\r\nanother submission, he/she must reference one or\r\nmore of the summary reports (Safety, Efficacy\r\nand/or Quality) in their entirety (i.e. if\r\nreferencing the safety summary report, the\r\napplicant must reference the entire report and not\r\nsubmit any additional safety\r\ninformation).Additional information on referencing\r\nother submissions may be found in Chapter 4.1 of\r\nthe Product Licensing guidance document.\"", "Lorsqu’il y a des références à des présentations de PSN dans la présentation de sujet, fournissez le code de société (reportez-vous à la section 5 plus haut), le numéro de dossier, le numéro de présentation et le numéro NPN/DIN-MH (si disponible). Indiquez le rapport de synthèse en référence en cochant la case appropriée pour la présentation complète, l’innocuité, l’efficacité, ou la qualité. Lorsqu’un demandeur désire établir une référence à une autre présentation, il doit établir une référence à un rapport de synthèse ou plus (innocuité, efficacité et/ou qualité) entier (p. ex. : s’il y a une référence au rapport de synthèse d’innocuité, le demandeur doit établir une référence à tout le rapport et non pas soumettre des informations supplémentaires d’innocuité). Vous pouvez trouver d’autres informations sur la référence à d’autres présentations au chapitre 4.1 du document de référence Licence de mise en marché. ");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtFileNo[0]", "60b. File Number *", "60b. N° de dossier");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtFileNo[0]", "\"Where related NHP submissions are referenced in\r\nthe subject submission, provide the company code\r\n(see Section 5 above), the file number, the\r\nsubmission number, and the NPN/DIN-HM number (if\r\navailable). Indicate the summary report being\r\nreferenced by checking the appropriate box for\r\nsafety, efficacy, quality, or complete\r\nsubmission.When an applicant wishes to reference\r\nanother submission, he/she must reference one or\r\nmore of the summary reports (Safety, Efficacy\r\nand/or Quality) in their entirety (i.e. if\r\nreferencing the safety summary report, the\r\napplicant must reference the entire report and not\r\nsubmit any additional safety\r\ninformation).Additional information on referencing\r\nother submissions may be found in Chapter 4.1 of\r\nthe Product Licensing guidance document.\"", "Lorsqu’il y a des références à des présentations de PSN dans la présentation de sujet, fournissez le code de société (reportez-vous à la section 5 plus haut), le numéro de dossier, le numéro de présentation et le numéro NPN/DIN-MH (si disponible). Indiquez le rapport de synthèse en référence en cochant la case appropriée pour la présentation complète, l’innocuité, l’efficacité, ou la qualité. Lorsqu’un demandeur désire établir une référence à une autre présentation, il doit établir une référence à un rapport de synthèse ou plus (innocuité, efficacité et/ou qualité) entier (p. ex. : s’il y a une référence au rapport de synthèse d’innocuité, le demandeur doit établir une référence à tout le rapport et non pas soumettre des informations supplémentaires d’innocuité). Vous pouvez trouver d’autres informations sur la référence à d’autres présentations au chapitre 4.1 du document de référence Licence de mise en marché. ");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtSubmissionNumber[0]", "60c. Submission Number *", "60c. N° de présentation");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtSubmissionNumber[0]", "\"Where related NHP submissions are referenced in\r\nthe subject submission, provide the company code\r\n(see Section 5 above), the file number, the\r\nsubmission number, and the NPN/DIN-HM number (if\r\navailable). Indicate the summary report being\r\nreferenced by checking the appropriate box for\r\nsafety, efficacy, quality, or complete\r\nsubmission.When an applicant wishes to reference\r\nanother submission, he/she must reference one or\r\nmore of the summary reports (Safety, Efficacy\r\nand/or Quality) in their entirety (i.e. if\r\nreferencing the safety summary report, the\r\napplicant must reference the entire report and not\r\nsubmit any additional safety\r\ninformation).Additional information on referencing\r\nother submissions may be found in Chapter 4.1 of\r\nthe Product Licensing guidance document.\"", "Lorsqu’il y a des références à des présentations de PSN dans la présentation de sujet, fournissez le code de société (reportez-vous à la section 5 plus haut), le numéro de dossier, le numéro de présentation et le numéro NPN/DIN-MH (si disponible). Indiquez le rapport de synthèse en référence en cochant la case appropriée pour la présentation complète, l’innocuité, l’efficacité, ou la qualité. Lorsqu’un demandeur désire établir une référence à une autre présentation, il doit établir une référence à un rapport de synthèse ou plus (innocuité, efficacité et/ou qualité) entier (p. ex. : s’il y a une référence au rapport de synthèse d’innocuité, le demandeur doit établir une référence à tout le rapport et non pas soumettre des informations supplémentaires d’innocuité). Vous pouvez trouver d’autres informations sur la référence à d’autres présentations au chapitre 4.1 du document de référence Licence de mise en marché. ");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtNPNNumber[0]", "60d. NPN/DIN-HM Number", "60d. N° NPN/DIN-MH");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].txtNPNNumber[0]", "\"Where related NHP submissions are referenced in\r\nthe subject submission, provide the company code\r\n(see Section 5 above), the file number, the\r\nsubmission number, and the NPN/DIN-HM number (if\r\navailable). Indicate the summary report being\r\nreferenced by checking the appropriate box for\r\nsafety, efficacy, quality, or complete\r\nsubmission.When an applicant wishes to reference\r\nanother submission, he/she must reference one or\r\nmore of the summary reports (Safety, Efficacy\r\nand/or Quality) in their entirety (i.e. if\r\nreferencing the safety summary report, the\r\napplicant must reference the entire report and not\r\nsubmit any additional safety\r\ninformation).Additional information on referencing\r\nother submissions may be found in Chapter 4.1 of\r\nthe Product Licensing guidance document.\"", "Lorsqu’il y a des références à des présentations de PSN dans la présentation de sujet, fournissez le code de société (reportez-vous à la section 5 plus haut), le numéro de dossier, le numéro de présentation et le numéro NPN/DIN-MH (si disponible). Indiquez le rapport de synthèse en référence en cochant la case appropriée pour la présentation complète, l’innocuité, l’efficacité, ou la qualité. Lorsqu’un demandeur désire établir une référence à une autre présentation, il doit établir une référence à un rapport de synthèse ou plus (innocuité, efficacité et/ou qualité) entier (p. ex. : s’il y a une référence au rapport de synthèse d’innocuité, le demandeur doit établir une référence à tout le rapport et non pas soumettre des informations supplémentaires d’innocuité). Vous pouvez trouver d’autres informations sur la référence à d’autres présentations au chapitre 4.1 du document de référence Licence de mise en marché. ");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].lbl60e[0]", "60e. Contains Information to Support *", "60e. Contient de l’information à l’appui de ce qui suit");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].lbl60e[0]", "\"Where related NHP submissions are referenced in\r\nthe subject submission, provide the company code\r\n(see Section 5 above), the file number, the\r\nsubmission number, and the NPN/DIN-HM number (if\r\navailable). Indicate the summary report being\r\nreferenced by checking the appropriate box for\r\nsafety, efficacy, quality, or complete\r\nsubmission.When an applicant wishes to reference\r\nanother submission, he/she must reference one or\r\nmore of the summary reports (Safety, Efficacy\r\nand/or Quality) in their entirety (i.e. if\r\nreferencing the safety summary report, the\r\napplicant must reference the entire report and not\r\nsubmit any additional safety\r\ninformation).Additional information on referencing\r\nother submissions may be found in Chapter 4.1 of\r\nthe Product Licensing guidance document.\"", "Lorsqu’il y a des références à des présentations de PSN dans la présentation de sujet, fournissez le code de société (reportez-vous à la section 5 plus haut), le numéro de dossier, le numéro de présentation et le numéro NPN/DIN-MH (si disponible). Indiquez le rapport de synthèse en référence en cochant la case appropriée pour la présentation complète, l’innocuité, l’efficacité, ou la qualité. Lorsqu’un demandeur désire établir une référence à une autre présentation, il doit établir une référence à un rapport de synthèse ou plus (innocuité, efficacité et/ou qualité) entier (p. ex. : s’il y a une référence au rapport de synthèse d’innocuité, le demandeur doit établir une référence à tout le rapport et non pas soumettre des informations supplémentaires d’innocuité). Vous pouvez trouver d’autres informations sur la référence à d’autres présentations au chapitre 4.1 du document de référence Licence de mise en marché. ");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].chkSafety[0]", "Safety", "Innocuité");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].chkSafety[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].chkEfficacy[0]", "Efficacy", "Efficacité");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].chkEfficacy[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].chkQuality[0]", "Quality", "Qualité");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].chkQuality[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].lblInstructions[0]", "60. Other Supporting Submission", "60. Autre présentation à l’appui");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].btnAdd[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionF[0].sfRow[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfHeading[0].lblHeading[0]", "G. - NHPD MASTER FILE ", "G. FICHIER PRINCIPAL DE LA DPSN");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfHeading[0].btnAdd[0]", "Add a Master File", "Ajouter un fichier principal");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].lblSupporting[0]", "61b. Contains information to support *", "61b. Contient de l’information à l’appui de ce qui suit");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].lblSupporting[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkSafety[0]", "61c. Safety only", "61c. Innocuité seulement");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkSafety[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkEfficacy[0]", "61d Efficacy only", "61d. Efficacité seulement");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkEfficacy[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkQuality[0]", "61e. Quality only", "61e. Qualité seulement");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkQuality[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkComplete[0]", "61f. Complete submission", "61f. Présentation complète");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].chkComplete[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].txtMasterFileNo[0]", "61a. Master File Number", "61a. N° de dossier principal");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].txtMasterFileNo[0]", "\"In some circumstances a NHP Master File may be\r\nreferenced. A NHP Master File may be submitted,\r\nwhen a company would like to submit confidential\r\ninformation on behalf of another company (i.e. a\r\nsupplier submitting confidential manufacturing\r\ninformation on behalf of a manufacturer).Where\r\nrelated NHP submission information is contained in\r\na Master File, please indicate the master file\r\nnumber and the information being supported (i.e.\r\nsafety, efficacy, quality, or complete submission).\r\nWhen the Master File has not been submitted by the\r\ncompany applying for the licence, a Letter of\r\nAccess must be included authorizing the NHPD to\r\naccess the indicated parts of the Master File.\r\nRefer to the Master File guidance document for\r\nfurther information on the requirements for a\r\nMaster file and information that must be included\r\nin the Letter of Access.It is the responsibility of\r\nthe applicant to ensure that a Master File has been\r\nsubmitted on his/her behalf if a Master File is to\r\nbe referenced.\"", "Dans certaines situations, il est possible de faire référence à un fichier principal de produit de santé naturel. Un fichier principal de PSN peut être présenté quand une compagnie veut soumettre de l’information confidentielle au nom d’une autre compagnie (p.ex. un fournisseur dépose de l’information confidentielle relative à la fabrication pour le compte d’un autre fournisseur.)\n\nLorsque de l’information de présentation connexe d’un NPH se trouve dans un dossier principal, veuillez indiquer le numéro de dossier principal et l’information appuyée (p. ex. : la présentation complète, l’innocuité, l’efficacité ou la qualité). Lorsque le dossier principal n’a pas été soumis par la société lors de la demande de licence, une lettre d’accès doit être incluse autorisant la DPSN à accéder aux parties indiquées du dossier principal. Reportez-vous au document de référence Fichier principal : procédures, particularités et spécifications pour plus d’information sur les exigences d’un dossier principal et d’information à inclure dans la lettre d’accès.\n\nLe demandeur est responsable de faire en sorte qu’un dossier principal soit soumis en son nom s’il y a une référence à un dossier principal.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].ddlLetterOfAccess[0]", "61g.Letter of Access Enclosed *", "61g. Lettres d’accès ci-jointes");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].ddlLetterOfAccess[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].lblInstructions[0]", "61. Supporting Master File", "61. Dossier principal supportant");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].lblInstructions[0]", "\"In some circumstances a NHP Master File may be\r\nreferenced. A NHP Master File may be submitted,\r\nwhen a company would like to submit confidential\r\ninformation on behalf of another company (i.e. a\r\nsupplier submitting confidential manufacturing\r\ninformation on behalf of a manufacturer).Where\r\nrelated NHP submission information is contained in\r\na Master File, please indicate the master file\r\nnumber and the information being supported (i.e.\r\nsafety, efficacy, quality, or complete submission).\r\nWhen the Master File has not been submitted by the\r\ncompany applying for the licence, a Letter of\r\nAccess must be included authorizing the NHPD to\r\naccess the indicated parts of the Master File.\r\nRefer to the Master File guidance document for\r\nfurther information on the requirements for a\r\nMaster file and information that must be included\r\nin the Letter of Access.It is the responsibility of\r\nthe applicant to ensure that a Master File has been\r\nsubmitted on his/her behalf if a Master File is to\r\nbe referenced.\"", "Dans certaines situations, il est possible de faire référence à un fichier principal de produit de santé naturel. Un fichier principal de PSN peut être présenté quand une compagnie veut soumettre de l’information confidentielle au nom d’une autre compagnie (p.ex. un fournisseur dépose de l’information confidentielle relative à la fabrication pour le compte d’un autre fournisseur.)\n\nLorsque de l’information de présentation connexe d’un NPH se trouve dans un dossier principal, veuillez indiquer le numéro de dossier principal et l’information appuyée (p. ex. : la présentation complète, l’innocuité, l’efficacité ou la qualité). Lorsque le dossier principal n’a pas été soumis par la société lors de la demande de licence, une lettre d’accès doit être incluse autorisant la DPSN à accéder aux parties indiquées du dossier principal. Reportez-vous au document de référence Fichier principal : procédures, particularités et spécifications pour plus d’information sur les exigences d’un dossier principal et d’information à inclure dans la lettre d’accès.\n\nLe demandeur est responsable de faire en sorte qu’un dossier principal soit soumis en son nom s’il y a une référence à un dossier principal.");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].btnAdd[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfModify[0].btnSubmit[0]", "Modify Form", "Modifier formulaire");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfModify[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart2[0].sfValidate[0].btnSubmit[0]", "Continue", "Continuer");
setTT("xfa[0].form[0].Pla[0].sfPart2[0].sfValidate[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfHeading[0].lblHeading[0]", "PART 3 - SITE INFORMATION", "PARTIE 3 - RENSEIGNEMENTS CONCERNANT L'EXPLOITATION");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfHeading[0].btnAdd[0]", "Add a Site", "Ajoutez un renseignement");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtCompanyName[0]", "62. Company Name", "62. Nom de l’entreprise");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtCompanyName[0]", "The name of the company who owns the site. Do not\r\nabbreviate the company name.  ", "Le nom de la société propriétaire de l’emplacement.\r\nN’utilisez pas d’abréviations du nom de la société.");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtStreet[0]", "64. Number, Street - Suite - PO Box", "64. Rue/bureau/B.P.");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtStreet[0]", "Provide the full mailing address of the company\r\n(i.e. not the site at which the activity is taking\r\nplace). If a street address is used, provide the\r\nsuite/unit number (if applicable) in addition to\r\nthe street and street number (64), the city/town\r\n(65), the province/state (67), the country (66) and\r\nthe postal or zip code (68). Include the PO Box\r\nnumber (64) if a post office box is used.", "Fournissez l’adresse postale complète de la société\r\n(p. ex. : non pas l’emplacement de l’activité en\r\nquestion). Si vous utilisez une adresse de bureau,\r\nfournissez le numéro de la suite/unité (s’il y a\r\nlieu) en plus de la rue et du numéro de la rue\r\n(64), la ville (65), la province/état (67), le pays\r\n(66) et le code postal ou le code de zone (68).\r\nAjoutez le numéro de B.P. (64) si une boîte postale\r\nest utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtCity[0]", "65. City", "65. Ville");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtCity[0]", "Provide the full mailing address of the company\r\n(i.e. not the site at which the activity is taking\r\nplace). If a street address is used, provide the\r\nsuite/unit number (if applicable) in addition to\r\nthe street and street number (64), the city/town\r\n(65), the province/state (67), the country (66) and\r\nthe postal or zip code (68). Include the PO Box\r\nnumber (64) if a post office box is used.", "Fournissez l’adresse postale complète de la société\r\n(p. ex. : non pas l’emplacement de l’activité en\r\nquestion). Si vous utilisez une adresse de bureau,\r\nfournissez le numéro de la suite/unité (s’il y a\r\nlieu) en plus de la rue et du numéro de la rue\r\n(64), la ville (65), la province/état (67), le pays\r\n(66) et le code postal ou le code de zone (68).\r\nAjoutez le numéro de B.P. (64) si une boîte postale\r\nest utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddlCountry[0]", "66. Country", "66. Pays");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddlCountry[0]", "Provide the full mailing address of the company\r\n(i.e. not the site at which the activity is taking\r\nplace). If a street address is used, provide the\r\nsuite/unit number (if applicable) in addition to\r\nthe street and street number (64), the city/town\r\n(65), the province/state (67), the country (66) and\r\nthe postal or zip code (68). Include the PO Box\r\nnumber (64) if a post office box is used.", "Fournissez l’adresse postale complète de la société\r\n(p. ex. : non pas l’emplacement de l’activité en\r\nquestion). Si vous utilisez une adresse de bureau,\r\nfournissez le numéro de la suite/unité (s’il y a\r\nlieu) en plus de la rue et du numéro de la rue\r\n(64), la ville (65), la province/état (67), le pays\r\n(66) et le code postal ou le code de zone (68).\r\nAjoutez le numéro de B.P. (64) si une boîte postale\r\nest utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddlProvince[0]", "67. Province - State", "67. Province/état");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddlProvince[0]", "Provide the full mailing address of the company\r\n(i.e. not the site at which the activity is taking\r\nplace). If a street address is used, provide the\r\nsuite/unit number (if applicable) in addition to\r\nthe street and street number (64), the city/town\r\n(65), the province/state (67), the country (66) and\r\nthe postal or zip code (68). Include the PO Box\r\nnumber (64) if a post office box is used.", "Fournissez l’adresse postale complète de la société\r\n(p. ex. : non pas l’emplacement de l’activité en\r\nquestion). Si vous utilisez une adresse de bureau,\r\nfournissez le numéro de la suite/unité (s’il y a\r\nlieu) en plus de la rue et du numéro de la rue\r\n(64), la ville (65), la province/état (67), le pays\r\n(66) et le code postal ou le code de zone (68).\r\nAjoutez le numéro de B.P. (64) si une boîte postale\r\nest utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtPostalCode[0]", "68. Postal Code - ZIP Code", "68. Code postal - Code de zone *");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtPostalCode[0]", "Provide the full mailing address of the company\r\n(i.e. not the site at which the activity is taking\r\nplace). If a street address is used, provide the\r\nsuite/unit number (if applicable) in addition to\r\nthe street and street number (64), the city/town\r\n(65), the province/state (67), the country (66) and\r\nthe postal or zip code (68). Include the PO Box\r\nnumber (64) if a post office box is used.", "Fournissez l’adresse postale complète de la société\r\n(p. ex. : non pas l’emplacement de l’activité en\r\nquestion). Si vous utilisez une adresse de bureau,\r\nfournissez le numéro de la suite/unité (s’il y a\r\nlieu) en plus de la rue et du numéro de la rue\r\n(64), la ville (65), la province/état (67), le pays\r\n(66) et le code postal ou le code de zone (68).\r\nAjoutez le numéro de B.P. (64) si une boîte postale\r\nest utilisée.");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].lbl63[0]", "63. Site Type", "63. Sorte de renseignement");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].lbl63[0]", "\"A number assigned by the NHPD for authorization to\r\nmanufacture, package, label or import a NHP. Please\r\nnote that distributors do not require a site\r\nlicence and only companies with an address in\r\nCanada require a site licence from the NHPD. A\r\nlocation may be licensed to manufacture, package,\r\nlabel, import and/or distribute products. For each\r\ncompany name, check all activities which are\r\nconducted by that company.\"", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63a[0]", "63a. Manufacturer", "63a. Fabricant");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63a[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63b[0]", "63b. Packager", "63b. Emballeur");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63b[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63c[0]", "63c. Labeller", "63c. Étiqueteur");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63c[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63d[0]", "63d. Importer", "63d. Importateur");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63d[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63e[0]", "63e. Distributor", "63e. Distributeur");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63e[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].btnAdd[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtSiteLicenceNumber[0]", "Site Licence Number", "Numéro de licence d'exploitation du site");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].txtSiteLicenceNumber[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfModify[0].btnSubmit[0]", "Modify Form", "Modifier formulaire");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfModify[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart3[0].sfValidate[0].btnSubmit[0]", "Continue", "Continuer");
setTT("xfa[0].form[0].Pla[0].sfPart3[0].sfValidate[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeading[0].lblHeading[0]", "PART 4 - PRODUCT INFORMATION", "PARTIE 4 - RENSEIGNEMENTS SUR LE PRODUIT");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeading[0].btnSummary[0]", "Summary", "Sommaire");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeading[0].btnSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfBrandNames[0].txtBrandName[0]", "70. Primary Brand Name *", "70. Marque nominative principale");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfBrandNames[0].txtBrandName[0]", "", "");

//setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicDisclaimer[0].lblDisclaimer[0]", "This product is for general homeopathic medicine claim only. The brand name must not indicate or imply a specific claim, recommended use or purpose. Please change your brand name accordingly or choose another type of application.", "");
//setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicDisclaimer[0].lblDisclaimer[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicDisclaimer[0].chkAgree[0]", "I Agree", "J'Accepte");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicDisclaimer[0].chkAgree[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfHeading[0].lblTitle[0]", "71. Other Brand Names", "71. Autres noms de marque");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfHeading[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfHeading[0].btnAdd[0]", "Add Brand Name", "Ajoutez un nom de marque");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfRow[0].txtOtherBrandNames[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfRow[0].txtOtherBrandNames[0]", "71. Other Brand Names", "71. Autres noms de marque");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfOtherBrandNames[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfCompendial[0].txtMonographName[0]", "Monograph Name", "Nom de la monographie");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfCompendial[0].txtMonographName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfCompendial[0].btnSearch[0]", "Search Monograph Database", "Faire une recherche dans la base de données des monographies");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfCompendial[0].btnSearch[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfCompendial[0].txtMonographDate[0]", "Monograph Date", "Date de la monographie");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfCompendial[0].txtMonographDate[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].ddlDosageForm[0]", "103. Dosage Form (one only)", "103. Forme posologique (une seulement)");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].ddlDosageForm[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].ddlRoute[0]", "105. Route of Administration", "105. Voie d’administration");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].ddlRoute[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].rblSterile[0].rbNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].rblSterile[0].rbNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].rblSterile[0].rbYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].rblSterile[0].rbYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].lblSterile[0]", "104. Sterile *", "104. Stérile *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHeader[0].lblSterile[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfROASynonym[0].ddlROASynonym[0]", "Dosage Form Selection", "Choix de forme posologique");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfROASynonym[0].ddlROASynonym[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].lblQuantityHMP[0]", "81. Quantity of Homeopathic Potency", "81.Quantité du taux de dilution ");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].lblQuantityHMP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].txtPotencyAmount[0]", "Amount:", "Quantité:");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].txtPotencyAmount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].ddlPotencyConstituent[0]", "Unit:", "Unité:");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].ddlPotencyConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblTitle[0]", "Source Information *", "Information d’origine *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].btnAdd[0]", "Add Source Information", "Ajouter information d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfSourceInformation[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfSourceInformation[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].ddlMethodOfPreparation[0]", "90. Method of Preparation *", "90. Méthode de préparation *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].ddlMethodOfPreparation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].lbl90a[0]", "All medicinal ingredients of animal origin (nosodes, sarcodes, etc.) must be sterilised as per HPUS and HAB requirements or equivalent.", "Tous les ingrédients médicinaux d’origine animale (nosodes, sarcodes, etc.) doivent être stérilisés conformément aux exigences de la HPUS et de la HAB ou l’équivalent.");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].lbl90a[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].chkAgree[0]", "I Agree *", "J'Accepte *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].chkAgree[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].Text8[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;91. Was animal tissue used in the processing of this &lt;span style=\"font-weight:bold\"&gt;ingredient&lt;/span&gt; (e.g: natural lactose used for triturations)? *&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;91. A-t-on utilisé des tissus d'origine animale au cours de la fabrication du &lt;span style=\"font-weight:bold\"&gt;Ingrédient&lt;/span&gt; (p. ex.: du lactose naturel au cours des triturations)? *&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].Text8[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].rblAnimalTissue[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].rblAnimalTissue[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].rblAnimalTissue[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfPreparation[0].rblAnimalTissue[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfHeading[0].lblMedicinalIngredients[0]", "A. MEDICINAL INGREDIENT(S)", "A. – INGRÉDIENT(S) MÉDICINAL(NAUX)");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfHeading[0].lblMedicinalIngredients[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfHeading[0].btnAdd[0]", "Add an Ingredient", "Ajouter un ingrédient");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeader[0].lblIngredient[0]", "MI", "IM");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeader[0].lblIngredient[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeader[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeader[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeader[0].btnSearch[0]", "Search Ingredient Database", "Rechercher dans la base de données des ingrédients");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeader[0].btnSearch[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlStandardOrGrade[0]", "73. Standard or Grade", "73. Norme ou classe");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlStandardOrGrade[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].txtDosageQuantity[0]", "77a. Quantity per Dosage Unit", "77a. Quantité par unité posologique");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].txtDosageQuantity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlDosageUnit[0]", "77b. Unit of Measure", "77b. Unité de mesure");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlDosageUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlIngredientType[0]", "Ingredient Type *", "Type d'ingrédient");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlIngredientType[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].txtAdditionalQuantity[0]", "Additional  Quantity", "Quantités supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].txtAdditionalQuantity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlAdditionalUnit[0]", "Additional Unit", "Unités supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlAdditionalUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].ddlProperName[0]", "75. Proper Name *", "75. Nom propre");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].ddlProperName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].txtApprovedName[0]", "Approved Name *", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].txtApprovedName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].lblExtract[0]", "Ingredient Names", "Nom des ingrédients");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].lblExtract[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].ddlCommonName[0]", "Common Name *", "Nom commun");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfNames[0].ddlCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblAnimalTissue[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblAnimalTissue[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblAnimalTissue[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblAnimalTissue[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].lblAnimalTissue[0]", "79. Animal Tissue **", "79. Tissus d’origine animale **");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].lblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblSynthetic[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblSynthetic[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblSynthetic[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].rblSynthetic[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].lblSynthetic[0]", "Synthetic *", "Synthétique *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].lblSynthetic[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeading[0].lblTitle[0]", "Source", "Provenance");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeading[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeading[0].btnAdd[0]", "Add a Source", "Ajouter une provenance");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblConstituent[0]", "Source *", "Provenance *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblAmount[0]", "Synthetic *", "Synthétique *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblAmount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblUnit[0]", "Animal Tissue **", "Tissus d’origine animale **");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfHeader[0].lblUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].ddlSource[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].ddlSource[0]", "Source *", "Provenance *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblSynthetic[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblSynthetic[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblSynthetic[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblSynthetic[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblAnimalTissue[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblAnimalTissue[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblAnimalTissue[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceInformation[0].sfRow[0].rblAnimalTissue[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeading[0].StaticText1[0]", "Source Material(s)", "Matériel(aux) d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeading[0].StaticText1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeading[0].btnAdd[0]", "Add a Source Material", "Ajouter un matériel d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeader[0].lblConstituent[0]", "Source Material *", "Matériel d'origine *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeader[0].lblConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeader[0].lblUnit[0]", "Animal Tissue **", "Tissus d’origine animale **");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfHeader[0].lblUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].ddlSource[0]", "", "")
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].ddlSource[0]", "Source Material *", "Matériel d'origine *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].rblAnimalTissue[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].rblAnimalTissue[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].rblAnimalTissue[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSource[0].sfRow[0].rblAnimalTissue[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfHeader[0].lblTitle[0]", "Source Organism", "Organisme de provenance");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfHeader[0].btnAdd[0]", "Add an Organism", "Ajouter un organisme");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfRow[0].ddlOrganism[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfRow[0].ddlOrganism[0]", "Source Organism", "Organisme de provenance");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfSourceOrganism[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfHeader[0].lblTitle[0]", "Source Material(s) *", "Matériel(aux) d'origine *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfHeader[0].btnAdd[0]", "Add a Source Material", "Ajouter un matériel d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfRow[0].ddlPart[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfRow[0].ddlPart[0]", "Source Material(s) *", "Matériel(aux) d'origine *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfRow[0].txtStrain[0]", "Strain:", "Souche:");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismPart[0].sfRow[0].txtStrain[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfHeader[0].lblTitle[0]", "Method(s) of Preparation *", "Méthode de préparation *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfHeader[0].btnAdd[0]", "Add a Method of Preparation", "Ajouter une méthode de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfRow[0].ddlMethodOfPreparation[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfRow[0].ddlMethodOfPreparation[0]", "Method(s) of Preparation *", "Méthode de préparation *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfMethodOfPreparation[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfHeading[0].lblExtract[0]", "Organism Substance Processing", "Traitement de substance dérivée d'un organisme");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfHeading[0].lblExtract[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfPotencyHeader[0].lblTitle[0]", "Potency", "Activité");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfPotencyHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfPotencyHeader[0].btnAdd[0]", "Add a Constituent", "Ajouter un constituant");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfPotencyHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfHeader[0].lblConstituent[0]", "Constituent *", "Constituant *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfHeader[0].lblConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfHeader[0].lblAmount[0]", "Amount *", "Quantité *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfHeader[0].lblAmount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfHeader[0].lblUnit[0]", "Unit *", "Unité");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfHeader[0].lblUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].ddlConstituent[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].ddlConstituent[0]", "Constituent *", "Constituant *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].txtAmount[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].txtAmount[0]", "Amount *", "Quantité *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].ddlUnit[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].ddlUnit[0]", "Unit *", "Unité *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPotency[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].txtRatio1[0]", "Ratio", "Ratio");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].txtRatio1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].lblRatioColon[0]", ":", ":");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].lblRatioColon[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].txtQuantityCrudeEquivalent[0]", "Quantity Crude Equivalent", "Quantité brute équivalente");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].txtQuantityCrudeEquivalent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].ddlOriginalMaterial[0]", "Original Material Used", "Matière d'origine utilisée");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].ddlOriginalMaterial[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].ddlUnit[0]", "Unit", "Unité");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].ddlUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].lblTitle[0]", "Extract", "Extrait");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfSolventHeader[0].lblTitle[0]", "Solvents", "Solvants");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfSolventHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfSolventHeader[0].btnAdd[0]", "Add a Solvent", "Ajouter un solvant");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfSolventHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfHeader[0].lblConstituent[0]", "Solvent", "Solvant");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfHeader[0].lblConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfHeader[0].lblAmount[0]", "Solvent Strength", "Force du solvant");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfHeader[0].lblAmount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfRow[0].ddlSolvents[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfRow[0].ddlSolvents[0]",  "Solvents", "Solvants");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfRow[0].txtSolventStrength[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfRow[0].txtSolventStrength[0]",  "Solvent Strength", "Force du solvant");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfSolvent[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfPreparationStepsHeader[0].StaticText1[0]", "Preparation Steps", "Étapes de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfPreparationStepsHeader[0].StaticText1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfPreparationStepsHeader[0].btnAdd[0]", "Add a Preparation Step", "Ajouter une étape de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfPreparationStepsHeader[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfHeader[0].lblPreparationStep[0]", "Preparation Step", "Étape de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfHeader[0].lblPreparationStep[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfHeader[0].lblMethodOfPreparation[0]", "Method of Preparation *", "Méthode de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfHeader[0].lblMethodOfPreparation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfHeader[0].lblRatio[0]", "Ratio", "Ratio");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfHeader[0].lblRatio[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].lblRatioColon[0]", ":", ":");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].lblRatioColon[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtPreparationSteps[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtPreparationSteps[0]", "Preparation Step", "Étape de préparation");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtMethodOfPreparation[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtMethodOfPreparation[0]", "Method of Preparation *", "Méthode de préparation *");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtRatio1[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtRatio1[0]", "Ratio", "Ratio");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtRatio2[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].txtRatio2[0]", "Ratio", "Ratio");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfPreparationSteps[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfHeading[0].lblNonMedicinalIngredients[0]", "B. NON-MEDICINAL INGREDIENT(S)", "B. – INGRÉDIENT(S) NON MÉDICINAL(AUX)");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfHeading[0].lblNonMedicinalIngredients[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfHeading[0].btnAdd[0]", "Add a Non-Medicinal Ingredient", "Ajoutez un ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlStandardOrGrade[0]", "98. Standard or Grade", "98. Norme ou classe");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlStandardOrGrade[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtApprovedName[0]", "Approved Name *", "Nom approuvé *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtApprovedName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlCommonName[0]", "94. Common Name *", "94. Nom usuel/commun *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtSourceInformation[0]", "100. Source Information", "100. Information d’origine");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtSourceInformation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtDosageQuantity[0]", "99a. Quantity per Dosage Unit", "99a. Quantité par unité posologique");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtDosageQuantity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlDosageUnit[0]", "99b. Unit of Measure", "99b. Unité de mesure");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlDosageUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlPurpose[0]", "95. Purpose *", "95. Fins *");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlPurpose[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlPurposeSynonym[0]", "Purpose Selection", "Choix de fins");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].ddlPurposeSynonym[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].rblAnimalTissue[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].rblAnimalTissue[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].rblAnimalTissue[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].rblAnimalTissue[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].lblAnimalTissue[0]", "96. Animal Tissue **", "96. Tissus d’origine animale utilisés**");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].lblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].btnAdd[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].btnSearch[0]", "Search Ingredient Database", "Rechercher dans la base de données des ingrédients");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].btnSearch[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].btnOverride[0]", "Manual Entry", "Entrée manuelle");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].btnOverride[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].lblIngredient[0]", "NMI", "INM");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].lblIngredient[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtId[0]", "id", "Id");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionB1[0].sfRow[0].txtId[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].lblMedicinalIngredients[0]", "C. INGREDIENT(S) USED IN PROCESSING", "C. – INGRÉDIENT(S) UTILISÉ(S) LORS DU TRAITEMENT");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].lblMedicinalIngredients[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].lblAnimalTissue[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;101. \"Was animal tissue used in the processing of this &lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span style=\"font-weight:bold\"&gt;product&lt;/span&gt;, although not present in the final product?\"**&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;101. A-t-on utilisé des tissus d’origine animale au cours de la fabrication de ce &lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span style=\"font-weight:bold\"&gt;produit&lt;/span&gt;, bien qu’il n’y en ait aucun présent dans le produit final? **&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].lblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].rblAnimalTissue[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].rblAnimalTissue[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].rblAnimalTissue[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfPart4[0].sfSectionC[0].rblAnimalTissue[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfHeading[0].lblHeading[0]", "PART 4 - PRODUCT INFORMATION", "PARTIE 4 - RENSEIGNEMENTS SUR LE PRODUIT");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfHeading[0].btnSummary[0]", "Summary", "Sommaire");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfHeading[0].btnSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfHeading[0].lblHeading[0]", "D. - RECOMMENDED CONDITIONS OF USE", "D. – CONDITIONS D’UTILISATION RECOMMANDÉES");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfHeading[0].lblRecommendedUse[0]", "102. Recommended Use and Purpose *", "102. Usage ou fins recommandés");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfHeading[0].lblRecommendedUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfHeading[0].btnAdd[0]", "Add a Statement", "Ajouter un énoncé");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfRow[0].ddlUse[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfRow[0].ddlUse[0]", "102. Recommended Use and Purpose *", "102. Usage ou fins recommandés *");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfRecommendedUses[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfHeading[0].lblRecommendedUse[0]", "102a. Specific Use or Purpose *", "102a. Usage ou fin recommandé spécifique *");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfHeading[0].lblRecommendedUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfHeading[0].btnAdd[0]", "Add a Specific Use or Purpose", "Ajouter un usage ou fin recommandé spécifique");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfRow[0].txtUse[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfRow[0].txtUse[0]", "102a. Specific Use or Purpose *", "102a. Usage ou fin recommandé spécifique");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfSectionD[0].sfSpecificUse[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfHeading[0].lblRecommendedDose[0]", "Recommended Dose (repeat for each sub-population group)", "Dose recommandée (répétez pour chaque sous population)");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfHeading[0].lblRecommendedDose[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfHeading[0].btnAdd[0]", "Add a New Sub-Population &amp; Recommended Dose", "Ajouter une nouvelle sous population &amp; dose recommandée");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtSubPopulationGroup[0]", "107. Sub-population group *", "107. Sous population");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtSubPopulationGroup[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMinDosageUnits[0]", "Min.", "Min.");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMinDosageUnits[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].ddlDosageUnit[0]", "110. Dosage Units", "110. Unité");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].ddlDosageUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtDirections[0]", "112. Directions of Use", "112. Mode d'emploi");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtDirections[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblTimesA[0]", "times a", "fois par");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblTimesA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].btnOverride[0]", "Manual Entry", "Entrée manuelle");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].btnOverride[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblFrequency[0]", "Frequency", "Fréquence");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblFrequency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblDosage[0]", "Dosage", "Posologie");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblDosage[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMaxDosageUnits[0]", "Max", "Max.");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMaxDosageUnits[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblTo[0]", "-", "-");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblTo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtAdditionalDosageInformation[0]", "Additional Dosage Information (ex. 1 scoop = 30g)", "Information de posologie supplémentaire");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtAdditionalDosageInformation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtAdditionalDirections[0]", "Additional Directions of Use", "Mode d'emploi supplémentaire");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtAdditionalDirections[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMaxFrequency[0]", "Max", "Max");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMaxFrequency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblToFrequency[0]", "-", "-");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].lblToFrequency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMinFrequency[0]", "Min", "Min");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].txtMinFrequency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].ddlFrequencyUnit[0]", "Frequency Units", "Unités de fréquence");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].ddlFrequencyUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeader[0].StaticText1[0]", "Duration of Use", "Durée d’utilisation");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeader[0].StaticText1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].txtDuration[0]", "106a. Duration", "Durée");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].txtDuration[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].ddlDurationUnit[0]", "106b. Duration Unit", "Unité");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].ddlDurationUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].rblMinMax[0].chkMin[0]", "Min", "Min");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].rblMinMax[0].chkMin[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].rblMinMax[0].chkMax[0]", "Max", "Max");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].rblMinMax[0].chkMax[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].rblMinMax[0].chkNeither[0]", "Neither", "Aucune");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfHeading[0].rblMinMax[0].chkNeither[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfHeading[0].lblRecommendedUse[0]", "106c. Duration Statement", "106c. Énoncé sur la durée d'utilisation");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfHeading[0].lblRecommendedUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfHeading[0].btnAdd[0]", "Add a Statement", "Ajouter un énoncé");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfRow[0].txtCell[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfRow[0].txtCell[0]", "106c. Duration Statement", "106c. Énoncé sur la durée d'utilisation");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfDuration[0].sfDurationStatement[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfHeading[0].lblRiskInformation[0]", "Risk Information", "Mention des risques");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfHeading[0].lblRiskInformation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfHeading[0].lblCautions[0]", "113. Cautions and Warnings", "113. Précautions et mises en garde");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfHeading[0].lblCautions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfHeading[0].btnAdd[0]", "Add a Statement", "Ajouter un énoncé");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfRow[0].txtCell[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfRow[0].txtCell[0]", "113. Cautions and Warnings", "113. Précautions et mises en garde");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfAdditional[0].txtAdditional[0]", "Additional Cautions and Warnings", "Précautions et mises en garde supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfCautions[0].sfAdditional[0].txtAdditional[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfHeading[0].lblCautions[0]", "114. Contraindications", "114. Contre-indications");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfHeading[0].lblCautions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfHeading[0].btnAdd[0]", "Add a Statement", "Ajouter un énoncé");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfRow[0].txtCell[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfRow[0].txtCell[0]", "114. Contraindications", "114. Contre-indications");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfAdditional[0].txtAdditional[0]", "Additional Contraindications", "Contre-indications supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfContraindications[0].sfAdditional[0].txtAdditional[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfHeading[0].lblCautions[0]", "115. Known Adverse Reactions", "115. Réactions indésirables connues");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfHeading[0].lblCautions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfHeading[0].btnAdd[0]", "Add a Statement", "Ajouter un énoncé");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfHeading[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfRow[0].txtCell[0]", "", "");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfRow[0].txtCell[0]", "115. Known Adverse Reactions", "115. Réactions indésirables connues");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfAdditional[0].txtAdditional[0]", "Additional Known Adverse Reactions", "Réactions indésirables connues supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRiskInformation[0].sfReactions[0].sfAdditional[0].txtAdditional[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfModify[0].btnSubmit[0]", "Modify Form", "Modifier formulaire");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfModify[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfValidate[0].btnSubmit[0]", "Continue", "Continuer");
setTT("xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfValidate[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfHeader[0].lblTitle[0]", "The Summary of Part4 Product Information", "Le sommaire de Partie 4  Renseignements sur le produit");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].lblSubTitle[0]", "Basic Information", "Renseignements de base");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].lblSubTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtBrandNameS[0]", "Primary Brand Name:", "Marque nominative principale:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtBrandNameS[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtOtherBrandNames[0]", "Other Brand Names:", "Autres marques nominatives:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtOtherBrandNames[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtROA[0]", "Route of Administration:", "Voie d'administraton:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtROA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtDosageForm[0]", "Dosage Form:", "Forme posologique:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtDosageForm[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtSterile[0]", "Sterile:", "Stérile:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfBasicInfomation[0].txtSterile[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].lblSubTitle[0]", "A. Medicinal Ingredient", "A. Ingrédient médicinal");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].lblSubTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblChemicalProteins[0]", "Chemicals and Proteins", "Composés chimiques et protéines");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblChemicalProteins[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblNo[0]", "No.", "No.");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblStandardGrade[0]", "Standard or Grade", "Norme ou classe");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblStandardGrade[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblIngredientType[0]", "Ingredient Type", "Type d'ingrédient");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblIngredientType[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblQuantityPerUnit[0]", "Quantity per Unit", "Quantité par unité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblQuantityPerUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblAddQuantityPerUnit[0]", "Additional quantity per unit", "Quantité par unité supplémentaire");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblAddQuantityPerUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblApprovedName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblProperName[0]", "Proper Name", "Nom propre");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblProperName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblCommonName[0]", "Common Name", "Nom commun");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].lblCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header1[0].lblSourceM[0]", "Source", "Provenance");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header1[0].lblSourceM[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header2[0].lblMaterial[0]", "Source", "Provenance");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header2[0].lblMaterial[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header2[0].lblSynthetic[0]", "Synthetic", "Synthétique");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header2[0].lblSynthetic[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header2[0].lbllblAnimalTissue[0]", "Animal Tissue", "Tissue animal");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader1[0].Header2[0].lbllblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader2[0].Header1[0].lblSource[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader2[0].Header1[0].lblSource[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader2[0].Header2[0].lblsource[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader2[0].Header2[0].lblsource[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader2[0].Header2[0].lblAnimalTissue[0]", "Animal Tissue", "Tissue animal");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfChemicalproteins[0].sfHeader[0].sfHeader2[0].Header2[0].lblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblOrganisms[0]", "Organisms and Organism Substance", "Organismes et substance dérivée d'un organisme");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblOrganisms[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblNo[0]", "No.", "No.");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblStandardGrade[0]", "Standard or Grade", "Norme ou classe");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblStandardGrade[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblIngredientType[0]", "Ingredient Type", "Type d'ingrédient");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblIngredientType[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblQuantityPerUnit[0]", "Quantity per Unit", "Quantité par unité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblQuantityPerUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblAddQuantityPerUnit[0]", "Additional quantity per unit", "Quantité par unité supplémentaire");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblAddQuantityPerUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblApprovedName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblProperName[0]", "Proper Name", "Nom propre");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblProperName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblCommonName[0]", "Common Name", "Nom commun");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblSourceOrganism[0]", "Source Organism", "Organisme de provenance");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblSourceOrganism[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header1[0].Header[0].lblOrganismParts[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header1[0].Header[0].lblOrganismParts[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header1[0].Header[0].lblStrain[0]", "Strain", "Souche");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header1[0].Header[0].lblStrain[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblMethodOfPreparation[0]", "Method of Preparation", "Méthode de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].lblMethodOfPreparation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header2[0].HeaderRow[0].lblPotency[0]", "Potency", "Activité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header2[0].HeaderRow[0].lblPotency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header2[0].Row1[0].lblConstituent[0]", "Constituent", "Constituant");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header2[0].Row1[0].lblConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header2[0].Row1[0].lblPotencyAmount[0]", "Amount", "Quantité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header2[0].Row1[0].lblPotencyAmount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblExtract[0]", "Extract", "Extrait");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblExtract[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblRatio[0]", "Ratio", "Ratio");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblRatio[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblQuantity[0]", "Quantity Crude Equivalent", "Quantité brute équivalente");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblQuantity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblUnit[0]", "Unit", "Unité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblUnit[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblOrgMaterial[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;Original Material&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;Used Material&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;Used&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;Matière originale&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;Matière utilisée&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;Utilisé&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header3[0].Header[0].lblOrgMaterial[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header4[0].Header[0].lblSolvents[0]", "Solvents", "Solvants");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header4[0].Header[0].lblSolvents[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header4[0].Header[0].lblSolvent[0]", "Solvent", "Solvant");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header4[0].Header[0].lblSolvent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header4[0].Header[0].lblStrength[0]", "Strength", "Force");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header4[0].Header[0].lblStrength[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblPreSteps[0]", "Preparation Steps", "Étapes de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblPreSteps[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblSteps[0]", "Steps", "Étapes");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblSteps[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblMethodOfpre[0]", "Method of Preparation", "Méthode de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblMethodOfpre[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblRatio[0]", "Ratio", "Ratio");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfOrganisms[0].sfHeader[0].Header5[0].Header[0].lblRatio[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader0[0].lblChemicalProteins[0]", "Homeopathic", "Homéopathique");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader0[0].lblChemicalProteins[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblNo[0]", "No.", "No.");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblStandardGrade[0]", "Standard or Grade", "Norme ou classe");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblStandardGrade[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblProperName[0]", "Proper Name", "Nom propre");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblProperName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblCommonName[0]", "Common Name", "Nom commun");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblQuantityPerUnit[0]", "Quantity per Dosage Unit", "Quantité par unité posologique");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblQuantityPerUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblPotency[0]", "Homeopathic Potency", "Taux de dilution");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblPotency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblSynthetic[0]", "Synthetic", "Synthétique");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblSynthetic[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblAmount[0]", "Potency Amount", "Quantité d'activité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblAmount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblConstituent[0]", "Potency Constituent", "Constituant d'activité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblConstituent[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].sfHeader0[0].Header2[0].lblMaterial[0]", "Source Information", "Information d’origine");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].sfHeader0[0].Header2[0].lblMaterial[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblMethodofPre[0]", "Method of Preparation", "Méthode de préparation");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblMethodofPre[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblAnimalTissue[0]", "Animal Tissue", "Tissue animal");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfIngredients[0].sfHomeoPathic[0].sfHeader1[0].lblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader1[0].lblNMI[0]", "B. NON-Medicinal Ingredient", "B. Ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader1[0].lblNMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblNo[0]", " No.", "No.");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblStandardGrade[0]", "Standard or Grade", "Norme ou classe");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblStandardGrade[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblApprovedName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblCommonName[0]", "Common Name", "Nom commun");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblPurpose[0]", "Purpose", "Fin");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblPurpose[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblQuantity[0]", "Quantity", "Quantité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblQuantity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblUnit[0]", "Unit", "Unité");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblSourceInformation[0]", "Source Information", "Information d'origine");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblSourceInformation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblAnimalTissue[0]", "Animal Tissue", "Tissue animal");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfNMIngredients[0].sfHeader2[0].lblAnimalTissue[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectionC[0].sfHeader[0].lblIngreUsedProcessing[0]", "C. Ingredient(s) Used In Processing", "C. Ingrédient(s) utilisés au cours de la fabrication");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectionC[0].sfHeader[0].lblIngreUsedProcessing[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectionC[0].sfHeader[0].txtQuestion[0]", "Was animal tissue used in the processing of this product, although not present in the final product?", "A-t-on utilisé des tissus d’origine animale au cours de la fabrication de ce produit, bien qu’il n’y en ait aucun présent dans le produit final?");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectionC[0].sfHeader[0].txtQuestion[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfHeader[0].lblConditionofUse[0]", "D. Recommended Conditions of Use", "D. Conditions d'utilisation recommandées");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfHeader[0].lblConditionofUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtRecommUsePurpose[0]", "Recommended Use and Purpose:", "Usage ou fins recommandés:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtRecommUsePurpose[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader1[0].lblRecommendDose[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-align:left\"&gt;Recommended Dose&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-align:left\"&gt;Dose recommandée&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader1[0].lblRecommendDose[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lblSubpopulatedGp[0]", "Sub-population group", "Groupe de sous-population");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lblSubpopulatedGp[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lblAmountATime[0]", "Amount to be taken at one time", "Quantité à prendre individuellement");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lblAmountATime[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lblFrequency[0]", "Frequency", "Fréquence");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lblFrequency[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lbAddDosageInfo[0]", "Additional Dosage Information ", "Information de posologie supplémentaire");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lbAddDosageInfo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lbDirectionUse[0]", "Directions of use", "Mode d’emploi");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lbDirectionUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lbAddDirectionUse[0]", "Additional Directions of Use", "Mode d'emploi supplémentaire");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].sfCol[0].sfHeader2[0].lbAddDirectionUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtDurationUse[0]", "Duration of Use :", "Durée d'utilisation:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtDurationUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtDurationStatementCount[0]", "Additional Duration Statements:", "Énoncés de durée additionnels :");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtDurationStatementCount[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].lblRiskInfo[0]", "Risk Information", "Mention des risques");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].lblRiskInfo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtCautionWarning[0]", "Caution and Warning :", "Précautions et mises en garde:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtCautionWarning[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtContraindication[0]", "Contraindications :", "Contre-indications:");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtContraindication[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtAdverseReaction[0]", "Know Adverse Reactions", "Réactions indésirables connues");
setTT("xfa[0].form[0].Pla[0].sfPart4Summary[0].sfSectioD[0].sfRecommConditionUse[0].txtAdverseReaction[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].lblHeading[0]", "PART 5 - LABEL TEXT", "PARTIE 5 - TEXTE D'ÉTIQUETTE");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].btnSubmit[0]", "Edit Label Text", "Réviser le texte d'étiquette");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].ckSubmittedSep[0]", "Label Text Submitted Separately", "Texte d'étiquette soumis séparément");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].ckSubmittedSep[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].validated[0]", "validated", "validé");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].validated[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].Text7[0]", "Any labels used in the marketing of this product must reflect the information outlined on the product licence and must comply with the labelling requirements as per Part 5 of the Natural Health Products Regulations.", "Toute étiquette utilisée pour la commercialisation de ce produit doit refléter l’information apparaissant sur la licence de mise en marché et être conforme aux exigences relatives à l’étiquetage de la partie 5 du Règlement sur les produits de santé naturels.");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfHeading[0].Text7[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfModify[0].btnSubmit[0]", "Modify Form", "Modifier formulaire");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfModify[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfPart5[0].sfValidate[0].btnSubmit[0]", "Continue", "Continuer");
setTT("xfa[0].form[0].Pla[0].sfPart5[0].sfValidate[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfHeading[0].lblHeading[0]", "ATTESTATION", "ATTESTATION");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfHeading[0].lblHeading[0]", "", "");

//setLblXml("xfa[0].form[0].Pla[0].sfAttestation[0].lblAttestation[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;\" I attest that the natural health product that is the subject of this product license application will be manufactured, packaged, labelled,&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;distributed and stored:&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;a)&lt;span style=\"xfa-spacerun:yes\"&gt;   &lt;/span&gt;If the natural health product is imported, in accordance with the 'Good Manufacturing Practices' requirements as set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3 of the Natural Health Products Regulations or in accordance with requirements that are equivalent to those set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3, or&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;b)&lt;span style=\"xfa-spacerun:yes\"&gt;   &lt;/span&gt;If the natural health product is not imported, in accordance with the 'Good Manufacturing Practices' requirements set out in&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;span style=\"xfa-spacerun:yes\"&gt;       &lt;/span&gt;Part 3 of the Natural Health Products Regulations.&lt;/p&gt;&lt;p style=\"line-height:12pt;text-decoration:none\"&gt;I, the undersigned, certify that the information and material included in this product licence application is accurate and complete. By clicking on the ‘I Agree ’ button and generating the Attestation Code, this generated code is confirmation of my attestation and will serve as authentication of this fact in the future”.&lt;/p&gt;&lt;p style=\"line-height:12pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", 
//"&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;«J'atteste que le produit de santé naturel faisant l'objet de cette demande de mise en marché sera fabriqué, emballé, étiqueté, distribué et entreposé&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt\"&gt;a) en vertu des exigences relatives aux bonnes pratiques de fabrication tel que le prescrit la partie 3 du Règlement sur les produits de santé naturels ou en vertu des exigences équivalentes à celles précisées dans la partie 3 (si le produit de santé naturel est importé);&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt\"&gt;b) en vertu des exigences relatives aux bonnes pratiques de fabrication tel que le prescrit la partie 3 du Règlement sur les produits de santé naturels (si le produit de santé naturel n'est pas importé).&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p style=\"margin-left:36pt;text-decoration:none\"&gt;&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;Je, soussigné, certifie que l'information et le matériel inclus dans cette demande de licence de mise en marché sont exacts et complets. En cliquant sur  le bouton J'Accepte   et en générant le Code d'attestation, ce code généré devient une confirmation de mon attestation et servira comme authentication de ce fait dans le futur. » &lt;span style=\"xfa-tab-count:1\"&gt;         &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/body&gt;");
//setTT("xfa[0].form[0].Pla[0].sfAttestation[0].lblAttestation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfAgree[0].chkAgree[0]", "I Agree", "J'Accepte");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfAgree[0].chkAgree[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfAgree[0].txtAttestationCode[0]", "Attestation Code", "Code d'attestation");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfAgree[0].txtAttestationCode[0]", "", "");

//begin of sfNano
setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].lblHeading[0]", "Ingredients Based on Nanotechnology", "Ingrédients basés sur la nanotechnologie");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].lblNano[0]", "Does this product contain any ingredients (medicinal or non-medicinal) based on nanotechnology? *", "Est-ce que ce produit contient des ingrédients (médicinaux ou non médicinaux) basés sur la nanotechnologie? *");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].lblNano[0]", "", "");
 
setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].rblNano[0].chkYes[0]", "Yes", "Oui");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].rblNano[0].chkYes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].rblNano[0].chkNo[0]", "No", "Non");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].rblNano[0].chkNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].txtNano[0]", "If yes, please list the ingredients:", "Si oui, veuillez indiquer les ingrédients :");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfNano[0].txtNano[0]", "", "");
//end of sfNano

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblName[0]", "116. Name of Authorized Senior Official1 (print)*", "116. Nom du signataire autorisé (en lettres moulées)*");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblSignature[0]", "117. Signature *", "117. Signature *");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblSignature[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblDate[0]", "118. Date * (yyyy-mm-dd)", "118. Date * (aaaa-mm-jj)");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblDate[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblNote[0]", "If the signing official is a third party acting on behalf of the Senior Official of the applicant company designated in Part 1 of the application, a designated Party Authorization form must be signed by the Senior Official and filed with the complete application.", "Si le signataire autorisé est un tiers agissant au nom du cadre principal de l’entreprise présentant la demande désigné dans la partie 1 de la demande, il faut que le formulaire d’autorisation de la partie désignée soit signé par le signataire autorisé et déposé avec la demande dûment remplie.");
setTT("xfa[0].form[0].Pla[0].sfAttestation[0].sfSignature[0].lblNote[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].lblTitle[0]", "ANIMAL TISSUE FORM", "FORMULAIRE POUR LES TISSUS D'ORIGINE ANIMALE");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].lblOriginator[0]", "Natural Health Products Directorate", "Direction des produits de santé naturels");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].lblOriginator[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].lblProtected[0]", "Protected when completed", "Protégé une fois rempli");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].lblProtected[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].btnSubmit[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"text-decoration:none\"&gt;Add another&lt;/p&gt;&lt;p style=\"text-decoration:none\"&gt;Animal Tissue Form&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Ajouter un autre&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;formulaire de tissu animal&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfHeader[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfIngredient[0].lblInstructions[0]", "1. -- Ingredient derived from animal tissue", "1. - Ingrédient contenant un (des) dérivé(s) de tissu animal");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfIngredient[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfIngredient[0].txtName[0]", "Name :", "Nom :");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfIngredient[0].txtName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].lblInstructions[0]", "2. -- Used as *", "2. -- Utilisé comme *");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].rblUsedAs[0].chkInProcessing[0]", "in processing of product", "dans la fabrication du produit");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].rblUsedAs[0].chkInProcessing[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].rblUsedAs[0].chkIngredient[0]", "Ingredient", "Ingrédient");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].rblUsedAs[0].chkIngredient[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].lblOr[0]", "OR", "OU");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection2[0].lblOr[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].lblInstructions[0]", "3. -- Animal species *", "3. -- Espèce animal *");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkCattle[0]", "cattle", "vache");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkCattle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkDeer[0]", "deer or elk", "cerf ou wapiti");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkDeer[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkSheep[0]", "sheep", "mouton");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkSheep[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkGoat[0]", "goat", "chèvre");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkGoat[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkPig[0]", "pig", "cochon");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkPig[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkPoultry[0]", "poultry", "volaille");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkPoultry[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkCrustacean[0]", "crustacean", "crustacé");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkCrustacean[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkOther[0]", "Other ", "Autre");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection3[0].rblSpecies[0].chkOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].lblInstructions[0]", "4. -- Animal tissues used *", "4. -- Tissu animal utilisé *");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkAdiopse[0]", "adipose tissue/omentum ", "tissu adipeux/épiploon");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkAdiopse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkAntler[0]", "antler velvet", "velours de bois");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkAntler[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkAppendix[0]", "appendix ", "appendice");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkAppendix[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBile[0]", "bile", "bile");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBile[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBlood[0]", "blood/blood products ", "sang/produits sanguins");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBlood[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBones[0]", "bones (other than vertebral column) ", "os (autre que la colonne vertébrale)");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBones[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBrain[0]", "brain ", "cerveau");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkBrain[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkColostrum[0]", "colostrum", "colostrum");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkColostrum[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkDorsal[0]", "dorsal root ganglia ", "ganglion de la racine dorsale");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkDorsal[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkDura[0]", "dura mater ", "dure-mère");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkDura[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkEnzymes[0]", "enzymes", "enzymes");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkEnzymes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkEyes[0]", "eyes/corneas ", "yeux/cornée");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkEyes[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkHeart[0]", "heart/pericardium ", "coeur/péricarde");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkHeart[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkIntestine[0]", "intestine ", "intestin");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkIntestine[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkIntestineSmall[0]", "small ", "petit");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkIntestineSmall[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkIntestineLarge[0]", "large", "grand");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkIntestineLarge[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkKidney[0]", "kidney ", "rein");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkKidney[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkLung[0]", "lung", "poumon");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkLung[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkMammary[0]", "mammary gland ", "glande mammaire");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkMammary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkMilk[0]", "milk and milk products", "lait, produits laitiers");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkMilk[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkMuscle[0]", "muscle, skeletal", "muscle, muscle squelettique");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkMuscle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkOvary[0]", "ovary ", "ovaire");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkOvary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkPancreas[0]", "pancreas", "pancréas");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkPancreas[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkPituitary[0]", "pituitary", "hypophyse");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkPituitary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSaliva[0]", "saliva, salivary gland ", "salive, glande salivaire");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSaliva[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSkin[0]", "skin/hides ", "peau/cuir");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSkin[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSkull[0]", "skull ", "crâne");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSkull[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSpinal[0]", "spinal cord", "moelle épinière");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSpinal[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSpleen[0]", "spleen ", "rate");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkSpleen[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTendons[0]", "tendons", "tendons");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTendons[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTestis[0]", "testis ", "testicule");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTestis[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkThymus[0]", "thymus", "thymus");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkThymus[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkThyroid[0]", "thyroid ", "glande thyroïde");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkThyroid[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTonsil[0]", "tonsil ", "amygdales");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTonsil[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTrigeminal[0]", "trigeminal ganglia ", "ganglion de Gasser");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkTrigeminal[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkVertebral[0]", "vertebral column ", "colonne vertébrale");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkVertebral[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection4[0].chkOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfInstructionBlock[0].lblInstructions[0]", "If you checked cattle; deer or elk; sheep; or goat, in section 3 please fill in the following two sections (5 and 6).", "Si vous avez coché vache; cerf ou wapiti; mouton; ou chèvre, dans section 3 veuillez remplir les sections ci-dessous. (section 5, 6).");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfInstructionBlock[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection5[0].txtAge[0]", "5. - What is (or will be) the age of the animals used?", "5. - Quel âge ont (ou auront) les animaux utilisés?");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection5[0].txtAge[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].lblInstructions[0]", "6. - Country/Countries from which the animals originates (or will originate)", "6. - De quel(s) pays proviennent (ou proviendont) ces animaux?");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkUruguay[0]", "Uruguay ", "Uruguay");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkUruguay[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkUnitedStates[0]", "United States ", "États-Unis");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkUnitedStates[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkBrazil[0]", "Brazil", "Brésil");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkBrazil[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkNewZealand[0]", "New Zealand", "Nouvelle-Zélande");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkNewZealand[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkAustralia[0]", "Australia", "Australie");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkAustralia[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkArgentina[0]", "Argentina", "Argentine");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSection6[0].chkArgentina[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSigningAuthority[0].lblInstructions[0]", "SIGNING AUTHORITY", "Signataire autorisé");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSigningAuthority[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSigningAuthority[0].lblDisclaimer[0]", "I am aware that the above information may be used to conduct a risk-based assessment before any decision is taken with regard to the accompanying Product Licence application.  I agree that if the company changes either the source or the type of animal sourced material used in the product prior to or after receiving final approval for a product submission, it must submit an Amendment of Product Licence form to the Natural Health Products Directorate of Health Canada.", "Je suis conscient que l'information ci-dessus pourrait être utilisée pour procéder à une évaluation des risques avant qu'une décision ne soit prise concernant la demande de licence de mise en marché ci-jointe. Je sais que si l'entreprise change la source ou le type de matière animale utilisé dans le produit avant ou après avoir reçu l'approbation finale, elle devra présenter une demande de modification au formulaire de licence de mise en marché à la Direction des produits de santé naturels de Santé Canada.");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSigningAuthority[0].lblDisclaimer[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSigningAuthority[0].chkAgree[0]", "I Agree", "J'accepte");
setTT("xfa[0].form[0].Pla[0].sfAnimalTissueForm[0].sfSigningAuthority[0].chkAgree[0]", "", "");

// **************************** ISSUE FORM ****************************
setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].id[0]", "ID", "ID");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].id[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].StaticText1[0]", "NHP INGREDIENTS DATABASE ISSUE FORM", "FORMULAIRE DE DEMANDE CONCERNANT LA BASE DE DONNÉES SUR LES INGRÉDIENTS DES PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].StaticText1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].StaticText2[0]", "We would like to thank you for your time and efforts in helping us to create a higher quality NHP ingredient database. NHPD is not obliged to implement any change requested in the NHP Ingredients Database.  Your issue will be processed and assessed in order of priority. You will be acknowledged once a decision/response has been finalized.", "Nous aimerions vous remercier pour le temps et les efforts consacrés pour nous aider à améliorer la qualité de la base de données sur les ingrédients des PSN. La DPSN n'a toutefois pas l'obligation d'apporter les changements demandés. Votre problème sera traité et évalué par ordre de priorité. Vous serez informé dès qu'une décision sera prise.");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].StaticText2[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].lblTrackingNumber[0]", "Tracking Number", "Numéro de suivi");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfHeader[0].lblTrackingNumber[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].sfHeading[0].lblHeading[0]", "PART 1 - REQUESTER", "PARTIE 1 - DEMANDEUR");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlLanguage[0]", "3. Language preferred:", "3. Langue de correspondance:");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlLanguage[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtAddress[0]", "4. Street/Suite/PO Box *", "4. Rue/Bureau/C.P. *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtAddress[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtCity[0]", "5. City - Town *", "5. Ville – Municipalité *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtCity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlProvince[0]", "7. Province - State", "7. Province – État");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlProvince[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlCountry[0]", "6. Country *", "6. Pays *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlCountry[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtPostalCode[0]", "8. Postal/ZIP Code *", "8. Code postal/code de zone *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtPostalCode[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtTelephone[0]", "9. Telephone No. *", "9. No de téléphone *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtTelephone[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtExtension[0]", "Ext.", "Poste");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtExtension[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtFax[0]", "10. Fax No.", "10. No de télécopieur");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtFax[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtEmail[0]", "11. E-mail", "11. Courriel");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtEmail[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtSurname[0]", "Surname *", "Nom *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtSurname[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtGivenName[0]", "Given Name *", "Prénom *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtGivenName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].lblName[0]", "1.Name", "1. Dénomination");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].lblName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtTitle[0]", "2. Title", "2. Titre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].txtTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].lblReference[0]", "Contact Address", "Adresse de la personne ressource");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].lblReference[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].lblHeading[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;PART 2 - REQUEST &lt;span style=\"font-size:8pt;font-weight:normal\"&gt;(Please do your best to provide us with the appropriate information pertaining to your issue by filling in the details below)&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p&gt;PARTIE 2 - DEMANDE &lt;span style=\"font-size:8pt;font-weight:normal\"&gt;(Veuillez fournir de l'information la plus précise possible relative à votre problème en remplissant les détails ci-bas).&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].txtTelephone[0]", "Date *", "Date *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].txtTelephone[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].ddlTypeOfRequest[0]", "Type of Request *", "Type de demande *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].ddlTypeOfRequest[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].ddlDataCategory[0]", "Your request is about data of (data category) *", "Votre demande concerne les données de (catégorie de données) *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].ddlDataCategory[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfReference[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfReference[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblRequest[0]", "Organism", "Organisme");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblRequest[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblRequestSummary[0]", "(a plant or a plant material, an alga, a bacterium, a fungus or a non-human animal material, an extract of the preceding or a probiotic (e.g. Allium sativum))", "(Plante ou matière végétale, algue, bactérie, champignon ou matière animale autre qu'une matière provenant de l'humain, un extrait des substances précédentes ou un probiotique (e.g. Allium sativum))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblRequestSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkApprovedName[0]", "NHPD approved names refer to latin binomial\r\nsupported by an NHPD authorized reference.", "Les noms approuvés par la DPSN font référence au\r\nnom latin binomial supporté par une référence\r\nautorisée par la DPSN");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkTaxonomicSynonym[0]", "Taxonomic Synonym", "Synonyme taxonomique");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkTaxonomicSynonym[0]", "Other scientific names", "Autres noms scientifiques");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkTaxonomicClassification[0]", "Taxonomic Classification", "Classification taxonomique");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkTaxonomicClassification[0]", "Taxonomic nodes: family, genus, species, subspecies", "Nodes taxonomiques: famille, genre, espèce,\r\nsous-espèce");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkReference[0]", "Reference", "Référence");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkReference[0]", "NHPD authorized references for organism", "Référence autorisée par la DPSN pour organisme");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].txtOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].txtOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkCommonName[0]", "Common Name", "Nom usuel");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkCommonName[0]", "Common names for an organism", "Noms usuels pour organisme");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkNonMedicinalIngredientData[0]", "Non-medicinal Ingredient Information", "Données d'ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkNonMedicinalIngredientData[0]", "Data related to non-medicinal role or purpose (i.e.\r\nneeded for the formulation of the dosage form)", "Donnée sur le rôle ou fin non médicinale (i.e.\r\nrequise pour la forme posologique)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkGRIN[0]", "GRIN (Germplasm Resources Information Network)", "GRIN (Germplasm Resources Information Network)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkGRIN[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkCOL[0]", "COL (Species 2000 and Catalogue of Life)", "COL(Species 2000 and Catalogue of Life)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkCOL[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkITIS[0]", "ITIS (Integrated Taxonomic Information System)", "ITIS (Système d'information taxonomique intégré)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkITIS[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkEOL[0]", "EOL (Encyclopedia of Life)", "EOL (Encyclopedia of Life)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkEOL[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkHOC[0]", "HOC (Herbs of Commerce 2)", "HOC (Herbs of Commerce 2)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkHOC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkOrgOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].chkOrgOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblReferenceAut[0]",  "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganism[0].lblReferenceAut[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblRequest[0]", "Organism Substance", "Substance dérivée d'un organisme");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblRequest[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblRequestSummary[0]", "(any substance derived from an organism that consists of the organism's name, part and preparation (e.g. Garlic Bulb Powder))", "(toute substance dérivée d'un organisme et qui consiste d'un nom d'organisme, d'une partie et d'une préparation (e.g. Tête d'ail séchée))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblRequestSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkApprovedName[0]", "NHPD approved names refer to well-characterized\r\norganism substance names", "Les noms approuvés par la DPSN font référence à des\r\nnoms de substance dérivée d'un organisme bien caractérisés");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkProperName[0]", "Proper Name", "Nom Propre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkProperName[0]", "Other names for the substance", "Autres noms pour la substance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkCommonName[0]", "Common Name", "Nom usuel");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkCommonName[0]", "Common Names for Organism Substance", "Nom usuel pour la substance");setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkToxicityRestriction[0]", "Toxicity Restriction", "Restriction de toxicité");

setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkToxicityRestriction[0]", "Data related to the toxicity restriction of the\r\nsubstance (i.e. limit above which harmful effects\r\nare possible)", "Données sur la restriction de toxicité de la\r\nsubstance (i.e. limit à partir de laquelle des\r\neffets nocifs sont possibles)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkParentOrganism[0]", "Parent Organism", "Organisme d'origine");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkParentOrganism[0]", "Data related to the organism the substance comes\r\nfrom", "Données sur l'organisme de provenance de la\r\nsubstance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkReference[0]", "Reference", "Référence");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkReference[0]", "NHPD authorized references for organism substance", "Références autorisées par la DPSN pour substance\r\nd'organisme");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].txtOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].txtOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkNonMedicinalIngredientData[0]", "Non-medicinal Ingredient Information", "Données d'ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkNonMedicinalIngredientData[0]", "Data related to non-medicinal role or purpose (i.e.\r\nneeded for the formulation of the dosage form)", "Donnée sur le rôle ou fin non médicinale (i.e.\r\nrequise pour la forme posologique)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkOrganismPart[0]", "Source Material / Preparation", "Matière d'origine / préparation");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkOrganismPart[0]", "The Source Material and preparations for the\r\nsubstance", "Les parties et préparations de la substance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkTGA[0]", "TGA (Approved terminology for medicines)", "TGA (Approved terminology for medicines)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkTGA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkCP[0]", "CP (Pharmacopoeia of the People's Republic of China, English 2005)", "CP (Pharmacopoeia of the People's Republic of China, English 2005)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkCP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkCMM[0]", "CMM (The Chinese Materia Medica)", "CMM (The Chinese Materia Medica)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkCMM[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkC[0]", "C (Chinese Herbal Medicine, MateriaMedica, Revised 1993)", "C (Chinese Herbal Medicine, MateriaMedica, Revised 1993) ");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkAPI[0]", "API (Ayurvedic Pharmacopoeia of India)", "API (Ayurvedic Pharmacopoeia of India)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkAPI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblReferenceAut[0]",  "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].lblReferenceAut[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkBHP[0]", "BHP (British Herbal Pharmacopoeia)", "BHP (British Herbal Pharmacopoeia)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkBHP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkBP[0]", "BP (British Pharmacopoeia 2008)", "BP (British Pharmacopoeia 2008)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkBP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkFCC[0]", "FCC (Food Chemicals Codex 6)", "FCC (Food Chemicals Codex 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkFCC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkMI[0]", "MI (Merck Index 14)", "MI (Merck Index 14)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkUSP[0]", "USP (United States Pharmacopoeia 31-NF-26)", "USP (United States Pharmacopoeia 31-NF-26)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkUSP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkJECFA[0]", "JECFA (WHO/FAO Joint Expert Committee on Food Additives (JECFA) - Monographs &amp; Evaluations cited [2004-2008])", "JECFA (WHO/FAO Joint Expert Committee on Food Additives (JECFA) - Monographs &amp; Evaluations cited [2004-2008])");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkJECFA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkOrgSubstOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkOrgSubstOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkEP[0]", "EP (European Pharmacopoeia 6)", "EP (European Pharmacopoeia 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkEP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkMAR[0]", "MAR (Martindale, The Extra Pharmacopoeia 33)", "MAR (Martindale, The Extra Pharmacopoeia 33)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkMAR[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkICID[0]", "ICID (International Cosmetic Ingredient Dictionary (CTFA))", "ICID (International Cosmetic Ingredient Dictionary (CTFA))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkICID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkEPA[0]", "EPA (Environmental Protection Agency)", "EPA (Environmental Protection Agency)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkEPA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkFDA[0]", "FDA (EAFUS: A Food Additive Database)", "FDA (EAFUS: A Food Additive Database)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfOrganismSubstance[0].chkFDA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblHeader[0]", "Chemical Substance", "Substance chimique");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblHeader[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblHeaderSummary[0]", "(a purified constituent of a defined molecular structure which can be isolated from a plant or a plant material, an alga, a bacterium, a fungus or a non-human animal material; may be chemically synthesized( e.g. Ascorbic acid))", "(constituant purifié avec une structure moléculaire définie qui peut être isolée d'une plante ou de matière végétale, d'une algue, d'une bactérie, d'un champignon ou de matière animale autre qu'une matière provenant de l'humain; peut être synthétisé chimiquement (e.g. Acide ascorbique))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblHeaderSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkApprovedName[0]", "NHPD approved names refer to well-characterized\r\nchemical substance names", "Les noms approuvés par la DPSN font référence à des\r\nnoms de substance chimique bien caractérisés");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCAS[0]", "CAS/RN (Chemical Abstract Service or other Registry Numbers)", "Numéro d'enregistrement CAS et autres numéros d'enregistrement");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCAS[0]", "CAS registry numbers are unique numerical\r\nidentifiers for chemical compounds, polymers,\r\nbiological sequences, mixtures and alloys. They are\r\nalso referred to as CAS numbers, CAS RNs or CAS #s.", "Les numéros d'enregistrement CAS sont des\r\nidentificateurs numériques uniques pour les\r\ncomposés chimiques, les polymères, les séquences\r\nbiologiques, les mixtures et les alliages.  Ils\r\nsont aussi connus sous le nom de numéros CAS.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkProperName[0]", "Proper Name", "Nom Propre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkProperName[0]", "Other names for the substance", "Autres noms pour la substance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCommonName[0]", "Common Name", "Nom usuel");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCommonName[0]", "Common Name for Chemical", "Nom usuel Pour la substance chimique");setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkToxicityRestriction[0]", "Toxicity Restriction", "Restriction de toxicité");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkToxicityRestriction[0]", "Data related to the toxicity restriction of the\r\nsubstance (i.e. limit above which harmful effects\r\nare possible)", "Données sur la restriction de toxicité de la\r\nsubstance (i.e. limit à partir de laquelle des\r\neffets nocifs sont possibles)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkReference[0]", "Reference", "Référence");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkReference[0]", "NHPD authorized references for chemicals", "Références autorisées par la DPSN pour substances\r\nchimiques");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].txtOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].txtOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkNonMedicinalIngredientData[0]", "Non-medicinal Ingredient Information", "Données d'ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkNonMedicinalIngredientData[0]", "Data related to non-medicinal role or purpose (i.e.\r\nneeded for the formulation of the dosage form)", "Donnée sur le rôle ou fin non médicinale (i.e.\r\nrequise pour la forme posologique)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkSubingredientData[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkSubingredientData[0]", "Subingredients from a chemical are medicinal\r\ningredients it can provide. ", "Les sous-ingrédients d'une substance chimique sont\r\nles ingrédients médicinaux qu'elle fourni.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkSource[0]", "Sources", "Provenances");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkSource[0]", "Sources are chemicals or organism parts which\r\nprovide the ingredient in question.", "Les matières d'origine sont les substances\r\nchimiques ou les parties d'organismes qui\r\nfournissent l'ingrédient en question");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblReferenceAut[0]",  "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].lblReferenceAut[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkBP[0]", "BP (British Pharmacopoeia 2008)", "BP (British Pharmacopoeia 2008)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkBP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCAS1[0]", "CAS (Chemical Abstract Service)", "CAS (Chemical Abstracts Service)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCAS1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCHEMID[0]", "CHEMID (ChemIDplus)", "CHEMID (ChemIDplus)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkCHEMID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkECFL[0]", "EC-FL (Commission Decision 2002/113/EC of 23 January 2002 - PART A Flavouring Substances))", "EC-FL (Commission Decision 2002/113/EC of 23 January 2002 - PART A Flavouring Substances))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkECFL[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkEP[0]", "EP (European Pharmacopoeia 6)", "EP (European Pharmacopoeia 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkEP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkEPA[0]", "EPA (Environmental Protection Agency)", "EPA (Environmental Protection Agency)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkEPA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkFCC[0]", "FCC (Food Chemicals Codex 6)", "FCC (Food Chemicals Codex 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkFCC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkFDA[0]", "FDA (EAFUS: A Food Additive Database)", "FDA (EAFUS: A Food Additive Database)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkFDA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkFEMA[0]", "FEMA (Flavor Extract Manufacturer's Association)", "FEMA (Flavor Extract Manufacturer's Association)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkFEMA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkICID[0]", "ICID (International Cosmetic Ingredient Dictionary (CTFA))", "ICID (International Cosmetic Ingredient Dictionary (CTFA))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkICID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkINN[0]", "INN (International Nonproprietary Names)", "INN (International Nonproprietary Names)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkINN[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkIUPAC[0]", "IUPAC (Principles of Chemical Nomenclature: a Guide to IUPAC Recommendations)", "IUPAC (Principles of Chemical Nomenclature: a Guide to IUPAC Recommendations)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkIUPAC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkJECFA[0]", "JECFA (WHO/FAO Joint Expert Committee on Food Additives (JECFA) - Monographs &amp; Evaluations cited [2004-2008])", "JECFA (WHO/FAO Joint Expert Committee on Food Additives (JECFA) - Monographs &amp; Evaluations cited [2004-2008])");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkJECFA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkMI[0]", "MI (Merck Index 14)", "MI (Merck Index 14)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkUSP[0]", "USP (United States Pharmacopoeia 31-NF-26)", "USP (United States Pharmacopoeia 31-NF-26)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkUSP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkChemicalOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfChemical[0].chkChemicalOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblHeader[0]", "Protein", "Protéine");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblHeader[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblHeaderSummary[0]", "(consisting of amino acids which are a class of organic molecules that contain amino and carboxyl groups (e.g. Alpha-amylase))", "(consiste des acides aminés qui sont une classe de molécules organiques contenant des groupements aminés et carboxyliques (e.g. Alpha-amylase))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblHeaderSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkApprovedName[0]", "NHPD approved name for a protein substance", "Nom approuvé par la DPSN pour une substance\r\nprotéique");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkCAS[0]", "EC Number, CAS Registry Number or Other Registry Numbers", "Numéro EC, numéro d'enregistrement CAS ou autres numéros d'enregistrement");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkCAS[0]", "Enzyme Commission number (EC number) is a numerical\r\nclassification scheme for enzymes, based on the\r\nchemical reactions they catalyze.", "Le numéro EC (Enzyme Commission number) est une\r\nclassification numérique pour les enzymes, basée\r\nsur les réactions chimiques qu'ils catalysent.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkProperName[0]", "Proper Name", "Nom Propre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkProperName[0]", "Other names for the substance", "Autres noms pour la substance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkCommonName[0]", "Common Name", "Nom usuel");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkCommonName[0]", "Common Name for protein", "Nom usuel pour la substance protéique");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkToxicityRestriction[0]", "Toxicity Restriction", "Restriction de toxicité");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkToxicityRestriction[0]", "Data related to the toxicity restriction of the\r\nsubstance (i.e. limit above which harmful effects\r\nare possible)", "Données sur la restriction de toxicité de la\r\nsubstance (i.e. limit à partir de laquelle des\r\neffets nocifs sont possibles)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkReference[0]", "Reference", "Référence");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkReference[0]", "NHPD authorized references for protein", "Référence autorisée par la DPSN pour protéine");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].txtOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].txtOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkSourceOrganism[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkSourceOrganism[0]", "Source Materials provides the substance in\r\nquestion.", "Les parties de l'organisme d'origine fournissent la\r\nsubstance en question");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkSubingredientData[0]", "Protein family members", "Membres de famille de protéines");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkSubingredientData[0]", "Protein family members are proteins belong to a\r\nprotein family, the substance in question", "Les membres de famille de protéines sont des\r\nprotéines qui appartiennent à une famille de\r\nprotéine, la substance en question");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkNonMedicinalIngredientData[0]", "Non-medicinal Ingredient Information", "Données d'ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkNonMedicinalIngredientData[0]", "Data related to non-medicinal role or purpose (i.e.\r\nneeded for the formulation of the dosage form)", "Donnée sur le rôle ou fin non médicinale (i.e.\r\nrequise pour la forme posologique)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblReferenceAut[0]",  "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].lblReferenceAut[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkIUBMB[0]", "IUBMB (International Union of Biochemistry and Molecular Biology)", "IUBMB (International Union of Biochemistry and Molecular Biology)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkIUBMB[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkBP[0]", "BP (British Pharmacopoeia 2008)", "BP (British Pharmacopoeia 2008)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkBP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkCHEMID[0]", "CHEMID (ChemIDplus)", "CHEMID (ChemIDplus)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkCHEMID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkEP[0]", "EP (European Pharmacopoeia 6)", "EP (European Pharmacopoeia 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkEP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkEPA[0]", "EPA (Environmental Protection Agency)", "EPA (Environmental Protection Agency)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkEPA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkFCC[0]", "FCC (Food Chemicals Codex 6)", "FCC (Food Chemicals Codex 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkFCC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkFDA[0]", "FDA (EAFUS: A Food Additive Database)", "FDA (EAFUS: A Food Additive Database)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkFDA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkINN[0]", "INN (International Nonproprietary Names)", "INN (International Nonproprietary Names)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkINN[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkJECFA[0]", "JECFA (WHO/FAO Joint Expert Committee on Food Additives (JECFA) - Monographs &amp; Evaluations cited [2004-2008])", "JECFA (WHO/FAO Joint Expert Committee on Food Additives (JECFA) - Monographs &amp; Evaluations cited [2004-2008])");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkJECFA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkMI[0]", "MI (Merck Index 14)", "MI (Merck Index 14)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkUSP[0]", "USP (United States Pharmacopoeia 31-NF-26)", "USP (United States Pharmacopoeia 31-NF-26)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkUSP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkMAR[0]", "MAR (Martindale, The Extra Pharmacopoeia 33)", "MAR (Martindale, The Extra Pharmacopoeia 33)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkMAR[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkProteinOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfProtein[0].chkProteinOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblHeader[0]", "Herbal Component", "Composante d'origine végétale");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblHeader[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblHeaderSummary[0]", "(chemical compounds or groups of chemical compounds which are components of plant and plant materials (e.g. Aloinoside))", "(composés chimiques ou groupes de composés chimiques qui sont des composantes de plante ou de matière végétale (e.g. Aloinoside))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblHeaderSummary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkApprovedName[0]", "Approved Name", "Nom approuvé");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkApprovedName[0]", "NHPD approved name", "Nom approuvé par la DPSN");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkCAS[0]", "CAS Registry Number or Other Registry Numbers", "Numéro d'enregistrement CAS ou autres numéros d'enregistrement");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkCAS[0]", "CAS registry numbers are unique numerical\r\nidentifiers for chemical compounds, polymers,\r\nbiological sequences, mixtures and alloys. They are\r\nalso referred to as CAS numbers, CAS RNs or CAS #s.", "Les numéros d'enregistrement CAS sont des\r\nidentificateurs numériques uniques pour les\r\ncomposés chimiques, les polymères, les séquences\r\nbiologiques, les mixtures et les alliages.  Ils\r\nsont aussi connus sous le nom de numéros CAS.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkProperName[0]", "Proper Name", "Nom Propre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkProperName[0]", "Other names for the substance", "Autres noms pour la substance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkCommonName[0]", "Common Name", "Nom usuel");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkCommonName[0]", "Common Name for Herbal Component", "Nom usuel pour la composante d'origine végétale");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkToxicityRestriction[0]", "Toxicity Restriction", "Restriction de toxicité");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkToxicityRestriction[0]", "Data related to the toxicity restriction of the\r\nsubstance (i.e. limit above which harmful effects\r\nare possible)", "Données sur la restriction de toxicité de la\r\nsubstance (i.e. limit à partir de laquelle des\r\neffets nocifs sont possibles)");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkReference[0]", "Reference", "Référence");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkReference[0]", "NHPD authorized references for herbal component", "Référence autorisée par la DPSN pour composante\r\nd'herbes");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].txtOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].txtOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkSourceOrganism[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkSourceOrganism[0]", "Source Material provides the substance in\r\nquestion.", "Les parties de l'organisme d'origine fournissent la\r\nsubstance en question");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkClassification[0]", "Chemical Class", "Classe chimique");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkClassification[0]", "Chemical class is one of the following:\r\ncarbohydrates and lipids, nitrogen-containing\r\ncompounds, alkaloids, phenolics, and terpenoids. \r\nThe chemical subclass is one of the subordinate\r\nchemical groups of chemical classes.", "La classe chimique est une des suivantes: glucides\r\net lipides, composés azotés, alcaloïdes, composés\r\nphénoliques et terpénoïdes.  La sous-classe\r\nchimique est un des groupes chimiques subordonnés\r\ndes classes chimiques.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblReferenceAut[0]",  "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].lblReferenceAut[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkCHEMID[0]", "CHEMID (ChemIDplus)", "CHEMID (ChemIDplus)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkCHEMID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkECFL[0]", "EC-FL (Commission Decision 2002/113/EC of 23 January 2002 - PART A Flavouring Substances))", "EC-FL (Commission Decision 2002/113/EC of 23 January 2002 - PART A Flavouring Substances))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkECFL[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkMI[0]", "MI (Merck Index 14)", "MI (Merck Index 14)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkUSP[0]", "USP (United States Pharmacopoeia 31-NF-26)", "USP (United States Pharmacopoeia 31-NF-26)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkUSP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkDUKE[0]", "DUKE (Handbook of Phytochemical Constituents of GRAS Herbs and Other Economic Plants)", "DUKE (Handbook of Phytochemical Constituents of GRAS Herbs and Other Economic Plants)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkDUKE[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkTGA[0]", "TGA (Approved terminology for medicines)", "TGA (Approved terminology for medicines)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkTGA[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkMAR[0]", "MAR (Martindale, The Extra Pharmacopoeia 33)", "MAR (Martindale, The Extra Pharmacopoeia 33)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkMAR[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkPCD[0]", "PCD (Phytochemical Dictionary)", "PCD (Phytochemical Dictionary)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkPCD[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkBHC[0]", "BHC (British Herbal Compendium)", "BHC (British Herbal Compendium)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkBHC[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkEP[0]", "EP (European Pharmacopoeia 6)", "EP (European Pharmacopoeia 6)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkEP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkDAB[0]", "DAB (Deutsches Arzneibuch (German Pharmacopoeia))", "DAB (Deutsches Arzneibuch (German Pharmacopoeia))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkDAB[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkBP[0]", "BP (British Pharmacopoeia 2008)", "BP (British Pharmacopoeia 2008)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkBP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkICID[0]", "ICID (International Cosmetic Ingredient Dictionary (CTFA))", "ICID (International Cosmetic Ingredient Dictionary (CTFA))");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkICID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkHerbalOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHerbalComponent[0].chkHerbalOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].lblHeader[0]", "Standards / Terminology", "Normes / Terminologie");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].lblHeader[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkOrganismPart[0]", "Source Material", "Matière d'origine");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkOrganismPart[0]", "NHPD approved name", "Nom approuvé par la DPSN");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkOrganismType[0]", "Organism Type", "Type d'organisme");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkOrganismType[0]", "CAS registry numbers are unique numerical\r\nidentifiers for chemical compounds, polymers,\r\nbiological sequences, mixtures and alloys. They are\r\nalso referred to as CAS numbers, CAS RNs or CAS #s.", "Les numéros d'enregistrement CAS sont des\r\nidentificateurs numériques uniques pour les\r\ncomposés chimiques, les polymères, les séquences\r\nbiologiques, les mixtures et les alliages.  Ils\r\nsont aussi connus sous le nom de numéros CAS.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkOrganismSubstancePreparation[0]", "Organism Substance Preparation", "Préparation de substance dérivée d'un organisme");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkOrganismSubstancePreparation[0]", "Other names for the substance", "Autres noms pour la substance");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkUnit[0]", "Unit", "Unité");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkUnit[0]", "NHPD authorized references for herbal component", "Référence autorisée par la DPSN pour composante d'origine végétale");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].txtOther[0]", "Other", "Autre");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].txtOther[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkDosageForm[0]", "Dosage Form", "Forme posologique");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkDosageForm[0]", "Source Material provides the substance in\r\nquestion.", "Les parties de l'organisme d'origine fournissent la\r\nsubstance en question");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkRouteOfAdministration[0]", "Route of Administration", "Voie d'administration");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkRouteOfAdministration[0]", "Chemical class is one of the following:\r\ncarbohydrates and lipids, nitrogen-containing\r\ncompounds, alkaloids, phenolics, and terpenoids. \r\nThe chemical subclass is one of the subordinate\r\nchemical groups of chemical classes.", "La classe chimique est une des suivantes: glucides\r\net lipides, composés azotés, alcaloïdes, composés\r\nphénoliques et terpénoïdes.  La sous-classe\r\nchimique est un des groupes chimiques subordonnés\r\ndes classes chimiques.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkNMIPurpose[0]", "Non-medicinal Ingredient Purpose", "Fin d'ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkNMIPurpose[0]", "NHPD authorized references for herbal component", "Référence autorisée par la DPSN pour composante\r\nd'herbes");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkAuthorizedReference[0]", "Authorized Reference", "Référence autorisée");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].chkAuthorizedReference[0]", "NHPD authorized references for herbal component", "Référence autorisée par la DPSN pour composante\r\nd'herbes");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].lblReference[0]", "References", "Références");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfStandards[0].lblReference[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfAuthorizedNameRef[0].chkAuthorizedNameRef[0]", "NHPD authorized references", "Référence autorisée par la DPSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfAuthorizedNameRef[0].chkAuthorizedNameRef[0]", "NHPD authorized references", "Référence autorisée par la DPSN");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfAuthorizedNameRef[0].lblAuthorizedNameRef[0]", "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfAuthorizedNameRef[0].lblAuthorizedNameRef[0]", "NHP Ingredients Database Authorized Naming References", "Références de nom autorisées pour la Base de données sur les ingrédients PSN");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].txtApprovedName[0]", "NHPD Approved Name (if applicable)", "Nom approuvé par la DPSN (s'il y a lieu)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].txtApprovedName[0]", "The existing NHPD approved name your request\r\nrelated to.", "Le nom approuvé par la DPSN relié à votre demande");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].txtRequestDetail[0]", "Request Detail (For organisms, please provide Latin binomial names such as 'Allium sativum' for garlic.) *", "Détails de la demande (Pour les organismes, veuillez fournir leurs noms binomial latin tels que 'Allium sativum' pour l'ail.) *");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].txtRequestDetail[0]", "Request content, rational, or any other data you\r\nthink they are useful to us.", "Contenu de la demande, justification et tout autre\r\ndonnée qui pourrait nous être utile.");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].txtOtherReferences[0]", "References / Other References (For pharmacopoeias, specify the edition, preferably the latest.  For scientifically validated web sites, specify the URL. For journal articles, specify the journal name, author name(s), volume, year and page number.)", "Références / Autres références (Pour les pharmacopées, veuillez spécifier l'édition, de préférence la plus récente.  Pour les sites web validés scientifiquement, veuillez spécifier son URL.  Pour les articles de revues, veuillez spécifier le nom de la revue, le ou les auteur(s), le volume, l'année et la pagination.)");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].txtOtherReferences[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].btnFinalise[0]", "Finalize", "Terminer");
setTT("xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfFooter[0].btnFinalise[0]", "", "");

// **************************** End Issue Form ****************************

setLbl("xfa[0].form[0].Pla[0].sfSubmit[0].btnSubmit[0]", "Finalize", "Terminer");
setTT("xfa[0].form[0].Pla[0].sfSubmit[0].btnSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSubmit[0].btnEmailSubmit[0]", "Submit by Email", "Submit by Email");
setTT("xfa[0].form[0].Pla[0].sfSubmit[0].btnEmailSubmit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSubmit[0].btnTest[0]", "Test", "Test");
setTT("xfa[0].form[0].Pla[0].sfSubmit[0].btnTest[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].lblHeader[0]", "The form has been completed. Please save your form and submit it to the NHPD via mail or using PosteCS.", "Le formulaire a été complété. Veuillez sauvegarder votre formulaire et le soumettre à la DPSN soit par courrier ou soit en utilisant PosteCS.");
setTT("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].lblHeader[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].btnModify[0]", "Modify", "Modifier");
setTT("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].btnModify[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].btnNew[0]", "New Application", "Nouvelle demande");
setTT("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].btnNew[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].btnPLChange[0]", "Post-Licence Change", "Changements après délivrance de la licence");
setTT("xfa[0].form[0].Pla[0].sfMsgValidFooter[0].btnPLChange[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkChemical[0]", "Chemical", "Substance chimique");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkChemical[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkProtein[0]", "Protein", "Protéine");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkProtein[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkOrganism[0]", "Organism", "Organisme");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkOrganism[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkOrganismSubstance[0]", "Defined Organism Substance", "Substance dérivée d'un organisme défini");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkOrganismSubstance[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkAny[0]", "Any", "N'importe lequel");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].rblNameCategory[0].chkAny[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].btnSearch[0]", "Search", "Rechercher");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].btnSearch[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].txtKeyword[0]", "Keyword", "Mot-clé");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].txtKeyword[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].btnNext[0]", "Close", "Fermer");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].btnNext[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfMonographSearchForm[0].btnSearch[0]", "Search", "Rechercher");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfMonographSearchForm[0].btnSearch[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfMonographSearchForm[0].txtKeyword[0]", "Keyword", "Mot-clé");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfMonographSearchForm[0].txtKeyword[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfMonographSearchForm[0].btnNext[0]", "Close", "Fermer");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfMonographSearchForm[0].btnNext[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].txtPage[0]", "Page", "Page");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].txtPage[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].txtRPP[0]", "Results per page", "Résultats par page");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].txtRPP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].txtTotal[0]", "Total", "Total");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].txtTotal[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].btnPrev[0]", "&lt;&lt;", "&lt;&lt;");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].btnPrev[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].btnNext[0]", "&gt;&gt;", "&gt;&gt;");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].btnNext[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].lblInstructions[0]", "Please click on an ingredient name to add the ingredient to the form ", "Veuillez cliquer sur un nom d'ingrédient pour ajouter l'ingrédient au formulaire");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfHeading[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfNoResults[0].lblInstructions[0]", "Sorry, no results matched your criteria.", "Il n'y a aucun résultat qui corresponde à vos critères");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfNoResults[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfRow[0].btnMoreDetails[0]", "More Details", "Détails supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfIngredient[0].sfRow[0].btnMoreDetails[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].txtPage[0]", "Page", "Page");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].txtPage[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].txtRPP[0]", "Results per page", "Résultats par page");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].txtRPP[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].txtTotal[0]", "Total", "Total");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].txtTotal[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].btnPrev[0]", "&lt;&lt;", "&lt;&lt;");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].btnPrev[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].btnNext[0]", "&gt;&gt;", "&gt;&gt;");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].btnNext[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].lblInstructions[0]", "The search results provide the monograph name along with the names of the ingredient associated with the monograph.  Please click on the monograph name to add the monograph to the form", "Les résultats de la recherche fournissent le nom de la monographie ainsi que les noms des ingrédients associés avec la monographie.  Veuillez cliquer sur le nom de la monographie pour ajouter la monographie au formulaire.");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfHeading[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfNoResults[0].lblInstructions[0]", "Sorry, no results matched your criteria.", "Il n'y a aucun résultat qui corresponde à vos critères");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfNoResults[0].lblInstructions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfRow[0].btnMoreDetails[0]", "More Details", "Détails supplémentaires");
setTT("xfa[0].form[0].Pla[0].sfSearch[0].sfSearchResults[0].sfMonograph[0].sfRow[0].btnMoreDetails[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfMain[0].lblTitle[0]", "NHP ONLINE LABEL TEXT EDITOR", "REVISEUR DE TEXTE D'ETIQUETTE DE PSN EN DIRECT");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfMain[0].lblTitle[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfHeading[0].lblHeading[0]", "PRINCIPAL DISPLAY PANEL", "ESPACE PRINCIPAL AVANT");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfHeading[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfHeading[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfBrandNames[0].txtPrimaryBrandName[0]", "Primary Brand Name:", "Marque nominative principale :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfBrandNames[0].txtPrimaryBrandName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfBrandNames[0].txtOtherBrandNames[0]", "Other Brand Name:", "Autre marque nominative :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfBrandNames[0].txtOtherBrandNames[0]", "", "");

//setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].txtNPN[0]", "Natural Product Number (NPN):", "Numéro du produit naturel (NPN) :");
//setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].txtNPN[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].txtNetAmount[0]", "Net Amount in Container:", "Montant Net du Contenant :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].txtNetAmount[0]", "The Net Amount in Container field defines what's in the container in terms of weight, measure or number, which is mandatory to appear on the label.  Examples are '900 mg', '500 ml', '40 tablets' and so on.", "Le champ Montant Net du Contenant défini ce que l'on retrouve dans le contenant en termes de poids, de capacité, ou de nombre, ce qui est une information obligatoire pour l'étiquette.  Des exemples sont '900 mg', '500 ml', '40 comprimés', et ainsi de suite.");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].ddlWeight[0]", "Weight/Measure/Number:", "Poids/Grandeur/Nombre :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].ddlWeight[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].gr.ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].txtDosageForm[0]", "Dosage Form:", "Forme posologique :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].txtDosageForm[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].txtDosageUnit[0]", "Dosage Unit:", "Unité posologique :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].txtDosageUnit[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].ckSterile[0]", "Sterile:", "Stérile :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfFrontPanel[0].sfContent[0].sfOtherFrontPanelText[0].grOFPT[0].ckSterile[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfHeading[0].lblHeading[0]", "ANY PANEL", "TOUT ESPACE");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfHeading[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfHeading[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading0[0].lblHeading[0]", "Applicant or  License Holder", "Demandeur ou titulaire de licence");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading0[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading0[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading0[0].ckHide[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtCompany[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Company Name&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span style=\"text-decoration:none\"&gt;:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Nom d'entreprise&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span style=\"text-decoration:none\"&gt;:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtCompany[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtStreet[0]", "Street/Suite/Land Location:", "Rue/bureau/ B.P.:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtStreet[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].ckStreet[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].ckStreet[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtCity[0]", "City:", "Ville:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtCity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].ckCity[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].ckCity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtProvince[0]", "Province :", "Province:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtProvince[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].ckProvince[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].ckProvince[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtCountry[0]", "Country:", "Pays:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtCountry[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtPostalCode[0]", "Postal Code:", "Code postale:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtPostalCode[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtAdditionalInfo[0]", "Additional License Holder Information", "Information supplémentaire sur le titulaire de licence");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfProductLicenseHolder[0].txtAdditionalInfo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading1[0].lblHeading[0]", "Importer", "Importateur");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading1[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading1[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading1[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfHeading[0].txtImporter[0]", "Importer:", "Importateur :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfHeading[0].txtImporter[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfHeading[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfHeading[0].ckIncluded[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfCompanyName[0].txtPart4[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Company Name&lt;span style=\"xfa-spacerun:yes\"&gt; &lt;/span&gt;&lt;span style=\"text-decoration:none\"&gt;:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", "");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfCompanyName[0].txtPart4[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfStreet[0].txtPart4[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p&gt;Street/Suite/Land Location&lt;span style=\"text-decoration:none\"&gt;:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;", "");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfStreet[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfStreet[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].sfStreet[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].txtAdditionalInfo[0]", "Additional Importer Information", "Information supplémentaire sur le titulaire de licence");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].txtAdditionalInfo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress1[0].sfCountry[0].txtPart4[0]", "Country:", "Pays :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress1[0].sfCountry[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress1[0].sfCity[0].txtPart4[0]", "City - Town:", "Ville :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress1[0].sfCity[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress1[0].sfCity[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress1[0].sfCity[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress2[0].sfProvince[0].txtPart4[0]", "Province/State:", "Province/état");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress2[0].sfProvince[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress2[0].sfProvince[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress2[0].sfProvince[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress2[0].sfPostalCode[0].txtPart4[0]", "Postal/ZIP Code:", "Code postal/code de zone");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfImporterContainer[0].sfImporter[0].grAddress2[0].sfPostalCode[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading2[0].lblHeading[0]", "A -Medicinal Ingredient", "A - Ingrédient médicinal");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading2[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading2[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading2[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].txtMINumber[0]", "Ingredient:", "Ingrédient:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].txtMINumber[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].txtId[0]", "Numeric Field", "Champ numérique");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].txtId[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfName[0].txtProperName[0]", "Proper Name :", "Nom propre :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfName[0].txtProperName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfName[0].txtCommonName[0]", "Common Name :", "Nom commun :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfName[0].txtCommonName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].txtSource[0]", "Source:", "Provenance :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].txtSource[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].ddlWebsite[0]", "Source  Website :", "Site web d'origine :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].ddlWebsite[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].rdSource[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].rdSource[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].rdWebsite[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfHomeopathicSource[0].rdWebsite[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfSourceMaterial[0].txtPart4[0]", "Source :", "Provenance :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfSourceMaterial[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfQuantityAndUnit[0].txtPart4[0]", "Quantity per Dosage Unit:", "Quantité par unité posologique :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfQuantityAndUnit[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfAddQuantityAndUnit[0].txtPart4[0]", "Additional Quantity and Unit:", "Quantité et Unité additionnelles");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfAddQuantityAndUnit[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotencyHeader[0].lblHeading[0]", "Potency", "Activité");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotencyHeader[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotency[0].txtId[0]", "Potency ID", "Identité de l'activité");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotency[0].txtId[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotency[0].sfConstituent[0].txtPart4[0]", "Potency Constituent:", "Constituant d'activité :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotency[0].sfConstituent[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotency[0].sfAmount[0].txtPart4[0]", "Potency Amount:", "Quantité d'activité :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfPotency[0].sfAmount[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].txtRatio[0]", "Extract Ratio :", "Ratio d'extraction :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].txtRatio[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].txtQCE[0]", "Quantity Crude Equivalent:", "Quantité brute équivalente :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].txtQCE[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].txtOriginalMaterialUsed[0]", "Original Material Used:", "Matériel original utilisé :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].txtOriginalMaterialUsed[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfMedicinalIngredients[0].sfMedicinalIngredient[0].sfExtract[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading3[0].lblHeading[0]", "D - Recommended Conditions of Use", "D - Conditions d'utilisation recommandées");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading3[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading3[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfHeading3[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfClaim[0].txtPart4[0]", "Recommended Use or Purpose on ePLA:", "Valeur sur l'étiquette provenant du formulaire:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfClaim[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfClaim[0].txtOverRidden[0]", "Replace with statement to the effect of:", "Remplacer la valeur du formulaire avec:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfClaim[0].txtOverRidden[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfROA[0].txtPart4[0]", "Route of Administration: ", "Voie d'administraton:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfROA[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfROA[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfUse[0].sfROA[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfDuration[0].lblField[0]", "Duration of Use", "Durée d'utilisation");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfDuration[0].lblField[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfDuration[0].txtPart4[0]", "Duration of Use on ePLA :", "Durée d'utilisation sur la DLMM-e :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfDuration[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfDuration[0].txtOverRidden[0]", "Replace with statement to the effect of :", "Remplacer la valeur du formulaire avec:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfUses[0].sfDuration[0].txtOverRidden[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading4[0].lblHeading[0]", "Recommended Dose", "Dose recommandée");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading4[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading4[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading4[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].txtSubpopulation[0]", "Sub-population", "Sous-population");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].txtSubpopulation[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].txtId[0]", "id", "Id");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].txtId[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfRecommendedDose[0].lblHeading[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"color:#000000;text-decoration:none\"&gt;Recommended Dose&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.6.7185.0\"&gt;&lt;p style=\"color:#000000;text-decoration:none\"&gt;Dose recommandée&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfRecommendedDose[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfRecommendedDose[0].txtPart4[0]", "Recommended Dose:", "Dose recommandée:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfRecommendedDose[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAdditionalInfo[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAdditionalInfo[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAdditionalInfo[0].txtPart4[0]", "Additional Dosage Information:", "Information de posologie supplémentaire:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAdditionalInfo[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfDirection4Use[0].lblDirection4Use[0]", "Directions of Use", "Mode d'emploi");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfDirection4Use[0].lblDirection4Use[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfDirection4Use[0].txtPart4[0]", "Directions of Use on ePLA:", "Mode d'emploi sur la DLMM-e:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfDirection4Use[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfDirection4Use[0].txtOverRidden[0]", "Replace with statement to the effect of:", "Remplacer la valeur du formulaire avec:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfDirection4Use[0].txtOverRidden[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAddDirection4Use[0].txtPart4[0]", "Additional Directions of Use:", "Mode d'emploi supplémentaire:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAddDirection4Use[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAddDirection4Use[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfDoses[0].sfDose[0].sfAddDirection4Use[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].lblHeading[0]", "Risk Information", "Mention des risques" );
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].lblHeading[0]", "", "" );

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfCautions[0].lblFieldName[0]", "Cautions and Warnings", "Précautions et mises en garde");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfCautions[0].lblFieldName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfCautions[0].txtPart4[0]", "Cautions and Warnings on ePLA:", "Précautions et mises en garde sur le eLMM :");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfCautions[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfCautions[0].txtOverRidden[0]", "Replace with statement to the effect of :", "Remplacer la valeur du formulaire avec:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfCautions[0].txtOverRidden[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfContraindications[0].lblFieldName[0]", "Contraindications", "Contre-indications");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfContraindications[0].lblFieldName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfContraindications[0].txtPart4[0]", "Contraindications information on ePLA:", "Information sur les contre-indications sur le eLMM");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfContraindications[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfContraindications[0].txtOverRidden[0]", "Replace with statement to the effect of :", "Remplacer la valeur du formulaire avec:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfContraindications[0].txtOverRidden[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfReactions[0].lblFieldName[0]", "Adverse Reactions", "Réactions indésirables");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfReactions[0].lblFieldName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfReactions[0].txtPart4[0]", "Adverse Reactions Information on ePLA", "Information sur les réactions indésirables sur le eLMM");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfReactions[0].txtPart4[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfReactions[0].txtOverRidden[0]", "Replace with statement to the effect of :", "Remplacer la valeur du formulaire avec:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfRisk[0].sfReactions[0].txtOverRidden[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading5[0].btnAdd[0]", "Add a Storage Condition", "Ajouter une condition d'entreposage");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading5[0].btnAdd[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading5[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading5[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading5[0].lblField[0]","Provided by Applicant","Fourni par le demandeur");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfHeading5[0].lblField[0]","","");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfProvidedByApplicant[0].sfRow[0].ddlRecommendedStorage[0]", "Recommended Storage Conditions:", "Conditions d'entreposage recommandés:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfProvidedByApplicant[0].sfRow[0].ddlRecommendedStorage[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfProvidedByApplicant[0].sfRow[0].btnRemove[0]", "remove", "enlever");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfProvidedByApplicant[0].sfRow[0].btnRemove[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfProvidedByApplicant[0].ddlLotNo[0]", "Select a Lot label :", "Choisissez une étiquette de lot");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfAnyPanel[0].sfContent[0].sfConditionOfUse[0].sfProvidedByApplicant[0].ddlLotNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfHeading[0].lblHeading[0]", "OUTER LABEL TEXT ONLY", "TEXTE DE L'ÉTIQUETTE EXTÉRIEURE");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfHeading[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfHeading[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].lblHeading[0]", "B - Non-medicinal Ingredient", "B - Ingrédient non médicinal");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].txtId[0]", "Id", "Id");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].txtId[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].txtNMINumber[0]", "Non-medicinal Ingredient Number (Reference Only):", "Numéro d'ingrédient non médicinal (Référence seulement):");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].txtNMINumber[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].sfName[0].txtName[0]", "Common Name:", "Non commun:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].sfName[0].txtName[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].sfName[0].txtUnit[0]", "Unit:", "Unité :");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].sfName[0].txtQty[0]", "Quantity:", "Quantité :");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfNMIs[0].sfNMI[0].sfName[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].lblHeading[0]", "Mercury Statement", "Énoncé sur le mercure:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].dplMercury[0]", "Product Contains Mercury", "Produit contient du mercure");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].dplMercury[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].txtMercuryQuantity[0]", "Quantity of Mercury Statement:", "Quantité de l'énoncé sur le mercure:");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].txtMercuryQuantity[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfHeading[0].lblHeading[0]", "SECURITY PACKAGE", "EMBALLAGE DE SÉCURITÉ");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfHeading[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfHeading[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfContent[0].ddlYesNo[0]", "Is the security feature self-evident?", "Le dispositif de sécurité est-il évident par lui-même?");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfContent[0].ddlYesNo[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfContent[0].txtSecurityFeature[0]", "Security Feature", "Dispositif de sûreté");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSecurityPackage[0].sfContent[0].txtSecurityFeature[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfHeading[0].lblHeading[0]", "SPECIALIZED LABELLING  - INNER and/or OUTER", "ÉTIQUETTAGE PARTICULIER - INTÉRIEUR ET(OU) EXTÉRIEUR");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfHeading[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfHeading[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfHeading[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading1[0].lblHeading[0]", "Homeopathic Medicines Labelling", "Étiquetage des médicaments homéopathiques");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading1[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading1[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading1[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtPreservativesUsed[0]", "Preservatives Used", "Agent de conservation utilisé");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtPreservativesUsed[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtMultiDoseContainerWarning[0]", "Multiple-dose Container Seal Warning", "Avertissement de sceau de contenant multidoses");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtMultiDoseContainerWarning[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtAgents[0]", "Preservatives, Isotonicity, Viscosity and Stabilization Agents", "Agents de conservation et de stabilisation, isotonicité et viscosité");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtAgents[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtOticWarning[0]", "Otic Warning", "Avertissement otique");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHomeopathic[0].txtOticWarning[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading2[0].lblHeading[0]", "Pressurized Container", "Contenant sous pression");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading2[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading2[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading2[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].ddlFlame[0]", "Flame Projection Length/Flashback", "Longueur de la projection de la flamme/Retour de la flamme");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].ddlFlame[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].ddlExceptions[0]", "Exceptions - Condition of Container", "Exceptions - condition du contenant");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].ddlExceptions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading3[0].lblHeading[0]", "Cautionary Statements", "Mises en garde");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading3[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading3[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading3[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading3[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading3[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfCautionary[0].txtOutOfReachStatement[0]", "Out of Reach Statement", "Énoncé hors de portée");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfCautionary[0].txtOutOfReachStatement[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfCautionary[0].txtPotentialHarmStatement[0]", "Potential Harm Statement", "Énoncé sur le tort potentiel");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfCautionary[0].txtPotentialHarmStatement[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading4[0].lblHeading[0]", "Organic Product Statements", "Énoncés sur les produits biologiques");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading4[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading4[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading4[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading4[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading4[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfOrganic[0].txtOrganicStatement[0]", "Organic statements", "Énoncés biologiques");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfOrganic[0].txtOrganicStatement[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading5[0].lblHeading[0]", "Irradiated Product Statements", "Énoncés sur les produits irradiés");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading5[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading5[0].ckIncluded[0]", "Include on Label", "Inclure sur l'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading5[0].ckIncluded[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading5[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading5[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading6[0].lblHeading[0]", "Eucalyptus/Camphor Product Statements", "Énoncés sur les produits à base d'eucalyptus et de camphre");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading6[0].lblHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading6[0].ckHide[0]", "Hide", "Cacher");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfHeading6[0].ckHide[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].txtEucalyptusCamphorPCCDirections[0]", "Eucalyptus/Camphor Poison Control Centre Directions", "Indications du centre antipoison pour l'eucalyptus/camphre");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].txtEucalyptusCamphorPCCDirections[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].txtEucalyptusCamphorWarning[0]", "Eucalyptus/Camphor Warning", "Avertissement pour l'eucalyptus/camphre");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].txtEucalyptusCamphorWarning[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].gr[0].dplPressurizedContainer[0]", "Pressurized Container", "Contenant sous pression");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].gr[0].dplPressurizedContainer[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].gr[0].dplPotentialHazardEliminated[0]", "Potential Hazard Eliminated", "Danger éventuel éliminé");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].gr[0].dplPotentialHazardEliminated[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].gr[0].dplEucalyptusOil[0]", "NHP Contains More Than 25% Eucalyptus Oil", "PSN contenant plus de 25% d'huile d'eucalyptus");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].gr[0].dplEucalyptusOil[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].gr[0].dplCamphor[0]", "NHP Contains More Than 2.5% Camphor", "PSN contenant plus de 2.5% de camphre");
setTT("xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].gr[0].dplCamphor[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfHeader[0].Text2[0]", "Label Text", "Texte d'étiquette");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfHeader[0].Text2[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfHeader[0].Text3[0]", "Appropriate text must be in English and in French as per Part 5, Section 87 of the NHP Regulations", "Le texte qui convient doit apparaître en anglais et en français selon la Partie 5, section 87 du Règlement sur les produits de santé naturels.");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfHeader[0].Text3[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfFrontPanel[0].ibiHeading[0]", "PRINCIPAL DISPLAY PANEL", "ESPACE PRINCIPAL AVANT");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfFrontPanel[0].ibiHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfFrontPanel[0].txtNPN[0]", "Natural Product Number (NPN):", "Numéro du produit naturel (NPN) :");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfFrontPanel[0].txtNPN[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].ibiHeading[0]", "ANY PANEL", "TOUT ESPACE");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].ibiHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtImporter[0]", "Importer", "Importateur");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtImporter[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtMI[0]", "Medicinal Ingredients (per dose unit)", "Ingrédients médicinaux (par dose unitaire)");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtUse[0]", "Recommended Use", "Fin recommandée");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtUse[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtDuration[0]", "Duration of Use", "Durée d’utilisation");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtDuration[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtDose[0]", "Recommended Dose", "Dose recommandée");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtDose[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtCautions[0]", "Cautions and Warnings", "Avertissements et énoncés de risque");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtCautions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtContraindications[0]", "Contraindications", "Contre-indications");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtContraindications[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtReactions[0]", "Known Adverse Reactions", "Réactions indésirables connues");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfAnyPanel[0].txtReactions[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfOuterLabel[0].ibiHeading[0]", "OUTER LABEL TEXT ONLY", "TEXTE DE L'ÉTIQUETTE EXTÉRIEURE");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfOuterLabel[0].ibiHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfOuterLabel[0].txtNMI[0]", "Non-Medicinal Ingredients", "Ingrédients non médicinaux");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfOuterLabel[0].txtNMI[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfSecurity[0].ibiHeading[0]", "SECURITY PACKAGE", "EMBALLAGE DE SÉCURITÉ");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSecurity[0].ibiHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].ibiHeading[0]", "SPECIALIZED LABELLING  - INNER and/or OUTER", "ÉTIQUETTAGE PARTICULIER - INTÉRIEUR ET(OU) EXTÉRIEUR");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].ibiHeading[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtHomeopathic[0]", "Homeopathic Medicines Labelling", "Étiquetage des médicaments homéopathiques");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtHomeopathic[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtPressurizedContainer[0]", "Pressurized Container ", "Contenant sous pression");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtPressurizedContainer[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtCautionary[0]", "Cautionary Statements", "Mises en garde");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtCautionary[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtOrganic[0]", "Organic Product Statements", "Énoncés sur les produits biologiques");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtOrganic[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtIrradiated[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p style=\"font-family:'Myriad Pro'\"&gt;Irradiated Product Statements&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p style=\"font-family:'Myriad Pro'\"&gt;Énoncés sur les produits irradiés&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtIrradiated[0]", "", "");

setLblXml("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtEucalyptusCamphor[0]", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p style=\"font-family:'Myriad Pro'\"&gt;Eucalyptus/Camphor Product Statements&lt;/p&gt;&lt;/body&gt;", "&lt;body xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\" xfa:APIVersion=\"2.5.6290.0\"&gt;&lt;p style=\"font-family:'Myriad Pro'\"&gt;Énoncés sur les produits à base d'eucalyptus et de camphre&lt;/p&gt;&lt;/body&gt;");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfSpecialized[0].txtEucalyptusCamphor[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfPrintCloseBttn[0].btclose[0]", "Edit/Close ", "Réviser/Fermer");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfPrintCloseBttn[0].btclose[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfPrintCloseBttn[0].btnCopy[0]", "Copy Label", "Copier étiquette");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfPrintCloseBttn[0].btnCopy[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].sfPrintCloseBttn[0].PrintButton1[0]", "Print Label", "Imprimer étiquette");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].sfPrintCloseBttn[0].PrintButton1[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].sfLabelText[0].txtlabeltext[0]", " Position cursor within Label Text box, then press Ctrl-A to select all text, then Ctrl-C to copy text (Only text, No image)", "Presser Ctrl-A pour sélectionner tout le texte suivi de Ctrl-C pour copier le texte");
setTT("xfa[0].form[0].Pla[0].sfLabelText[0].txtlabeltext[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].persistent[0].nextIngredientID[0]", "Next Ingredient ID", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].nextIngredientID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].persistent[0].aFieldState[0]", "aFieldState", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].aFieldState[0]", "","");

setLbl("xfa[0].form[0].Pla[0].persistent[0].aInstanceVar[0]", "aInstanceVar", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].aInstanceVar[0]", "","");

setLbl("xfa[0].form[0].Pla[0].persistent[0].isInitialized[0]", "isInitialized", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].isInitialized[0]", "","");

setLbl("xfa[0].form[0].Pla[0].persistent[0].NextRecomDoseID[0]", "Recommended Dose ID", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].NextRecomDoseID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].persistent[0].nextNoneMIID[0]", "next NonMIID", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].nextNoneMIID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].persistent[0].nextPotencyID[0]", "Next Potency ID", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].nextPotencyID[0]", "", "");

setLbl("xfa[0].form[0].Pla[0].persistent[0].TestBox[0]", "TestBox", "");
setTT("xfa[0].form[0].Pla[0].persistent[0].TestBox[0]", "","");



///////////////////////////////////////////////////////////
// DDL Control List and Callbacks

function provinceCallback(oNode, oArgs) 
{ 
	var aList = [];
	if(oNode.parent.ddlCountry.rawValue == "CA")
	{
		aList =oEmbeddedList.aProvince;
		oNode.parent.txtPostalCode.myvalidate = "postalCode";
	}
	else if(oNode.parent.ddlCountry.rawValue == "US")
	{
		aList = oEmbeddedList.aState;
		oNode.parent.txtPostalCode.myvalidate = "zipCode";
	}

	var key = oNode.rawValue;
	Pla.script.core.util.xfaUtil.setDDL(oNode, aList, oArgs);
	oNode.value.resolveNode("#text").value = key;
}	

// list to ddl index
var aIndex = {
	"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].ddlProvince[0]": provinceCallback
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionA[0].ddlCountry[0]":oEmbeddedList.aCountry
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlSameAddressAsA[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlProvince[0]": provinceCallback
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlCountry[0]":oEmbeddedList.aCountry
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlSalutation[0]":oEmbeddedList.aSalutation
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].ddlLanguage[0]":oEmbeddedList.aLanguage
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSameAddressAsA[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlProvince[0]": provinceCallback
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlCountry[0]":oEmbeddedList.aCountry
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSalutation[0]":oEmbeddedList.aSalutation
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlLanguage[0]":oEmbeddedList.aLanguage
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlSameAsSeniorOfficial[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionC[0].sfRow[0].ddlContactToReceiveLicence[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlSameAddressAsA[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlProvince[0]":oEmbeddedList.aProvince
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlSalutation[0]":oEmbeddedList.aSalutation
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlLanguage[0]":oEmbeddedList.aLanguage
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionD[0].sfRow[0].ddlSameAsContact[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart1[0].sfSectionE[0].ddlContactToReceiveLicence[0]":oEmbeddedList.aContactToReceiveLicence
	,"xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].ddlTypeOfApplication[0]":oEmbeddedList.aTOA
	,"xfa[0].form[0].Pla[0].sfPart2[0].sfSectionA[0].ddlHypotheticalFormulation[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart2[0].sfSectionG[0].sfRow[0].ddlLetterOfAccess[0]":oEmbeddedList.aLetterOfAccess
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddlCountry[0]":oEmbeddedList.aCountry
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddlProvince[0]": provinceCallback
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63a[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63b[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63c[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63d[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfPart3[0].sfRow[0].ddl63e[0]":oEmbeddedList.aYesNo	
	,"xfa[0].form[0].Pla[0].sfPart4[0].sfHomeopathicMI[0].sfRow1[0].sfHeading[0].ddlHomeopathicPotency[0]": oEmbeddedList.aHomeopathicScale
	,"xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlStandardOrGrade[0]":oEmbeddedList.aGrade
	,"xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfHeading[0].sfOther[0].ddlAdditionalUnit[0]":oEmbeddedList.aAdditionalUnit
	,"xfa[0].form[0].Pla[0].sfPart4[0].sfSectionA1[0].sfRow1[0].sfOrganismSubstanceProcessing[0].sfExtract[0].ddlOriginalMaterial[0]":oEmbeddedList.aOriginalMaterial	
	,"xfa[0].form[0].Pla[0].sfPart4ProductInformation[0].sfRecommendedDose[0].sfRow[0].ddlFrequencyUnit[0]":oEmbeddedList.aRecommendedDoseFrequencyUnit	
	,"xfa[0].form[0].Pla[0].sfSearch[0].sfSearchForm[0].ddlSearchField[0]": provinceCallback
	,"xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlLanguage[0]":oEmbeddedList.aLanguage
	,"xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlProvince[0]": provinceCallback
	,"xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlCountry[0]":oEmbeddedList.aCountry
	,"xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequester[0].ddlSalutation[0]":oEmbeddedList.aSalutation
	,"xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].ddlTypeOfRequest[0]":oEmbeddedList.aTypeOfRequest
	,"xfa[0].form[0].Pla[0].sfChangeRequestForm[0].sfRequest[0].sfHeading[0].ddlDataCategory[0]":oEmbeddedList.aDataCategoryGroup
	,"xfa[0].form[0].Pla[0].sfLTGForm[0].sfOuterLabel[0].sfContent[0].sfMercury[0].dplMercury[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].gr[0].dplPressurizedContainer[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfPressurizedContainer[0].gr[0].dplPotentialHazardEliminated[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].gr[0].dplEucalyptusOil[0]":oEmbeddedList.aYesNo
	,"xfa[0].form[0].Pla[0].sfLTGForm[0].sfSpecialized[0].sfContent[0].sfEucalyptusCamphor[0].gr[0].dplCamphor[0]":oEmbeddedList.aYesNo	
	};
	
///////////////////////////////////////////////////////////
// Control Functions

function showLanguage(newLanguage)
{	
	language = newLanguage;
	//cResourceManager.setCurrentLanguage(newLanguage);
	var oArgs = {};
	
	//cLog.trace("newLanguage: " + newLanguage);
	//cLog.trace("arguments.length: " + arguments.length);
	//cLog.trace("arguments: " + cObjectUtil.asString(arguments, 4));
	if(arguments.length &gt; 1)
	{
		oArgs = arguments[1];
	}
	updateLanguage(Pla, oArgs);		
	updateMPCaptions(Pla);
}

/**
 * Loops through each subForm in the form and call updateLanguage on each of them.
 */
function updateLanguage(oNode)
{
	// this function is disabled
	//return false;
	if(oNode == undefined) return false;
	
	//cLog.trace("oNode1: " + oNode.somExpression);
	//cLog.trace("oNode2: " + cObjectUtil.asString(oNode, 4));
	
	var oArgs = {};
	if(arguments.length &gt; 1)
	{
		oArgs = arguments[1];
	}
		
	for(var i = 0; i &lt; oNode.nodes.length; i++)
	{	
		var oItem = oNode.nodes.item(i)
		
		showCaption(oItem, oArgs);		
		if(oItem.className == "subform" 
		|| oItem.className == "exclGroup"
		|| oItem.className == "subformSet" 
		|| oItem.className == "area")
		{					
			updateLanguage(oItem, oArgs);
			if (i &lt; 15)
			{
				//cLog.trace("oItem2: " + oItem.name);
				//cLog.trace("oItem3: " + oItem.somExpression);
			}
		}
	}
}

/**
 * Loops through each Page in the form and call updateLanguage on each of them.
 */
function updateMPCaptions()
{
	var oContent;
	var numPages = xfa.layout.absPageCount();

	//cLog.trace("numPages: " + numPages);
	for(var i = 0; i &lt;numPages ; i++)
	{
		oContent = xfa.layout.pageContent(i, "pageArea");
//		cLog.trace("oContent.item(0): " + oContent.item(0));
		updateLanguage(oContent.item(0));
	}
}

function showCaption(oNode)
{
	var isInitialized = false;//Pla.script.model.form.isInitialized();
	var doDDL = true;
	var oArgs = {};
	
	if(arguments.length &gt; 1) 
	{
		oArgs = arguments[1];
		isInitialized = oArgs["isInit"];	
	}
	
	if(oNode)
	{
		var nodeSom = oNode.somExpression;
		var mainSom = nodeSom;
		var lang =  getLanguage();
		
		if (Pla.script.core.util.js.string(aLbl[lang][mainSom]) == "")
		{
			mainSom = nodeSom.replace(/\[[0-9]*\]/g, "[0]");
		}						
		
		switch(oNode.className)
		{
			case "field":
				// Tooltip
				if (Pla.script.core.util.js.string(aTT[lang][mainSom]) == "")
				{
					oNode.assist.speak.disable = "0";
				}
				else
				{
					oNode.assist.toolTip.value = aTT[lang][mainSom];
				}
				
				// Caption
				if(oNode.caption.value.resolveNode("#text") != undefined &amp;&amp; aLbl[lang][mainSom] != undefined)
				{
					if(aLbl[lang][mainSom] == "") // avoid adding an asterisk if there is no caption
					{
						oNode.caption.value.resolveNode("#text").value = ""; 				
					}
					else
					{
						var oldcaption = aLbl[lang][mainSom];
						var foundstar = (oldcaption.indexOf(" *") == (oldcaption.length-2));					
						var isRequired = (oNode.mandatory == "error");
						
						if(!isRequired &amp;&amp; foundstar)
						{
							oldcaption = oldcaption.substr(0, oldcaption.length-2);
						}	
						else if(isRequired &amp;&amp; !foundstar &amp;&amp; oldcaption != undefined)
						{
							oldcaption = oldcaption + " *";
						}
						
						if (mainSom != "xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]" &amp;&amp;
							mainSom != "xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtSurname[0]")
						{
							oNode.caption.value.resolveNode("#text").value = oldcaption;
						}
						else
						{
							if (mainSom == "xfa[0].form[0].Pla[0].sfPart1[0].sfSectionB[0].txtSurname[0]")
							{
								oNode.caption.value.resolveNode("#text").value = 
												cResourceManager.get("SURNAME");
							}
							else
							{
								oNode.caption.value.resolveNode("#text").value = 
												cResourceManager.get("english");
							}
						}
						
/*
						if (aLbl[lang][mainSom] == "English")
						{
							cLog.trace("aLbl[" + lang + "][" + mainSom + "] = " + oldcaption);
							cLog.trace("mainSom: " + mainSom);
							cLog.trace("oNode.mandatory: " + oNode.mandatory);
						}
*/
					}
				}
				else if(oNode.caption.value.isPropertySpecified("exData")
				&amp;&amp; oNode.caption.value.exData != undefined &amp;&amp; aLblXml[lang][mainSom] != "")
				{
					try {
						oNode.caption.value.exData.loadXML(aLblXml[lang][mainSom]);			
					} catch (e) {
						Pla.script.core.util.debug.dbg("LblXml Error: " + mainSom)
					}			
				}
				// check to see if it's a DDL, and populate the DDL with it's respective list
				if(doDDL &amp;&amp; oNode.ui.resolveNode("#choiceList") != undefined)
				{								
					if(aIndex[mainSom] != undefined)
					{				
						if(aIndex[mainSom].constructor == Array)
						{												
							var key = oNode.rawValue; // get the key
							Pla.script.core.util.xfaUtil.setDDL(oNode, aIndex[mainSom], {isInit: isInitialized});
							oNode.value.resolveNode("#text").value = key;					
						}
						else if(aIndex[mainSom].constructor == Object)
						{
							var key = oNode.rawValue; // get the key
							Pla.script.core.util.xfaUtil.setDDL(oNode, aIndex[mainSom], {isInit: isInitialized});
							oNode.value.resolveNode("#text").value = key;												
						}
						else if(aIndex[mainSom].constructor == Function)
						{			
							aIndex[mainSom](oNode, {isInit: isInitialized});						
						}
					}
				}
				break;
			case "draw":
				if(oNode.value.resolveNode("#text") != undefined &amp;&amp; aLbl[lang][mainSom] != null)
				{					
					oNode.value.resolveNode("#text").value = aLbl[lang][mainSom];
				}
				else if(oNode.value.exData != undefined &amp;&amp; aLblXml[lang][mainSom] != "" &amp;&amp; aLblXml[lang][mainSom] != undefined)
				{	
					//Pla.sfAttestation.#variables[0].controller
					try {
						oNode.value.exData.loadXML(aLblXml[lang][mainSom]);		
					} catch (e) {
						Pla.script.core.util.debug.dbgdate("LblXml Error: " + mainSom)
					}
			
				}
				break;	
		}
	}
}

function getMsg(key)
{
	var msg = aMsg[getLanguage()][key];

	if(arguments.length &gt; 1)
	{
		if(arguments[1].constructor == Array)
		{
			var aReplace = arguments[1];
			for(var i = 0; i &lt; aReplace.length; i++)
			{
				msg = msg.replace(aReplace[i][0], aReplace[i][1]);
			}
		}		
	}
	
	return msg;
}

function getLbl(key)
{
	var lang = getLanguage();
	if(arguments.length &gt; 1)
	{
		lang = arguments[1];	
	}
	
	var s = aLbl[lang][key];
	if (!s)
	{
		key = key.replace(/\[[0-9]*\]/g, "[0]");
		s = aLbl[lang][key];
	}	

	return s;
}

function getLblXml(key)
{
	var lang = getLanguage();
	if(arguments.length &gt; 1)
	{
		lang = arguments[1];	
	}
	return aLblXml[lang][key];
}

function getTT(key)
{
	var lang = getLanguage();
	if(arguments.length &gt; 1)
	{
		lang = arguments[1];	
	}
	return aTT[lang][key];
}

function useLbl(destkey, srckey)
{
	var en = getLbl(srckey, "en");
	var fr = getLbl(srckey, "fr");
	setLbl(destkey, en, fr); 
}

function useLblXml(destkey, srckey)
{
	var en = getLblXml(srckey, "en");
	var fr = getLblXml(srckey, "fr");
	setLblXml(destkey, en, fr); 
}

function useTT(destkey, srckey)
{
	var en = getTT(srckey, "en");
	var fr = getTT(srckey, "fr");
	setTT(destkey, en, fr); 
}

function messageBox(key)
{
	xfa.host.messageBox(getMsg(key));
}

function setMsg(key, en, fr)
{
	aMsg["en"][key] = en;	
	aMsg["fr"][key] = fr;
}

function setLbl(key, en, fr)
{
	aLbl["en"][key] = en;	
	aLbl["fr"][key] = fr;
}

function setLblXml(key, en, fr)
{
	aLblXml["en"][key] = en;	
	aLblXml["fr"][key] = fr;
}

function setTT(key, en, fr)
{
	aTT["en"][key] = en;	
	aTT["fr"][key] = fr;
}

function getLanguage() 
{ 	
	//return Pla.script.model.form.getLanguage();
	return cResourceManager.getCurrentLanguage();
}

//setLbl("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]", cResourceManager.get("english"), cResourceManager.get("english"));
//setLbl("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]", "English", "English");
//setTT("xfa[0].form[0].Pla[0].sfHeader[0].pageLanguage[0].chkEnglish[0]", cResourceManager.get("english_tip"), cResourceManager.get("english_tip"));
</script>
            <?templateDesigner expand 0?></variables>
         <subform w="100mm" h="50mm" name="config">
            <variables>
               <script contentType="application/x-javascript" name="defaults">
/*******************************************************************************
 * Default values. Over-ride these as required in form-specific configurations.
 */

//imports
var Log = script.core.util.Log;

var content = { //Required to wrap entries
core_version: "2.2",
colourError: "230,125,125", 
colourReadOnly: "245,245,245",
defaultLanguage: "en",

NodeValidator_formatValidator: "script.core.validation.BasicFormatValidator",
Log_logLevel: Log.LEVEL_WARN,
Log_showExceptionDetail: false,
Log_writeToFile: false,

countryNodeName: "ddlCountry", //Used by PostalZipDelegate &amp; ProvinceStateDelegate
postalCodeNodeName: "txtPostalCode", //Used by HandlerUtil
provinceNodeName: "ddlProvince", //Used by HandlerUtil

}

/*Change List
 Version 2.0
 -added version number
 -fixed validation bug for hidden fields
 - added star for tooltips
 
 version 2.1
 Fixed french/ english for the province lists.
 Updated the province list order in french
 updated error_badEmailFormat in french
version 2.1b
French states updated the order alphabeticallly
This version modifies default value for drop lists for PMRA compatibility
 NO_ENTRY_CODE is set to an empty string
*/
</script>
               <?templateDesigner expand 1?></variables>
            <bind match="none"/>
            <?templateDesigner expand 1?></subform>
         <subform w="100mm" h="50mm" name="encode">
            <variables>
               <script contentType="application/x-javascript" name="Base64Encoder">//
/*******************************************************************************
 * A class used to encode and decode byte arrays into Base 64 strings. This is
 * often done to transfer them when the transfer mechanism only supports Strings
 * (e.g. sending them through SOAP or putting them in barcodes).
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Encodes the passed byte array into Base 64.
 * @param byteArray a String that contains the byte array that is to be Base 64
 *		  encoded.
 * @return a String that is properly encoded in Base 64.
 * @throws an UnexpectedDataType Exception if byteArray is undefined, null, or not
 *		   a string.
 */
function encode(byteArray)
{
	cTypeEnforcer.checkString(byteArray, "Base64Encoder", "encode", "byteArray");
	
	var output = "";
	var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
	var i = 0;

	while (i &lt; byteArray.length)
	{
		chr1 = byteArray.charCodeAt(i++);
		chr2 = byteArray.charCodeAt(i++);
		chr3 = byteArray.charCodeAt(i++);

		enc1 = chr1 &gt;&gt; 2;
		enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
		enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6);
		enc4 = chr3 &amp; 63;

		if (isNaN(chr2))
		{
			enc3 = enc4 = 64;
		}
		else if (isNaN(chr3))
		{
			enc4 = 64;
		}

		output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) 
				 + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);

	}
	return output;
}

/**
 * Decodes the passed String from Base 64.
 * @param aString the String that is properly encoded in Base 64.
 * @return a String that contains the byte array that was originally Base 64
 *		   encoded.
 * @throws an UnexpectedDataType Exception if aString is undefined, null, or not
 *		   a string.
 */
function decode(aString)
{
	cTypeEnforcer.checkString(aString, "Base64Encoder", "encode", "aString");

	var output = "";
	var chr1, chr2, chr3;
	var enc1, enc2, enc3, enc4;
	var i = 0;

	aString = aString.replace(/[^A-Za-z0-9\+\/\=]/g, "");
	while (i &lt; input.length)
	{
		enc1 = _keyStr.indexOf(aString.charAt(i++));
		enc2 = _keyStr.indexOf(aString.charAt(i++));
		enc3 = _keyStr.indexOf(aString.charAt(i++));
		enc4 = _keyStr.indexOf(aString.charAt(i++));

		chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
		chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
		chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;

		output = output + String.fromCharCode(chr1);

		if (enc3 != 64)
		{
			output = output + String.fromCharCode(chr2);
		}
		if (enc4 != 64)
		{
			output = output + String.fromCharCode(chr3);
		}
	}
	return output;
}

</script>
               <script contentType="application/x-javascript" name="Utf8Encoder">//
/*******************************************************************************
 * A class used to encode Strings into UTF-8. This is used when they are going
 * to be externalized (e.g. put into a zip archive).
 *
 * version: 812.316  
 * original by: Webtoolkit.info (http://www.webtoolkit.info/)  
 * discuss at: http://phpjs.org/functions/utf8_encode  
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Encodes the passed String into UTF-8.
 * @param aString the String to be encoded into UTF-8.
 * @return a String that is properly encoded. Note that this should be treated
 *		   as a byte array rather than a string, since the encoding no longer
 *		   alighns with this environment.
 * @throws an UnexpectedDataType Exception if aString is undefined, null, or not
 *		   a string.
 */
function encode(aString)
{
	cTypeEnforcer.checkString(aString, "Utf8Encoder", "encode", "aString");

	var end = 0;  
	var utftext = "";  
	var start = 0;  
		
	aString = (aString + '').replace(/\r\n/g, "\n").replace(/\r/g, "\n");  
	for (var n = 0; n &lt; aString.length; n++)
	{  
		var c1 = aString.charCodeAt(n);  
		var enc = null;  
		
		if (c1 &lt; 128)
		{  
			end++;  
		}
		else if((c1 &gt; 127) &amp;&amp; (c1 &lt; 2048))
		{  
			enc = String.fromCharCode((c1 &gt;&gt; 6) | 192) 
				  + String.fromCharCode((c1 &amp; 63) | 128);
		}
		else
		{  
			enc = String.fromCharCode((c1 &gt;&gt; 12) | 224) 
				  + String.fromCharCode(((c1 &gt;&gt; 6) &amp; 63) | 128) 
				  + String.fromCharCode((c1 &amp; 63) | 128);  
		}  
		if (enc != null)
		{  
			if (end &gt; start)
			{  
				utftext += aString.substring(start, end);  
			}  
			utftext += enc;  
			start = end = n+1;  
		}  
	}  
		
	if (end &gt; start) {  
		utftext += aString.substring(start, aString.length);  
	}  
	return utftext;
}
</script>
               <?templateDesigner expand 0?></variables>
            <bind match="none"/>
            <?templateDesigner expand 0?></subform>
         <subform w="100mm" h="50mm" name="event">
            <variables>
               <script contentType="application/x-javascript" name="ActionEvent">//
/*******************************************************************************
 * A semantic event which indicates that a component-defined action occured.
 * This high-level event is generated by a component (such as a Button) when the
 * component-specific action occurs (such as being pressed). The event is passed
 * to every every ActionListener object that needs to be aware of it.
 *
 * The object that implements the ActionListener interface gets this ActionEvent
 * when the event occurs. The listener is therefore spared the details of
 * processing individual mouse movements and mouse clicks, and can instead
 * process a "meaningful" (semantic) event like "button pressed". 
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new ActionEvent. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * @param command a String that specifies a command associated with the event.
 * @param sourceNode the Node that originated the event.
 * @param value (optional) the value, if any, that is pertinent this event. Note
 *		  that the data type is unspecified, since it is dependant on the
 *		  context of the event.
 * @return the new ActionEvent instance
 */
function createInstance(command, sourceNode, value)
{
	return new ActionEventClass(command, sourceNode, value);
}

/**
 * Class implementation
 */
function ActionEventClass(command, sourceNode, value)
{
	this.className = "ActionEvent";

	cTypeEnforcer.checkString(command, "ActionEvent","constructor", "command");
	cTypeEnforcer.checkNode(sourceNode, "ActionEvent","constructor", "sourceNode");

	this.command = command;
	this.source = sourceNode;
	this.value = value;

	/**
	 * Gets the command associated with this event.
	 * @return a String that specifies a command associated with this event.
	 */
    this.getActionCommand = function()
    {
    	return this.command;
	}

	/**
	 * Gets the Node that originated this event.
	 * @return the Node that originated this event.
	 */
    this.getSource = function()
    {
    	return this.source;
	}

	/**
	 * Gets the value, if any, that is pertinent this event. For example, if
	 * this event indicates that a field's value has changed, this would be its
	 * new value.
	 * @return the value that is pertinent this event. Undefined if this isn't
	 *		   applicable. Note that the data type is unspecified, since it is
	 *		   dependant on the context of the event.
	 */
    this.getValue = function()
    {
    	return this.value;
	}

    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    buffer += "command= " + this.command;
	    if (this.source != undefined)
	    {
	    	buffer += ", source.somExpression= " + this.source.somExpression;
	    }
	    else
	    {
	    	buffer += ", source= undefined";
	    }
	    buffer += ", value= " + this.value;
		buffer += "]";
		return buffer;
	}
}


</script>
               <script contentType="application/x-javascript" name="ActionListenerInterface">//
/*******************************************************************************
 * This defines the listener Interface for receiving action events. The class
 * that is interested in processing an action event implements this interface,
 * and when the action event occurs, that object's actionPerformed method is
 * invoked.
 */

var interfaceName = "ActionListenerInterface"; //Required for all interfaces

/**
 * Invoked when a UI action occurs.
 * @param anEvent the ActionEvent instance that represents an action that has
 *		  occurred in the User Interface.
 */
function actionPerformed(anEvent){}


</script>
               <?templateDesigner expand 0?></variables>
            <bind match="none"/>
            <?templateDesigner expand 0?></subform>
         <subform w="100mm" h="50mm" name="lang">
            <variables>
               <script contentType="application/x-javascript" name="LocalizedException">//
/*******************************************************************************
 * A LocalizedException is an Exception whose message is looked up using
 * ResourceManager. These are used when the exception message is likely to be
 * displayed to a user. Note that, since over-riding toString() is not supported
 * and the console uses toString(), these are actually using Adobe's Error class
 * which has implemented toString().
 */

//imports
var cException = script.core.util.Exception;
var cResourceManager = script.core.lang.ResourceManager;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new LocalizedException. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * @param key the String whose associated value is the message (see
 *		  ResourceManager).
 * @param additionalValues (optional) these additional parameters are used to
 * 		  support the dynamic replacement of placeholders in a retrieved String
 *		  message. Placeholders follow the syntax "{#}", where # is the 1-based
 *		  index of the additional arguments. Any number of additional arguments
 *		  can be passed. Eg. get("test", "this", "out") will retrieve the
 *		  message with the key "test", then replace all "{1}"s with "this", and
 *		  replace all "{2}"s with "out".
 * @return the new LocalizedException instance
 */
function createInstance(key)
{
	cTypeEnforcer.checkString(key, "LocalizedException", "constructor",
							  "key");

	//This runs the ResourceManager's "get" function object by calling its apply
	//function so that it can pass in the arguments passed to this function
	//directly (it uses the same arguments in the same way).
	var message = cResourceManager.get.apply(cResourceManager, arguments);
	var anError = new Error(message);

	anError.className = "LocalizedException";
	anError.name = "LocalizedException";
	anError.key = key;

	//Add its custom methods

    /**
     * Gets the exception's localized message, which is typically the reason for
     * the failure.
     * @return a String that contains the message that describes the problem.
     */
    anError.getMessage = function ()
	{
		return this.message;
	}
        
    /**
     * Gets the key used to look up the message in the ResourceManager.
     * @return a string that contains the key used to look up the message.
     */    
	anError.getKey = function()
	{
		return this.key;
	}

    /**
     * Describes this object. This is implemented to get the same result as
     * its toString(), which is implemented by Error.
     * @return the description of this exception.
     */
    anError.asString = function ()
	{
		return this.toString();
	}

	return anError;
}

</script>
               <script contentType="application/x-javascript" name="ResourceManager">//
/*******************************************************************************
 * A class that manages the form's resource files which contains labels and
 * messages in the language specified. It loads all JavaScript classes in
 * "resources" packages (i.e. treats them as resrouce files). 
 * This creates a master resource file from all of these entries, so
 * individual entries can be over-ridden by those in files that are subsequently
 * loaded. Loading follows the ordering they are in the forms - proceding down
 * the first branches to the first leaves before proceding to the next leaves
 * and then the next branches.
 *
 * Resource entry values are usually Strings.
 */

//imports
var cConfigurationManager = script.core.util.ConfigurationManager;
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cMap = script.core.util.Map;
var cNodeUtil = script.core.util.NodeUtil;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;
var cStringUtil = script.core.util.StringUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var LANG_ENGLISH = "en";
var LANG_FRENCH = "fr";
var _EXT_ENGLISH = "_" + LANG_ENGLISH;
var _EXT_FRENCH = "_" + LANG_FRENCH;

var prefLanguage = null; // Prefered Language
var content = null; //Map
var pickLists = null; //Map

/**
 * Gets whether there is an entry for the specified key.
 * @param key the key whose presence in this configuration is to be tested.
 * @return a boolean - true if this configuration contains an entry for the
 *		   specified key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function containsKey(key)
{
	try
	{
		return _getContent().containsKey(key);
	}
	catch(exception)
	{
		throw cException.createInstance("ResourceManager.containsKey() "
			  + "encountered a problem: " + exception);
	}
}

/**
 * Gets the value for the passed key. Returns string $key$ if the resource file
 * doesn't contain an entry for this key.
 * @param key the key whose associated value is to be returned.
 * @param additionalValues (optional) these additional parameters are used to
 * 		  support the dynamic replacement of placeholders in a retrieved String
 *		  message. Placeholders follow the syntax "{#}", where # is the 1-based
 *		  index of the additional arguments. This is only appropriate if the
 *		  return value is a String. Any number of additional arguments can be
 *		  passed. Eg. get("test", "this", "out") will retrieve the message with
 * 		  the key "test", replace all "{1}"s with "this", and replace all "{2}"s
 *		  with "out".
 * @return the value for the specified key, or "$key$" if the resource files
 *		   contain no entry for this key. Values are usually, but not limited
 *		   to, Strings.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function get(key)
{
	var value;

	try
	{
		if (containsKey(key))
		{
			value = _getContent().get(key);

			if(arguments.length &gt; 1)
			{
				for (var i = 1; i &lt; arguments.length; i++)
				{
					var temp = "\\{" + i + "\\}";
					var re = new RegExp(temp, "g");
					value = value.replace(re, arguments[i]);
				}
			}
		}
		else
		{
			cLog.warn("ResourceManager.get(key) encountered a problem: '" + 
						key + "' is not defined in any resource file.");
			value = "$" + key + "$";
		}
		
	}
	catch(exception)
	{
		throw cException.createInstance("ResourceManager.get() "
			  + "encountered a problem: " + exception.getMessage(),
	   		  exception.getType());
	}
	
	return value;
}

/**
 * Gets the current language setting. If null, it is automatically set to
 * the default language in the config file and then loads the resources.
 * @return the current language setting.
 */
function getCurrentLanguage()
{	
	if (prefLanguage == null)
	{
		prefLanguage = cConfigurationManager.get("defaultLanguage");
	}
	
	return prefLanguage;
}

/**
 * Gets the pick list for the passed key. Returns null if the resource
 * files don't contain an entry for this key. This is a String of the format
 * "displayValue1, code1, displayValue2, code2, displayValue3, key3...".
 * @param key the key whose associated pick list is to be returned.
 * @return the pick list for the specified key, or null if the resource
 *		   files contain no entry for this key.
 * @throws an UnexpectedDataType Exception if key is undefined or null, or if
 *		   the pick list is not properly defined in the resource entry.
 */
function getPickList(key)
{
	if (key == null)
	{
		throw cException.createInstance(
			  "ResourceManager.getPickList(): key cannot be undefined or null",
			  "UnexpectedDataType");
	}

	if (!_getPickLists().containsKey(key))
	{
		if (containsKey(key))
		{
			_getPickLists().put(key, _convertPickList(key, get(key)));
		}
		else
		{
			cLog.warn("ResourceManager.getPickList(key) encountered a problem: '" 
					  + key + "' is not defined in any resource file.");
		}
	}
		
	return _getPickLists().get(key);
}

/**
 * Sets the language which will be in use for the UI presentation.
 * @param lang the language to be set. This should be one of the class
 *		  constants.
 * @return true if the language actually changed from its previous value.
 * @throws an UnexpectedLanguage Exception if lang not one of the constants.
 */
function setCurrentLanguage(lang)
{
	if (lang == LANG_ENGLISH || lang == LANG_FRENCH)
	{
		if (prefLanguage != lang)
		{
			prefLanguage = lang;
			content = null; //So it will lazy load
			pickLists = null; //So it will lazy load
			return true;
		}
	}
	else
	{
		throw cException.createInstance("ResourceManager.setCurrentLanguage() " + 
			  "encountered a problem: '" + lang + "' is not a valid language.",
	   		  "UnexpectedLanguage");
	}
	return false;
}

//===== PRIVATE ================================================================

/**
 * Converts a pick list from the way it is represented in a resource file to the
 * way that it is expected by consumers. This expects it to start out as an
 * Array of entries in display order. Each entry is an Array that contains 2
 * Strings - the code and the display value.
 * @param key the key whose associated pick list is to be converted.
 * @param rawPickList an Array that contains the pick list as defined in the
 *		  resource file.
 * @return the pick list as a String of the format "displayValue1,code1,
 *		   displayValue2,code2,displayValue3,key3...".
 * @throws an UnexpectedDataType Exception if the pick list is not properly
 *		   defined in the resource entry.
 */
function _convertPickList(key, rawPickList)
{
	if (!cTypeChecker.isArray(rawPickList))
	{
		throw cException.createInstance("ResourceManager._convertPickList() "
			  + "encountered a problem: '" + key 
			  + "' does not contain an Array.",
	   		  "UnexpectedDataType");
	}

	var entry;
	var pickListString = "";
	for (var i=0; i &lt; rawPickList.length; i++)
	{
		entry = rawPickList[i];
		if (!cTypeChecker.isArray(entry) || entry.length != 2
			|| !cTypeChecker.isString(entry[0]) 
			|| !cTypeChecker.isString(entry[1]))
		{
			throw cException.createInstance("ResourceManager._convertPickList() "
				  + "encountered a problem: '" + key 
				  + "' does not contain a properly formed pick list definition.",
		   		  "UnexpectedDataType");
		}
		if (i &gt; 0)
		{
			pickListString += ",";
		}
		pickListString += cStringUtil.cleanPickListEntry(entry[1]);
		pickListString += "," + cStringUtil.cleanPickListEntry(entry[0]);
	}
	
	return pickListString;
}

/**
 * Gets the content map that stores all of the resource files. This is lazy
 * loaded.
 * @return the content map that stores all of the resource files.
 */
function _getContent()
{
	if (content == null)
	{
		_load();
	}
	return content;
}

/**
 * Gets the map that stores all of the pickLists. This is lazy loaded.
 * @return the map that stores all of the pickLists.
 */
function _getPickLists()
{
	if (pickLists == null)
	{
		_load();
	}
	return pickLists;
}

/**
 * Checks if the passed resource script is in the same language set in the config.
 * @param aLanguageFileNode the resource script to be checked.
 * @return true if the resource script is in the same language set in the config,
 * 		   false otherwise.
 */
function _isCurrentLanguage(aResourceFileNode)
{
	var aResourceFileName = aResourceFileNode.name;	
	var resNameLeng = aResourceFileName.length;

	return (aResourceFileName.substring(resNameLeng - 2, resNameLeng) 
			== getCurrentLanguage());
}

/**
 * Check if the passed resource file has its opposite language file.
 * @param aLanguageFileNode the resource script to be checked.
 * @param lastFileNode the resource script to be checked against with.
 * @return true if they are in opposite language, false otherwise.
 */
function _isOppositeLanguage(aLanguageFileNode, lastFileNode)
{
	var aLanguageFileName = aLanguageFileNode.name;
	var lastFileName = lastFileNode.name;
	var fileNameLeng = aLanguageFileName.length;

	if (aLanguageFileName.substring(fileNameLeng - 3, fileNameLeng) == "_fr")
	{
		return (_stripLanguageExtension(aLanguageFileNode) + "_en" == lastFileName);
	}
	else (aLanguageFileName.substring(fileNameLeng - 3, fileNameLeng) == "_en")
	{
		return (_stripLanguageExtension(aLanguageFileNode) + "_fr" == lastFileName);
	}
}

/**
 * Checks if the passed resource script is in the valid language.
 * It logs a warning if the resource script passed is not ending with "_en" / "_fr".
 * @param aLanguageFileNode the node to be checked.
 * @return true if the resource script ends with "_en" / "_fr", false otherwise.
 */
function _isValidLanguage(aLanguageFileNode)
{
	var aLanguageFileName = aLanguageFileNode.name;
	var nameLeng = aLanguageFileName.length;
	var aFileName;
	
	if (aLanguageFileName.substring(nameLeng - 3, nameLeng) == _EXT_ENGLISH ||
		aLanguageFileName.substring(nameLeng - 3, nameLeng) == _EXT_FRENCH)
	{
		return true;
	}
	
	cLog.warn("Resource script '" 
				+ cStringUtil.formatSomExpression(aLanguageFileNode.somExpression) 
				+ "' is not a valid resrouce script.");
	return false;
}

/**
 * Initializes the content Map by loading all JavaScript classes that are
 * emulating resource files. These are in "resources" script packages
 * (subforms) scattered through the code base.
 * It logs a warning when the resource script is missing its matched script
 * in the opposite language and load the equivalent resource script in language
 * available.
 * @para scriptPackage (optional) name of a specific script package to be loaded
 *		 Load "resources" script package as default if none is assigned.
 */
function _load(scriptPackage)
{
	var startTime = new Date().getTime();
	var lastScript = null;
	var resourcePackages;
	var packageName;
	var scripts;
	
	content = cMap.createInstance();
	pickLists = cMap.createInstance();

	if (scriptPackage != undefined)
	{
		packageName = scriptPackage;
	}
	else
	{
		packageName = "resources";
	}
	
	resourcePackages = cNodeUtil.getScriptPackages(packageName);

	// Loop thru individual module resrouces
	for (var i=0; i &lt; resourcePackages.length; i++)
	{
		scripts = cNodeUtil.getScripts(resourcePackages[i]);
		cNodeUtil.sortNodeArray(scripts);		

		// Loop thru individual resource files
		for (var j=0; j &lt; scripts.length; j++)
		{
			if(_isValidLanguage(scripts[j]))
			{
				if (_isCurrentLanguage(scripts[j])){
					_loadScript(scripts[j]);
				}
				
				if(lastScript == null)
				{
					lastScript = scripts[j];
				}
				else
				{
					if(_isOppositeLanguage(scripts[j], lastScript))
					{
						lastScript = null;
					}
					else
					{
						cLog.warn("Resource script '" 
						  + cStringUtil.formatSomExpression(lastScript.somExpression) 
						  + "' does not have its opposite matching resource file.");
						_loadScript(lastScript);
						lastScript = scripts[j];
					}
				}
			}
		}
	}

	if (lastScript != null)
	{
		cLog.warn("Resource script '" 
					+ cStringUtil.formatSomExpression(lastScript.somExpression) 
					+ "' does not have its opposite matching resource file");
					_loadScript(lastScript);
		lastScript = null;
	}
		
	cLog.info(packageName + " " + getCurrentLanguage() + " package loaded with "
			  + content.size() + " entries in " 
			  + (new Date().getTime() - startTime) + "ms");	
}

/**
 * Loads a specific JavaScript class that is emulating a resource file.
 * @param aScript the JavaScript class that is emulating the file.
 * @throws an UnexpectedDataType Exception if aScript is not an Adobe script
 *		   Object.
 * @throws an InvalidResourceScript Exception if aScript does not contain a
 *		   content variable.
 */
function _loadScript(aScript)
{
	cTypeEnforcer.checkSpecificCustomObject(aScript, "ResourceManager",
				  "_loadScript", "aScript", "script");

	if (aScript.content != null)
	{
	    content.putAll(cObjectUtil.getProperties(aScript.content));
    }
    else
    {
    	throw cException.createInstance("Resource script '" 
    		  + StringUtil.formatSomExpression(aScript.somExpression) 
    		  + "' does not contain a content variable",
    		  "InvalidResourceScript");
    }
}

/**
 * Strips off the language extension on the passed resource script.
 * @param aLanguageFileNode the resource script to be stripped.
 * @return the resource script name without language extension.
 */
function _stripLanguageExtension(aLanguageFileNode)
{
	var aLanguageFileName = aLanguageFileNode.name;
	var nameLeng = aLanguageFileName.length;
	
	return aLanguageFileName.substring(0, nameLeng - 3);
}
</script>
               <?templateDesigner expand 0?></variables>
            <bind match="none"/>
            <?templateDesigner expand 0?></subform>
         <subform w="100mm" h="50mm" name="model">
            <variables>
               <script contentType="application/x-javascript" name="ChangeManager">//
/*******************************************************************************
 * An object used to manage changes to attributes in a model Object.
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new ChangeManager. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * @return the new ChangeManager instance
 */
function createInstance()
{
	return new ChangeManagerClass();
}

/**
 * Class implementation
 */
function ChangeManagerClass()
{
	this.className = "ChangeManager";

	this.changedFields = {};
		
	/**
	 * Gets whether any changes have been registered with this manager.
     * @return a boolean -true if any changes are currently registered with
     *		   this manager.
	 */
    this.isChanged = function()
    {
	    for (var prop in this.changedFields)
	    {
	    	return true;
	    }    	
		return false;
	}
		
	/**
	 * Gets whether any changes have been registered for the field with the
	 * passed name.
	 * @param aFieldName a String that contains the name of the field in
	 *		  question. These are written in camel case where the first letter
	 *		  is lower cased (eg. "firstName");
	 * @return a boolean -true if any changes are currently registered for
	 *		   the field with the passed name.
	 * @throws an UnexpectedDataType Exception if aFieldName is undefined,
	 *		   null, or isn't a String.
	 */
    this.isFieldChanged = function(aFieldName)
    {
    	cTypeEnforcer.checkString(aFieldName, "ChangeManager", "isFieldChanged",
    							  "aFieldName");
		return (this.changedFields[aFieldName] != undefined);
	}
		
	/**
	 * Registers a field as having changed.
	 * @param aFieldName a String that contains the name of the field in
	 *		  question. These are written in camel case where the first letter
	 *		  is lower cased (eg. "firstName");
	 * @throws an UnexpectedDataType Exception if aFieldName is undefined,
	 *		   null, or isn't a String.
	 */
    this.registerFieldChange = function(aFieldName)
    {
    	cTypeEnforcer.checkString(aFieldName, "ChangeManager",
    							  "registerFieldChange", "aFieldName");
		this.changedFields[aFieldName] = true;
	}
		
	/**
	 * Clears all of the changes that have been registered with this manager.
	 */
    this.reset = function()
    {
    	this.changedFields = {};
	}
		
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		var isFirst = true;
		
	    for (var prop in this.changedFields)
	    {
    		if (isFirst)
    		{
				isFirst = false;
    		}
    		else
    		{
				buffer += ", ";
    		}
			buffer += prop;
	    }    	
		buffer += "]";
		return buffer;
	}
}

</script>
               <script contentType="application/x-javascript" name="CodeableInterface">//
/*******************************************************************************
 * This interface is implemented by model objects that need to be compared to 
 * Adobe node object. The methods defined here will allow the model objects 
 * that implement them to be uniquely identified. Adobe nodes that are bound
 * to model objects that implement this interface should have an attribute named
 * hdnCode. When binding an Adobe node with a model object make sure to set the 
 * value of getCode to the hdnCode attribute for the comparison to work.
 */

//Required for all interfaces
var interfaceName = "CodeableInterface"; 
//Constant that must be used by implementing class when creating a dummy/empty entry.
var NO_ENTRY_CODE = " "; 
/**
 * Gets the objects unique identifier code. 
 * @return a String that contains this objects unique code.
 */
function getItemCode(){}

</script>
               <script contentType="application/x-javascript" name="CodeSource">//
/*******************************************************************************
 * An object that provides unique codes to objects that require them. Typcally
 * used by implementors of CodeableInterface or ListItemInterface when they
 * don't already contain a unique code.
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

var nextCode = 0;

/**
 * Gets the next available unique code.
 * @return a String that contains the next available unique code.
 */
function getNextCode()
{
	return String(nextCode++);
}


/**
 * Sets the last used unique code to the passed value if it is larger than the
 * current one. This object uses a counter as a source of codes. The counter
 * will always start at 0, so reopening a saved form may cause it to reissue
 * existing codes. This can be called with the existing codes as part of the
 * form initialization to increase the starting point to be above them.
 * @param aNumber the value of an existing code.
 * @throws an UnexpectedDataType Exception if aNumber is undefined, null, or
 *		   doesn't contain a valid number.
 */
function resetLastCode(aNumber)
{
	aNumber = cTypeEnforcer.checkNumber(aNumber, "CodeSource", "resetLastCode",
										"aNumber");
						  
	if (aNumber &gt; nextCode)
	{
		nextCode = aNumber;
	}
}
</script>
               <script contentType="application/x-javascript" name="EqualityComparableInterface">//
/*******************************************************************************
 * This defines an Interface that is implemented by Objects that need to have a
 * custom way of testing their equality.
 */

var interfaceName = "EqualityComparableInterface"; //Required for all interfaces

/**
 * Gets whether this object is equal to the one passed in. This should give the
 * same result as comparing their equality keys.
 * @param obj the object to be compared.
 * @return a Boolean -true if this object is equal to obj.
 */
function equals(obj){}

/**
 * Gets a String key that can be used to externally compare this object to
 * another for equality. Sometimes that is a more efficient option than to have
 * the objects compare themselves (e.g. this is used by Sets).
 * @return a String that contains the representation of this object suitable for
 *		   equality comparison to one generated by another object.
 */
function getEqualityKey(){}
</script>
               <script contentType="application/x-javascript" name="FormNode">//
/*******************************************************************************
 * An object that represents nodes in this XFA form. These may define a tree
 * structure, where a base node with an absolute SOM expression can contain
 * child nodes with SOM expressions relative to the parent, and they themselves
 * can contain child nodes, etc.
 *
 * A node that has no children is an endpoint of interest (e.g. a title that
 * must be internationalized).
 *
 * A node with children is a node with a number of potential instances (e.g. a
 * subform). In this way, we can create a structure that lets us anticipate
 * where nodes may have multiple instances, each with the same endpoints of
 * interest.
 *
 * These are retrieved from FormNodeManager, which uses FormNodeFactory to
 * create them.
 */

//imports
var cConfigurationManager = script.core.util.ConfigurationManager;
var cException = script.core.util.Exception;
var cNodeValidator = script.core.validation.NodeValidator;
var cFormNodeDelegateInterface = script.core.model.delegate.FormNodeDelegateInterface;
var cInstanceManagerUtil = script.core.util.InstanceManagerUtil;
var cLog = script.core.util.Log;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;
var cStringUtil = script.core.util.StringUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;
var cUiUtil = script.core.util.UiUtil; 
var cValidationFailure = script.core.validation.ValidationFailure;

/**
 * Gets a new FormNode. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * Note that this is only intended for use by FormNodeFactory. All instances
 * should be created by that class. As a result, no type checking is done here-
 * this relies on the factory to create valid instances.
 * @param key a String that contains the key that uniquely identifies this
 *		  FormNode.
 * @return the new FormNode instance
 */
function createInstance(key)
{
	return new FormNodeClass(key);
}

/**
 * Class implementation
 */
function FormNodeClass(key)
{
	cTypeEnforcer.checkString(key, "FormNode", "constructor", "key", true);

	this.className = "FormNode";

	this.childNodes = new Array();
	this.defaultValueKey = null; //String (resource bundle key)
	this.delegate = null; //FormNodeDelegate
	this.fieldNumber = null; //String, note this will not work for RichText Labels***
	this.formatType = null; //String
	this.key = key; //String
	this.labelKey = null; //String (resource bundle key)
	this.mandatory = null; //Boolean
	this.parentNode = null; //FormNode
	this.parentNodeKey = null; //String (only populated during loading)
	this.pickListKey = null; //String
	this.somExpression = null; //String
	this.toolTipKey = null; //String (resource bundle key)
	this.validatedSeparately = false;
		
	/**
	 * Adds a FormNode to the Array of this node's direct descendants.
	 * @param aFormNode the FormNode to add to the Array of children.
	 * @throws an UnexpectedDataType Exception if aFormNode is undefined, null,
	 *		   or isn't a FormNode.
	 */
    this.addChildNode = function(aFormNode)
    {
    	cTypeEnforcer.checkSpecificCustomObject(aFormNode, "FormNode",
    				  "addChildNode", "aFormNode", "FormNode");
		this.childNodes.push(aFormNode);
	}
		
	/**
	 * Gets an Array of the FormNodes that are direct descendants of this node.
	 * @return an Array of FormNodes that includes this node's children. An
	 *		   empty Array if there aren't any.
	 */
    this.getChildren = function()
    {
		return this.childNodes;
	}
			
	/**
	 * Gets whether this node has child FormNodes. If so, this is a parent node
	 * that can have multiple instances (e.g. a subform).
	 * @return a boolean that is true if this has child FormNodes.
	 */
    this.hasChildren = function()
    {
		return this.childNodes.length &gt; 0;
	}
		
	/**
	 * Gets this node's default value, which is an internationalized value.
	 * @param aNode the Adobe Node instance who's default value is required.
	 *		  This is not used by this implementation, but may be required by
	 *		  a delegate if one is present.
	 * @return a String that contains the internationalized default value for
	 *		   the passed Node. Undefined if this is not applicable.
	 */
    this.getDefaultValue = function(aNode)
    {
    	if (this.defaultValueKey != null)
    	{
    		return cResourceManager.get(this.defaultValueKey);
    	}
    	if (this.hasDelegate())
    	{
    		return this.delegate.getDefaultValue(aNode);
    	}
    	return null;
	}
		
	/**
	 * Gets the key to this node's default value. This is used to retrieve the
	 * internationalized value from the ResourceManager or to select the
	 * correct value in a coded pickList.
	 * @return a String that contains the key to this node's default value.
	 *		   Undefined if this is not applicable.
	 */
    this.getDefaultValueKey = function()
    {
    	return this.defaultValueKey;
	}
		
	/**
	 * Sets the key to this node's default value. This is used to retrieve the
	 * internationalized value from the ResourceManager or to select the
	 * correct value in a pickList.
	 * Used by the FormNodeFactory when initializing this Object.
	 * @param aString a String that contains the key to this node's default
	 *		  value.
	 */
    this.setDefaultValueKey = function(aString)
    {
		this.defaultValueKey = aString;
	}
		
	/**
	 * Gets the delegate that is used to process requests about the
	 * characteristics of this node, if any.
	 * @return an Object that implements the FormNodeDelegate interface or null
	 *		   if there isn't any installed into tihs FormNode.
	 */
    this.getDelegate = function(aFormNodeDelegate)
    {
		return this.delegate;
	}

	/**
	 * Gets whether this node has a delegate that is being used to process
	 * about the characteristics of this node.
	 * @return a boolean that is true if this has a delegate.
	 */
    this.hasDelegate = function()
    {
		return this.delegate != null;
	}
		
	/**
	 * Sets the delegate that is used to process requests about the
	 * characteristics of this node.
	 * Used by the FormNodeFactory when initializing this Object.
	 * @param aFormNodeDelegate an Object that implements the FormNodeDelegate
	 *		  interface.
	 * @throws an UnexpectedDataType Exception if this was not passed an Object
	 *		   that implements the FormNodeDelegateInterface.
	 */
    this.setDelegate = function(aFormNodeDelegate)
    {
    	cTypeEnforcer.checkInterface(aFormNodeDelegate, "FormNode",
    		"setDelegate", "aFormNodeDelegate", cFormNodeDelegateInterface);

		this.delegate = aFormNodeDelegate;
		this.delegate.setFormNode(this);
	}
		
	/**
	 * Gets the field number of this node in the form. When populated, this is
	 * displayed as part of the field's label in the UI.
	 * @return a String that contains the number of this field node in the UI.
	 *		   Null if this is not applicable.
	 */
    this.getFieldNumber = function()
    {
		return this.fieldNumber;
	}
		
	/**
	 * Sets the field number of this node in the form. When populated, this is
	 * displayed as part of the field's label in the UI.
	 * @param aString a String that contains the number of this field node in
	 *		  the UI. Null if this is not applicable.
	 */
    this.setFieldNumber = function(aString)
    {
		this.fieldNumber = aString;
	}
		
	/**
	 * Gets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * @param aNode the Adobe Node instance who's value must conform to a 
	 *		  specific format. This is not used by this implementation, but may
	 *		  be required by a delegate if one is present.
	 * @return a String that contains the type of format validation to be
	 *		   applied to data entered into this node in the UI. These must be
	 *		   types that are supported by the currently installed 
	 *		   FormatValidator. Null if this is not applicable.
	 */
    this.getFormatType = function(aNode)
    {
    	if (this.formatType != null)
    	{
			return this.formatType;
    	}
    	if (this.hasDelegate())
    	{
    		return this.delegate.getFormatType(aNode);
    	}
		return null;
	}
		
	/**
	 * Sets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * Used by the FormNodeFactory when initializing this Object.
	 * @param aString a String that contains the type of format validation to
	 *		  be applied to data entered into this node in the UI. These must
	 *		  be types that are supported by the currently installed 
	 *		  FormatValidator. Null if this is not applicable.
	 */
    this.setFormatType = function(aString)
    {
		this.formatType = aString;
	}
		
	/**
	 * Gets the full SOM expression (path) to the XFA node that this
	 * represents. If this is a child node, this is prepends the paths of its
	 * parents.
	 * @return a String that contains the SOM expression (path) to the XFA node
	 *		   that this represents.
	 */
    this.getFullSomExpression = function()
    {
    	if (this.hasParent())
    	{
    		return this.getParentNode().getFullSomExpression() + "." 
    			   + this.somExpression;
    	}
		return this.somExpression;
	}
	
	/**
	 * Gets the unique key assigned to this FormNode in its configuration
	 * entry. Note that this will be undefined for the base FormNode. All
	 * others should have a value.
	 * @return a String that contains the unique key assigned to this FormNode.
	 */
    this.getKey = function(aNode)
    {
    	return this.key;
	}
	
	/**
	 * Gets this node's label to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's label is required.
	 *		  This is not used by this implementation, but may be required by
	 *		  a delegate if one is present.
	 * @return a String that contains the internationalized UI label for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getLabel = function(aNode)
    {
    	if (this.labelKey != null)
    	{
    		return cResourceManager.get(this.labelKey);
    	}
    	if (this.hasDelegate())
    	{
    		return this.delegate.getLabel(aNode);
    	}
    	return null;
	}
		
	/**
	 * Sets the key to this node's label to be displayed in the UI. This is
	 * used to retrieve the internationalized value from the ResourceManager.
	 * Used by the FormNodeFactory when initializing this Object.
	 * @param aString a String that contains the key to this node's UI label.
	 */
    this.setLabelKey = function(aString)
    {
		this.labelKey = aString;
	}
	
	/**
	 * Gets whether this node is mandatory (required). This is usually set as a
	 * field attribute in the UI definition, however sometimes it must be
	 * changed based on business logic. This provides one way of doing this
	 * through its delegates.
	 * @param aNode the Adobe Node instance who's mandatory setting is required.
	 *		  This is not used by this implementation, but may be required by
	 *		  a delegate if one is present.
	 * @return a boolean - true if the node instance should be set to mandatory
	 *		   false if it should be set to optional, null if it shouldn't be
	 *		   changed by this means.
	 */
    this.isMandatory = function(aNode)
    {
    	if (this.mandatory != null)
    	{
    		return this.mandatory;
    	}
    	if (this.hasDelegate())
    	{
    		return this.delegate.isMandatory(aNode);
    	}
    	return null;
	}
	
	/**
	 * Sets whether this node is mandatory (required). This is usually set as a
	 * field attribute in the UI definition, however sometimes it must be
	 * changed based on business logic. This provides one way of doing this
	 * through its delegates.
	 * @param aBoolean true if the node instance should be set to mandatory
	 *		   false if it should be set to optional.
	 */
    this.setMandatory = function(aBoolean)
    {
    	this.mandatory = aBoolean;
	}
	
	/**
	 * Gets this node's name that is used for information purposes when refering
	 * to the node. Note that this may be viewable in the UI (e.g. when
	 * displaying validation results), so should be internationalized.
	 * @param aNode the Adobe Node instance who's name is required.
	 *		  This is not used by this implementation, but may be required by
	 *		  a delegate if one is present.
	 * @return a String that contains the internationalized name of this node.
	 *		   It will return the UI label if one is defined, otherwise it will
	 *		   try to look up the key in the resource bundles and return the
	 *		   key itself if it isn't found.  Note that this will be undefined
	 *		   for the base FormNode.
	 */
    this.getName = function(aNode)
    {
    	var label = this.getLabel(aNode);
    	
    	if (label != null)
    	{
    		return label;
    	}
    	//Since these are not displayed yet, most are not in the resources yet.
    	//This stops the log messages for them being missing. 
    	if (this.key != undefined &amp;&amp; cResourceManager.containsKey(this.key))
    	{
    		return cResourceManager.get(this.key);
    	}
    	//cLog.info("&gt;&gt;&gt; key: " + this.key);
    	return this.key;
	}
		
	/**
	 * Gets this node's parent FormNode. Parent nodes are ones that can have
	 * multiple instances (e.g. subforms).
	 * @return the FormNode that considers this node as one of its children.
	 *		   Null if this is a base node (i.e. not under a subform).
	 */
    this.getParentNode = function()
    {
		return this.parentNode;
	}
		
	/**
	 * Sets this node's parent FormNode. Parent nodes are ones that can have
	 * multiple instances (e.g. subforms). This is called when this object is
	 * being initialized by FormNodeManager, and will automatically clear
	 * parentNodeKey.
	 * @param aFormNode the FormNode that considers this node as one of its
	 *		  children.
	 * @throws an UnexpectedDataType Exception if aFormNode is undefined, null,
	 *		   or isn't a FormNode.
	 */
    this.setParentNode = function(aFormNode)
    {
    	cTypeEnforcer.checkSpecificCustomObject(aFormNode, "FormNode",
    				  "setParentNode", "aFormNode", "FormNode");
		this.parentNode = aFormNode;
		this.parentNodeKey = null;
	}
		
	/**
	 * Gets the key to this node's parent FormNode. This is used to retrieve
	 * the actual FormNode from the FormNodeManager when this object is being
	 * initialized by FormNodeManager, and will be cleared as part of that
	 * process.
	 * @return a String that contains the key to this node's parent FormNode.
	 *		   Null if this is not applicable.
	 */
    this.getParentNodeKey = function()
    {
		return this.parentNodeKey;
	}
		
	/**
	 * Sets the key to this node's parent FormNode. This is used to retrieve
	 * the actual FormNode from the FormNodeManager when this object is being
	 * initialized by FormNodeManager, and will be cleared as part of that
	 * process.
	 * @param aString a String that contains the key to this node's parent
	 *		  FormNode. Null if this is not applicable.
	 */
    this.setParentNodeKey = function(aString)
    {
		this.parentNodeKey = aString;
	}

	/**
	 * Gets whether this node has a parent FormNode (which makes this a child
	 * node). Parent nodes are ones that can have multiple instances (e.g.
	 * subforms).
	 * @return a boolean that is true if this has a parent FormNode.
	 */
    this.hasParent = function()
    {
		return this.parentNode != null;
	}
		
	/**
	 * Gets a string that defines the pick list to be displayed in the UI for
	 * this node.
	 * @param aNode the Adobe Node instance who's pick list is required.
	 *		  This is not used by this implementation, but may be required by
	 *		  a delegate if one is present.
	 * @return the object that contains the list values. This will be one of:
	 *		   1)A String containing a comma delimited list of values to be
	 *		  	 displayed in the list, of the format "displayValue1, code1,
	 *			 displayValue2, code2...". This is what this implementation
	 *			 returns. A delegate, if one is present, may alternatively
	 *			 return one of the following.
	 *		  2)An Array of Objects that implement the ListItem Interface.
	 *		  3)An Array of the Strings that are the values. Note that this
	 *			assumes these are not coded.
	 *		  Null if this is not applicable, an empty String if any existing
	 *		  pick list should be cleared.
	 */
    this.getPickListValues = function(aNode)
    {
    	if (this.pickListKey != null)
    	{
    		return cResourceManager.getPickList(this.pickListKey);
    	}
    	if (this.hasDelegate())
    	{
    		return this.delegate.getPickListValues(aNode);
    	}
		return null;
	}
		
	/**
	 * Sets the key to this node's pick list to be displayed in the UI. This is
	 * used to retrieve the internationalized version from the ResourceManager.
	 * Used by the FormNodeFactory when initializing this Object.
	 * @param aString a String that contains the key to this node's UI pick list.
	 */
    this.setPickListKey = function(aString)
    {
		this.pickListKey = aString;
	}
		
	/**
	 * Gets the SOM expression (path) to the XFA node that this represents. If
	 * this is a child node, this is relative to its parent.
	 * @return a String that contains the SOM expression (path) to the XFA node
	 *		   that this represents.
	 */
    this.getSomExpression = function()
    {
		return this.somExpression;
	}
		
	/**
	 * Sets the SOM expression (path) to the XFA node that this represents. If
	 * this is a child node, this is relative to its parent.
	 * @param aString a String that contains the SOM expression (path) to the
	 *		  XFA node that this represents.
	 */
    this.setSomExpression = function(aString)
    {
		this.somExpression = aString;
	}
		
	/**
	 * Gets this node's tool tip to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's tool tip is required.
	 *		  This is not used by this implementation, but may be required by
	 *		  a delegate if one is present.
	 * @return a String that contains the internationalized UI tool tip for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getToolTip = function(aNode)
    {
    	if (this.toolTipKey != null)
    	{
    		return cResourceManager.get(this.toolTipKey);
    	}
    	if (this.hasDelegate())
    	{
    		return this.delegate.getToolTip(aNode);
    	}
    	return null;
	}
		
	/**
	 * Sets the key to this node's tool tip to be displayed in the UI. This is
	 * used to retrieve the internationalized value from the ResourceManager.
	 * Used by the FormNodeFactory when initializing this Object.
	 * @param aString a String that contains the key to this node's UI tool
	 *		  tip.
	 */
    this.setToolTipKey = function(aString)
    {
		this.toolTipKey = aString;
	}
	
	/**
	 * Gets whether this node is the top of a structure that is validated
	 * separately. When set to true, this node's parent will not call this
	 * node's validateNode() as part of its validation.
	 * Used when this is the top node of a distinct structure (like a dialog)
	 * that is validated on its own.
	 * @return a boolean - true if this node is at the top of a structure that
	 *		   should be validated separately.
	 */
    this.isValidatedSeparately = function(aNode)
    {
    	return this.validatedSeparately;
	}
	
	/**
	 * Sets whether this node is the top of a structure that is validated
	 * separately. When set to true, this node's parent will not call this
	 * node's validateNode() as part of its validation.
	 * Used when this is the top node of a distinct structure (like a dialog)
	 * that is validated on its own. Defaults to false.
	 * @param aBoolean -true if this node is at the top of a structure that
	 *		   should be validated separately.
	 */
    this.setValidatedSeparately = function(aBoolean)
    {
    	this.validatedSeparately = aBoolean;
	}

	/**
	 * Gets an InstanceManager for the Adobe Node that is on the form for this
	 * FormNode. Used for repeating nodes.
	 * @param ancestorNodeInstance (optional) the Adobe Node instance that is a
	 *		  parent of this node. Required if this is below a collection of
	 *		  instances (e.g. a repeating subform). When unspecified, this will
	 *		  follow the 0 index path through to the node's InstanceManager.
	 *		  Note that this does not have to be the immediate parent as long
	 *		  as it is an ancestor.
	 * @return the InstanceManager.
	 * @throws an UnexpectedDataType Exception if ancestorNodeInstance isn't an
	 *		   Adobe Node.
	 * @throws an InstanceManagerNotResolved Exception if aSomExpression can't
	 *		   be resolved to an InstanceManager (it isn't a valid node, or the
	 *		   node isn't repeating so doesn't have an InstanceManager).
	 */
	this.getInstanceManager = function(ancestorNodeInstance)
	{
		cTypeEnforcer.checkNode(ancestorNodeInstance, "FormNode",
					  "getInstanceManager", "ancestorNodeInstance", true);
	
		if (ancestorNodeInstance == undefined)
		{
			return cInstanceManagerUtil.getInstanceManagerForSom(
					this.getFullSomExpression());
		}
		else
		{
			return cInstanceManagerUtil.getInstanceManagerForSom(
					cStringUtil.spliceSomExpressions(
								ancestorNodeInstance.somExpression, 
								this.getFullSomExpression()));
		}
	}

	/**
	 * Gets the current instance of Adobe Node that is on the form for this
	 * FormNode.
	 * @param ancestorNodeInstance (optional) the Adobe Node instance that is a
	 *		  parent of this instance. Required if this is below a collection
	 *		  of instances (e.g. a repeating subform). When unspecified, this
	 *		  will follow the 0 index path through to the instance. Note that
	 *		  this does not have to be the immediate parent as long as it is an
	 *		  ancestor.
	 * @return the instance, or null if none was found.
	 * @throws an UnexpectedDataType Exception if ancestorNodeInstance isn't an
	 *		   Adobe Node.
	 * @throws an UnexpectedState Exception if more than one instance of Adobe
	 *		   Node was found.
	 */
	this.getNodeInstance = function(ancestorNodeInstance)
	{
		cTypeEnforcer.checkNode(ancestorNodeInstance, "FormNode",
					  "getNodeInstance", "ancestorNodeInstance", true);
	
		var nodeInstances = this.getNodeInstances(ancestorNodeInstance);

		if (nodeInstances != null)
		{
			if (nodeInstances.length == 1)
			{
				return nodeInstances.item(0);
			}
			else if (nodeInstances.length &gt; 1)
			{
				throw cException.createInstance("FormNode.getNodeInstance(): "
					  + "there is more than one Adobe Node instance of FormNode '" 
					  + this.getKey() + "'", "UnexpectedState");
			}
		}
		return null;
	}

	/**
	 * Gets all of the current instances of Adobe Node that are on the form for
	 * this FormNode.
	 * @param ancestorNodeInstance (optional) the Adobe Node instance that is a
	 *		  parent of these instances. Required if this is below a collection
	 *		  of instances (e.g. a repeating subform). When unspecified, this
	 *		  will follow the 0 index path through to the instances. Note that
	 *		  this does not have to be the immediate parent as long as it is an
	 *		  ancestor.
	 * @param fromAllAncestors (optional) a boolean - true if this should get
	 *		  all instances that are under all instances of the ancestor. When
	 *		  false, only those below the passed ancestor instance are returned.
	 *		  Ignored unless an ancestor instance is passed. Defaults to false.
	 * @return a nodeList containing the instance(s), or null if none were
	 *		   found.
	 * @throws an UnexpectedDataType Exception if ancestorNodeInstance isn't an
	 *		   Adobe Node or if fromAllAncestors isn't a boolean.
	 */
	this.getNodeInstances = function(ancestorNodeInstance, fromAllAncestors)
	{
		cTypeEnforcer.checkNode(ancestorNodeInstance, "FormNode",
					  "getNodeInstances", "ancestorNodeInstance", true);
		fromAllAncestors = cTypeEnforcer.checkBoolean(fromAllAncestors,
						   "FormNode", "getNodeInstances", "fromAllAncestors",
						   true);
	
		if (ancestorNodeInstance == undefined)
		{
			return xfa.resolveNodes(this.getFullSomExpression() + "[*]");
		}
		else
		{
			var ancestorSomExpression = ancestorNodeInstance.somExpression;

			if (fromAllAncestors)
			{
				ancestorSomExpression = ancestorSomExpression.substring(0,
					ancestorSomExpression.lastIndexOf("[")) + "[*]";
			}
			return xfa.resolveNodes(cStringUtil.spliceSomExpressions(
									ancestorSomExpression, 
									this.getFullSomExpression())
									+ "[*]");
		}
	}

	/**
	 * Locks (makes read only) the related instance(s). This also locks all
	 * child FormNodes.
	 * @param aNodeInstance (optional) the instance of Adobe Node that should
	 *		  be locked. Required if this is below a collection of instances
	 *		  (e.g. a repeating subform). When unspecified, this will use
	 *		  getNodeInstances() to get all instances of this Node and will
	 *		  lock them all.
	 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
	 *		   Node.
	 * @throws an UnexpectedState Exception if this is the "base" FormNode and
	 *		   it doesn't have any children.
	 */
	this.lock = function(aNodeInstance)
	{
		cTypeEnforcer.checkNode(aNodeInstance, "FormNode", "lock",
								"aNodeInstance", true);
	
		if (this.getSomExpression() != null)
		{
			if (aNodeInstance == undefined)
			{
				var nodeInstanceList = this.getNodeInstances();
				
				if (nodeInstanceList != null)
				{
					for (var i = 0; i &lt; nodeInstanceList.length; i++)
					{	
						this.lock(nodeInstanceList.item(i)); //Recursive call
					}
				}		
			}
			else
			{
				if (this.hasChildren())
				{
					for (var i = 0; i &lt; this.getChildren().length; i++)
					{
						this.getChildren()[i]._lockBranch(aNodeInstance);
					}
				}
				else
				{
					this._lockLeaf(aNodeInstance);
				}
			}
		}
		else //Must be the base node (it doesn't have a somExpression)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; this.getChildren().length; i++)
				{
					this.getChildren()[i].lock();
				}
			}
			else //Should never happen
			{
				throw cException.createInstance(
					  "FormNode.lock(): base FormNode has no children",
					  "UnexpectedState");
			}
		}
	}

	/**
	 * Un-locks (makes read / write) the related instance(s). This also
	 * un-locks all child FormNodes.
	 * @param aNodeInstance (optional) the instance of Adobe Node that should
	 *		  be un-locked. Required if this is below a collection of instances
	 *		  (e.g. a repeating subform). When unspecified, this will use
	 *		  getNodeInstances() to get all instances of this Node and will
	 *		  un-lock them all.
	 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
	 *		   Node.
	 * @throws an UnexpectedState Exception if this is the "base" FormNode and
	 *		   it doesn't have any children.
	 */
	this.unLock = function(aNodeInstance)
	{
		cTypeEnforcer.checkNode(aNodeInstance, "FormNode", "unLock",
								"aNodeInstance", true);
	
		if (this.getSomExpression() != null)
		{
			if (aNodeInstance == undefined)
			{
				var nodeInstanceList = this.getNodeInstances();
				
				if (nodeInstanceList != null)
				{
					for (var i = 0; i &lt; nodeInstanceList.length; i++)
					{	
						this.unLock(nodeInstanceList.item(i)); //Recursive call
					}
				}		
			}
			else
			{
				if (this.hasChildren())
				{
					for (var i = 0; i &lt; this.getChildren().length; i++)
					{
						this.getChildren()[i]._unLockBranch(aNodeInstance);
					}
				}
				else
				{
					this._unLockLeaf(aNodeInstance);
				}
			}
		}
		else //Must be the base node (it doesn't have a somExpression)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; this.getChildren().length; i++)
				{
					this.getChildren()[i].unLock();
				}
			}
			else //Should never happen
			{
				throw cException.createInstance(
					  "FormNode.unLock(): base FormNode has no children",
					  "UnexpectedState");
			}
		}
	}

	/**
	 * Updates the visual components in the form that are used to render the
	 * related Adobe node instance(s). This is done mainly to update them to
	 * the current language (e.g. labels, pick lists, etc.), but can also
	 * affect other related items (e.g. whether they are mandatory).
	 * This also updates the visual components for all child FormNodes.
	 * @param aNodeInstance (optional) the instance of Adobe Node that should
	 *		  be updated. Required if this is below a collection of instances
	 *		  (e.g. a repeating subform). When unspecified, this will use
	 *		  getNodeInstances() to get all instances of this Node and will
	 *		  update them all.
	 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
	 *		   Node.
	 * @throws an UnexpectedState Exception if this is the "base" FormNode and
	 *		   it doesn't have any children.
	 */
	this.updateUI = function(aNodeInstance)
	{
		cTypeEnforcer.checkNode(aNodeInstance, "FormNode", "updateUI",
								"aNodeInstance", true);
	
		if (this.getSomExpression() != null)
		{
			if (aNodeInstance == undefined)
			{
				var nodeInstanceList = this.getNodeInstances();
				
				if (nodeInstanceList != null)
				{
					for (var i = 0; i &lt; nodeInstanceList.length; i++)
					{	
						this.updateUI(nodeInstanceList.item(i)); //Recursive call
					}
				}		
			}
			else
			{
				if (this.hasChildren())
				{
					for (var i = 0; i &lt; this.getChildren().length; i++)
					{
						this.getChildren()[i]._updateBranchUI(aNodeInstance);
					}
				}
				else
				{
					this._updateLeafUI(aNodeInstance);
				}
			}
		}
		else //Must be the base node (it doesn't have a somExpression)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; this.getChildren().length; i++)
				{
					this.getChildren()[i].updateUI();
				}
			}
			else //Should never happen
			{
				throw cException.createInstance(
					  "FormNode.updateUI(): base FormNode has no children",
					  "UnexpectedState");
			}
		}
	}

	/**
	 * Validates this node and all of its child FormNodes. The base
	 * implementation checks mandatory fields, but this functionality may be
	 * overridden by delegates as required.
	 * @param aNodeInstance (optional) the instance of Adobe Node that should
	 *		  be validated. Required if this is below a collection of instances
	 *		  (e.g. a repeating subform). When unspecified, this will use
	 *		  getNodeInstances() to get all instances of this Node and will
	 *		  validate them all.
	 * @param updateDisplay (optional) a boolean that indicates whether this
	 *		  should automatically update the colour of the node to reflect
	 *		  whether it passed validation. Defaults to true.
	 * @param aValidationFailure (optional) the ValidationFailure that this
	 *		  should append its validationFailures to. This is only used
	 *		  internally when this is called recursively.
	 * @return a ValidationFailure containing all failures that were
	 *		   encountered. Returns aValidationFailure if that parameter was
	 *		   used. Null if there were no failures.
	 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
	 *		   Node.
	 * @throws an UnexpectedState Exception if this is the "base" FormNode and
	 *		   it doesn't have any children, or if it is a leaf FormNode and
	 *		   wasn't passed a node instance.
	 */
	this.validateNode = function(aNodeInstance, updateDisplay,
								 aValidationFailure)
	{
		var returnTo = null;
    	if (this.hasDelegate() &amp;&amp; this.delegate.isUsedToValidateNodes())
    	{
    	    if (aValidationFailure == undefined)
			{
				aValidationFailure = cValidationFailure.createInstance(
					this._createValidationFailureSourceName(aNodeInstance));
			}
    		returnTo = this.delegate.validateNode(aNodeInstance, updateDisplay,
    										  aValidationFailure);
    	}else{
			returnTo = this._validateNode(aNodeInstance, updateDisplay,
								  aValidationFailure);
    	}
    	if (returnTo != null &amp;&amp; returnTo.hasAnyValidationFailures())
		{
			return returnTo;
		}
    	return null;
	}
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    buffer += "key= " + this.key;
	    buffer += ", somExpression= " + this.somExpression;
	    if (this.hasParent())
	    {
	    	buffer += ", hasParent= true";
	    }
	    if (this.parentNodeKey != null)
	    {
	    	buffer += ", parentNodeKey= " + this.parentNodeKey;
	    }
	    if (this.hasDelegate())
	    {
	    	buffer += ", hasDelegate = true";
	    }
	    buffer += ", defaultValueKey= " + this.defaultValueKey;
	    buffer += ", fieldNumber= " + this.fieldNumber;   	
	    buffer += ", labelKey= " + this.labelKey;   	
	    buffer += ", picklistValues= " + this.picklistValues;   	
	    buffer += ", toolTipKey= " + this.toolTipKey;   	
	    buffer += ", formatType= " + this.formatType;   	
	    if (this.hasChildren())
	    {
	    	buffer += ", children= " + cObjectUtil.asString(this.childNodes);
	    }
		buffer += "]";
		return buffer;
	}

	//===== PROTECTED ==========================================================

	/**
	 * Locks the visual components in the form that are used to render the
	 * related Adobe Node instance(s). This is called by this FormNode's parent
	 * so that it can pass down the relevant parent Adobe Node instance. This
	 * in turn will call the same function in its children, passing each of its
	 * Adobe Node instances.
	 * @param parentNodeInstance the instance of Adobe Node that is the parent
	 *		  of those that should be locked.
	 * @throws an UnexpectedDataType Exception if parentNodeInstance is
	 *		   undefined, null, or isn't an Adobe Node.
	 */
	this._lockBranch = function(parentNodeInstance)
	{
		cTypeEnforcer.checkNode(parentNodeInstance, "FormNode",
			"_lockBranch", "parentNodeInstance");
	
		var nodeInstanceList = this.getNodeInstances(parentNodeInstance);
		
		if (nodeInstanceList != null)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; nodeInstanceList.length; i++)
				{	
					for (var j = 0; j &lt; this.getChildren().length; j++)
					{
						this.getChildren()[j]._lockBranch(
							nodeInstanceList.item(i)); //Recursive call
					}
				}
			}
			else
			{
				for (var i = 0; i &lt; nodeInstanceList.length; i++)
				{
					this._lockLeaf(nodeInstanceList.item(i));
				}
			}
		}
	}
	
	/**
	 * Un-locks the visual components in the form that are used to render the
	 * related Adobe Node instance(s). This is called by this FormNode's parent
	 * so that it can pass down the relevant parent Adobe Node instance. This
	 * in turn will call the same function in its children, passing each of its
	 * Adobe Node instances.
	 * @param parentNodeInstance the instance of Adobe Node that is the parent
	 *		  of those that should be un-locked.
	 * @throws an UnexpectedDataType Exception if parentNodeInstance is
	 *		   undefined, null, or isn't an Adobe Node.
	 */
	this._unLockBranch = function(parentNodeInstance)
	{
		cTypeEnforcer.checkNode(parentNodeInstance, "FormNode",
			"_unLockBranch", "parentNodeInstance");
	
		var nodeInstanceList = this.getNodeInstances(parentNodeInstance);
		
		if (nodeInstanceList != null)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; nodeInstanceList.length; i++)
				{	
					for (var j = 0; j &lt; this.getChildren().length; j++)
					{
						this.getChildren()[j]._unLockBranch(
							nodeInstanceList.item(i)); //Recursive call
					}
				}
			}
			else
			{
				for (var i = 0; i &lt; nodeInstanceList.length; i++)
				{
					this._unLockLeaf(nodeInstanceList.item(i));
				}
			}
		}
	}

	/**
	 * Updates the visual components in the form that are used to render the
	 * related Adobe Node instance(s). This is done mainly to update them to
	 * the current language (e.g. labels, pick lists, etc.), but can also
	 * affect other related items (e.g. whether they are mandatory).
	 * This is called by this FormNode's parent so that it can pass down the
	 * relevant parent Adobe Node instance. This in turn will call the same
	 * function in its children, passing each of its Adobe Node instances.
	 * @param parentNodeInstance the instance of Adobe Node that is the parent
	 *		  of those that should be updated.
	 * @throws an UnexpectedDataType Exception if parentNodeInstance is
	 *		   undefined, null, or isn't an Adobe Node.
	 */
	this._updateBranchUI = function(parentNodeInstance)
	{
		cTypeEnforcer.checkNode(parentNodeInstance, "FormNode",
			"_updateBranchUI", "parentNodeInstance");
	
		var nodeInstanceList = this.getNodeInstances(parentNodeInstance);
		
		if (nodeInstanceList != null)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; nodeInstanceList.length; i++)
				{	
					for (var j = 0; j &lt; this.getChildren().length; j++)
					{
						this.getChildren()[j]._updateBranchUI(
							nodeInstanceList.item(i)); //Recursive call
					}
				}
			}
			else
			{
				for (var i = 0; i &lt; nodeInstanceList.length; i++)
				{
					this._updateLeafUI(nodeInstanceList.item(i));
				}
			}
		}
	}

	/**
	 * This is the standard implementation of validation, which performs "basic"
	 * validation (e.g. mandatory fields, etc.). This also validates all child
	 * FormNodes. This can also be used by Delegates where appropriate.
	 * @param aNodeInstance (optional) the instance of Adobe Node that should
	 *		  be validated, or a parent node to it. Required if this is below a
	 *		  collection of instances (e.g. a repeating subform).
	 * @param updateDisplay (optional) a boolean that indicates whether this
	 *		  should automatically update the colour of the node to reflect
	 *		  whether it passed validation. Defaults to true.
	 * @param aValidationFailure (optional) the ValidationFailure that this
	 *		  should append its validationFailures to. This is only used
	 *		  internally when this is called recursively.
	 * @return a ValidationFailure containing all failures that were
	 *		   encountered. Returns aValidationFailure if that parameter was
	 *		   used. Null if there were no failures.
	 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
	 *		   Node.
	 * @throws an UnexpectedState Exception if this is the "base" FormNode and
	 *		   it doesn't have any children, or if it is a leaf FormNode and
	 *		   wasn't passed a node instance.
	 */
	 //TODO Need to refactor the naming of validation errors so they include the
	 //indices
	this._validateNode = function(aNodeInstance, updateDisplay,
								  aValidationFailure)
	{
		cTypeEnforcer.checkNode(aNodeInstance, "FormNode", "_validateNode",
								"aNodeInstance", true);
		cTypeEnforcer.checkBoolean(updateDisplay, "FormNode", "_validateNode",
								   "updateDisplay", true);

		if (aValidationFailure == undefined)
		{
			aValidationFailure = cValidationFailure.createInstance(
				this._createValidationFailureSourceName(aNodeInstance));
		}
		else
		{
			cTypeEnforcer.checkSpecificCustomObject(aValidationFailure,
				"FormNode", "_validateNode", "aValidationFailure",
				"ValidationFailure");
		}
		//dan added
		if(aNodeInstance &amp;&amp; aNodeInstance.isPropertySpecified("presence") &amp;&amp; aNodeInstance.presence!=="visible"){
			return aValidationFailure;
		}
		
		
		if (updateDisplay == undefined)
		{
			updateDisplay = true;
		}

		if (this.getSomExpression() != null)
		{
			if (aNodeInstance == null)
			{
				var nodeInstanceList = this.getNodeInstances();
						
				if (nodeInstanceList != null)
				{
					for (var i = 0; i &lt; nodeInstanceList.length; i++)
					{	
						aValidationFailure.addNestedValidationFailure(
							this.validateNode(nodeInstanceList.item(i),
											  updateDisplay));
					}
				}
			}
			else
			{
				//Radio Button groups are treated differently
				if (cTypeChecker.isSpecificCustomObject(aNodeInstance,
								 cTypeEnforcer.EXCLUSION_GROUP_CLASS))
				{
					//In this context, they are treated the same as fields
					aValidationFailure.addFailureMessage(
						this._validateExclusionGroup(aNodeInstance,
													 updateDisplay));
				}
				else
				{
					if (this.hasChildren()) //Branch
					{
						for (var i = 0; i &lt; this.getChildren().length; i++)
						{
							var childFormNode = this.getChildren()[i];

							if (!(childFormNode.isValidatedSeparately()))
							{
								var nodeInstanceList = childFormNode
													   .getNodeInstances(aNodeInstance);
										
								if (nodeInstanceList != null)
								{
									for (var j = 0; j &lt; nodeInstanceList.length; j++)
									{
										aValidationFailure.addNestedValidationFailure(
											childFormNode.validateNode(
												nodeInstanceList.item(j),
												updateDisplay));
									}
								}
							}
						}
					}
					else //Leaf
					{
						aValidationFailure.addFailureMessage(
							this._validateLeaf(aNodeInstance, updateDisplay));
					}
				}
			}
		}
		else //Must be the base node (it doesn't have a somExpression)
		{
			if (this.hasChildren())
			{
				for (var i = 0; i &lt; this.getChildren().length; i++)
				{
					if (!(this.getChildren()[i].isValidatedSeparately()))
					{
						this.getChildren()[i].validateNode(undefined,
							 updateDisplay, aValidationFailure);
					}
				}
			}
			else //Should never happen
			{
				throw cException.createInstance(
					  "FormNode._validateNode(): base FormNode has no children",
					  "UnexpectedState");
			}
		}
		
		/* move to validateNode method check delegate validate and normal validate
		if (aValidationFailure.hasAnyValidationFailures())
		{
			return aValidationFailure;
		}
		*/
		return aValidationFailure;
	}

	//===== PRIVATE ============================================================

	/**
	 * Creates a source name suitable for a ValidationFailure. These include a
	 * 1-based index for node instances that are in a collection of more than
	 * one (the first will not have an index). Eg. aNode, aNode(2), aNode(3)...
	 * @param aNodeInstance (optional) the Adobe Node instance that is being
	 *		  processed. If undefined, this will assume an index of 0.
	 * @return a String containing a ValidationFailure source name.
	 */
	this._createValidationFailureSourceName = function(aNodeInstance)
	{
		if (aNodeInstance != null &amp;&amp; aNodeInstance.isPropertySpecified("index") &amp;&amp; aNodeInstance.index &gt; 0)
		{
			return this.getName(aNodeInstance) + " (" 
				   + (aNodeInstance.index + 1)  + ")";
		}
		return this.getName(aNodeInstance);
	}

	/**
	 * Performs the actual locking of the passed related Adobe Node instance.
	 * This is called in the "leaf" FormNodes after a lock request has
	 * traversed all of the "branch" FormNodes.
	 * @param aNode the Adobe Node instance to lock.
	 * @return a ValidationFailure containing all failures that were
	 *		   encountered. Null if there were no failures.
	 */
	this._lockLeaf = function(aNode)
	{
		if (cTypeChecker.isSpecificCustomObject(aNode,
												cTypeEnforcer.FIELD_CLASS))
		{
			cUiUtil.setReadOnly(aNode, true);
		}
	}
	
	/**
	 * Performs the actual un-locking of the passed related Adobe Node instance.
	 * This is called in the "leaf" FormNodes after an un-lock request has
	 * traversed all of the "branch" FormNodes.
	 * @param aNode the Adobe Node instance to un-lock.
	 * @return a ValidationFailure containing all failures that were
	 *		   encountered. Null if there were no failures.
	 */
	this._unLockLeaf = function(aNode)
	{
		if (cTypeChecker.isSpecificCustomObject(aNode,
												cTypeEnforcer.FIELD_CLASS))
		{
			cUiUtil.setReadOnly(aNode, false);
		}
	}
	
	/**
	 * Performs the actual update of the passed related Adobe Node instance
	 * visual component in the form. This is called in the "leaf" FormNodes
	 * after an update request has traversed all of the "branch" FormNodes.
	 * @param aNode the Adobe Node instance to update.
	 */
	this._updateLeafUI = function(aNode)
	{
		var internationalizedString; //Minimize accessor calls
		var mandatory;
	
		mandatory = this.isMandatory(aNode);
		if (mandatory != null)
		{
			cUiUtil.setMandatory(aNode, mandatory);
		}
	
		if (cTypeChecker.isPickList(aNode))
		{
			//Not really internationalized since picklists are coded
			internationalizedString = this.getDefaultValueKey(); 
		}
		else
		{
			internationalizedString = this.getDefaultValue(aNode);
		}
		//populate the field's data only if there was a default value
		//defined and it is empty. Test for a default value first since not
		//all labeled entries have a rawValue.
		if (internationalizedString != null
			&amp;&amp; aNode.rawValue == undefined)
		{
			aNode.rawValue = internationalizedString;
		}
	
		internationalizedString = this.getLabel(aNode);
		if (internationalizedString != null)
		{
			if (this.getFieldNumber() != null)
			{
				internationalizedString = this.getFieldNumber() + ". " 
										  + internationalizedString;
			}
			cUiUtil.setCaption(aNode, internationalizedString);
		}
	
		internationalizedString = this.getToolTip(aNode);
		if (internationalizedString != null)
		{
			cUiUtil.setToolTip(aNode, internationalizedString);
		}
	
		var pickListValues = this.getPickListValues(aNode);

		if (pickListValues != null)
		{
			cUiUtil.setPickList(aNode, pickListValues);
		}
	}

	/**
	 * Performs the actual validation of the passed related Adobe Exclusion
	 * Group instance. This is called for "branch" FormNodes that are Exclusion
	 * Groups (groups of Radio Buttons), since they are validated like fields -
	 * when mandatory, they must have something selected.
	 * @param aGroup the Adobe Exclusion Group instance to validate.
	 * @param updateDisplay a boolean that indicates whether this should
	 *		  automatically update the colour of the radio button nodes to
	 *		  reflect whether it passed validation.
	 * @return a message describing any failure that was encountered. Null if
	 *		   there was no failure.
	 */
	this._validateExclusionGroup = function(aGroup, updateDisplay)
	{
		var errorMessage = cNodeValidator.validateGroup(aGroup);
		
		if (errorMessage == null)
		{
			if (updateDisplay)
			{
				var radioButtonList = aGroup.nodes;
				
				for (var i = 0; i &lt; radioButtonList.length; i++)
				{
					//In case it previously failed
					//There are more nodes than the radio buttons here
					if (cTypeChecker.isSpecificCustomObject(
									 radioButtonList.item(i),
									 cTypeEnforcer.FIELD_CLASS))
					{
						//cLog.info("setColor-radioButton: " 
						//		  + radioButtonList.item(i).somExpression + " : "
						//		  + cObjectUtil.asString(radioButtonList.item(i)));
						cUiUtil.resetColour(radioButtonList.item(i));
					}
				}
			}
		}
		else //Has an error
		{
			if (updateDisplay)
			{
				var radioButtonList = aGroup.nodes;
				
				for (var i = 0; i &lt; radioButtonList.length; i++)
				{
					//There are more nodes than the radio buttons here
					if (cTypeChecker.isSpecificCustomObject(
									 radioButtonList.item(i),
									 cTypeEnforcer.FIELD_CLASS))
					{
						//cLog.info("setColor-radioButton: " 
						//		  + radioButtonList.item(i).somExpression + " : "
						//		  + cObjectUtil.asString(radioButtonList.item(i)));
						cUiUtil.setColour(radioButtonList.item(i),
							cConfigurationManager.get("colourError"));
					}
				}
			}
			return errorMessage;
		}

		return null;
	}

	/**
	 * Performs the actual validation of the passed related Adobe Node
	 * instance. This is called in the "leaf" FormNodes after a validation
	 * request has traversed all of the "branch" FormNodes.
	 * @param aNode the Adobe Node instance to validate.
	 * @param updateDisplay a boolean that indicates whether this should
	 *		  automatically update the colour of the node to reflect whether
	 *		  it passed validation.
	 * @return a message describing any failure that was encountered. Null if
	 *		   there was no failure.
	 */
	this._validateLeaf = function(aNode, updateDisplay)
	{
		if (cTypeChecker.isSpecificCustomObject(aNode,
												cTypeEnforcer.FIELD_CLASS))
		{
			var errorMessage = cNodeValidator.validateField(aNode,
							   this.getFormatType(aNode));
			
			if (errorMessage == null)
			{
				if (updateDisplay)
				{
					cUiUtil.resetColour(aNode); //In case it previously failed
				}
			}
			else //Has an error
			{
				if (updateDisplay)
				{
					cUiUtil.setColour(aNode, cConfigurationManager.get(
											 "colourError"));
				}
				return errorMessage;
			}
		}

		return null;
	}
}
</script>
               <script contentType="application/x-javascript" name="FormNodeManager">//
/*******************************************************************************
 * A class used to retrieve instances of FormNode.  It loads all JavaScript
 * classes in "nodeDefinitions" packages (i.e. treats them as specialized
 * configuration files). This creates a master collection of FormNodes created
 * from all of these entries, so care must be take since individual entries can
 * be over-ridden by those in files that are subsequently loaded. Loading follows
 * the ordering they are in the forms - proceding down the first branches to the
 * first leaves before proceding to the next leaves and then the next branches.
 */

//imports
var cException = script.core.util.Exception;
var cFormNode = script.core.model.FormNode;
var cFormNodeFactory = script.core.model.factory.FormNodeFactory;
var cLog = script.core.util.Log;
var cMap = script.core.util.Map;
var cNodeUtil = script.core.util.NodeUtil;
var cObjectUtil = script.core.util.ObjectUtil;
var cStringUtil = script.core.util.StringUtil;

var baseNode = null; //Fake FormNode (children do not know about this node)
var nodeKeyMap = null; //Map
var nodeSomMap = null; //Map

/**
 * Gets the base FormNode that contains all of the FormNodes that have been
 * defined. This a "fake" node (the only one with no SOM expression). Its
 * immediate child FormNodes are those that were defined with no parents - their
 * SOM expressions are absolute. These in turn may contain child FormNodes
 * whose SOM expressions are relative to those nodes (their parents).
 * @return a FormNode that contains all the FormNodes that have no parents.
 */
function getBaseNode()
{
	if (baseNode == null)
	{
		_load();
	}
	return baseNode;
}

/**
 * Gets the FormNode for the specified key. Returns null and issues a warning if
 * there is none defined for this key.
 * @param key a String that contains the key whose associated FormNode is to be
 *		  returned.
 * @return the FormNode for the specified key, or null if there is none
 *		   defined for this key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function getFormNodeForKey(key)
{
	try
	{
		var result = _getNodeKeyMap().get(key);
		
		if (result == null)
		{
			cLog.warn("FormNodeManager.getFormNodeForKey(): no FormNode found "
					  + "for key '" + key + "'");
		}
		return result;
	}
	catch(exception)
	{
		throw cException.createInstance("FormNodeManager.getFormNodeForKey() "
			  + "encountered a problem: " + exception);
	}
}

/**
 * Gets the FormNode for the specified SOM expression. Returns null and issues a
 * warning if there is none defined for this SOM expression.
 * @param som a String that contains the SOM expression whose associated
 *		  FormNode is to be returned.
 * @return the FormNode with the specified SOM expression, or null if
 *		   there is none defined with this SOM expression.
 * @throws an UnexpectedDataType Exception if som is not a string, undefined, or
 *		   null.
 */
function getFormNodeForSom(som)
{
	try
	{
		//compresses the SOM to remove any instance information
		var result = _getNodeSomMap().get(cStringUtil.generalizeSomExpression(
													 som));
		
		if (result == null)
		{
			cLog.warn("FormNodeManager.getFormNodeForSom(): no FormNode found "
					  + "for SOM '" + som + "'");
		}
		return result;
	}
	catch(exception)
	{
		throw cException.createInstance("FormNodeManager.getFormNodeForSom() "
			  + "encountered a problem: " + exception);
	}
}

//===== PRIVATE ================================================================

/**
 * Gets the Map that stores all of the FormNodes based on the keys they were
 * defined with. This is lazy loaded.
 * @return the Map that stores all of the FormNodes by the defined keys.
 */
function _getNodeKeyMap()
{
	if (nodeKeyMap == null)
	{
		_load();
	}
	return nodeKeyMap;
}

/**
 * Gets the Map that stores all of the FormNodes based on their SOM expressions.
 * This is lazy loaded.
 * @return the Map that stores all of the FormNodes by their SOM expressions.
 */
function _getNodeSomMap()
{
	if (nodeSomMap == null)
	{
		_load();
	}
	return nodeSomMap;
}

/**
 * Initializes the node Map by loading all JavaScript classes that are defining
 * FormNodes. These are in "nodeDefinitions" script packages (subforms)
 * scattered through the code base.
 * @throws an InvalidDefinitionScript Exception if any of the definition scripts
 *		   don't contain a content variable or are otherwise improperly
 *		   formatted.
 * @throws an UnexpectedDataType Exception if any of the script packages are not
 *		   container nodes.
 */
function _load()
{
	var startTime = new Date().getTime();
	var childNodes = new Array();
	var nodeDefPackages = cNodeUtil.getScriptPackages("nodeDefinitions");
	var scripts;

	baseNode = cFormNode.createInstance("base");
	nodeKeyMap = cMap.createInstance();
	nodeSomMap = cMap.createInstance();
	
	for (var i=0; i &lt; nodeDefPackages.length; i++)
	{
		try
		{
			scripts = cNodeUtil.getScripts(nodeDefPackages[i]);
		}
		catch(exception)
		{
			if (exception.className == "Exception")
			{
				throw cException.createInstance("FormNodeManager._load():"
					  + "encountered a problem when processing script package '"
					  + cStringUtil.formatSomExpression(nodeDefPackages[i].somExpression) 
	    			  + "': " + exception.getMessage(),
	    			  exception.getType());
    		}
    		else
    		{
				throw cException.createInstance("FormNodeManager._load():"
					  + "encountered a problem when processing script package '"
					  + cStringUtil.formatSomExpression(nodeDefPackages[i].somExpression) 
	    			  + "': " + exception,
	    			  "UnexpectedException");
    		}
		}
		for (var j=0; j &lt; scripts.length; j++)
		{
			_loadScript(scripts[j], childNodes);
		}
	}
	_populateParents(childNodes);
	_populateSomMap(); //Must be done after they know their parents
	cLog.info("FormNodeManager loaded with " + nodeKeyMap.size() + " nodes in "
			  + (new Date().getTime() - startTime) + "ms");
}

/**
 * Loads a specific JavaScript class that contains FormNode definitions. All of
 * the nodes are added to the nodeKeyMap.
 * @param aScript the JavaScript class that contains FormNode definitions.
 * @param childNodes an Array that contains all loaded nodes that are children
 *		  of other nodes. This adds nodes that it senses are children to this
 *		  collection. Otherwise, they are added to the baseNode's children.
 * @throws an InvalidDefinitionScript Exception if any of the definition scripts
 *		   don't contain a content variable or are otherwise improperly
 *		   formatted.
 */
function _loadScript(aScript, childNodes)
{
	if (aScript.content != undefined)
	{
	    var definitions = cObjectUtil.getProperties(aScript.content);
	    var definitionKeys = definitions.keySet();
	    var formNode;
	    
		for (var i=0; i &lt; definitionKeys.length; i++)
		{
			if (nodeKeyMap.containsKey(definitionKeys[i]))
			{
				cLog.warn("FormNodeManager: duplicate entry found for key '" 
						  + definitionKeys[i] + "' - duplicate skipped.");
			}
			else
			{
				formNode = cFormNodeFactory.createFormNode(definitionKeys[i],
											definitions.get(definitionKeys[i]));
				nodeKeyMap.put(definitionKeys[i], formNode);
				if (formNode.getParentNodeKey() == null)
				{
					baseNode.addChildNode(formNode);
				}
				else
				{
					childNodes.push(formNode);
				}
			}
		}
    }
    else
    {
    	throw cException.createInstance("FormNodeManager._loadScript():" 
    		  + " Definition script '" 
    		  + cStringUtil.formatSomExpression(aScript.somExpression) 
    		  + "' does not contain a content variable",
    		  "InvalidDefinitionScript");
    }
}

/**
 * Populates the passed child FormNodes' parents.
 * @param childNodes an Array that contains all loaded nodes that are children
 *		  of other nodes.
 * @throws an InvalidDefinitionScript Exception if a parent isn't found.
 */
function _populateParents(childNodes)
{
	var parentNode;

	for (var i=0; i &lt; childNodes.length; i++)
	{
		parentNode = nodeKeyMap.get(childNodes[i].getParentNodeKey());
		if (parentNode != null)
		{
			childNodes[i].setParentNode(parentNode);
			parentNode.addChildNode(childNodes[i]);
		}
		else
		{
	    	throw cException.createInstance("FormNodeManager._populateParents():" 
	    		  + " could not find parent FormNode '"  
	    		  + childNodes[i].getParentNodeKey() + "' for child FormNode '"
	    		  + childNodes[i].getSomExpression() + "'",
	    		  "InvalidDefinitionScript");
		}
	}
}

/**
 * Populates the nodeSomMap with all of the formNodes based on their full SOM
 * expressions. Note that the full SOMs are compressed to remove any instance
 * information that may be there (although, in this case, this should do
 * nothing since the configured values shouldn't have any to begin with).
 */
function _populateSomMap()
{
	var formNodes = nodeKeyMap.values();

	for (var i=0; i &lt; formNodes.length; i++)
	{
		nodeSomMap.put(
			cStringUtil.generalizeSomExpression(
						formNodes[i].getFullSomExpression()),
						formNodes[i]);
	}
}
</script>
               <script contentType="application/x-javascript" name="ListItemInterface">//
/*******************************************************************************
 * This defines an Interface that is implemented by Objects that can be
 * displayed in the User Interface picklists. These must have a unique code that
 * is hidden and a description that is displayed.
 *
 * @extends CodeableInterface - not technically, but we make it look that way
 *	by giving ListItemInterface every method and constant available to 
 *	CodeableInterface
 */
 
// imports
var cCodeableInterface = script.core.model.CodeableInterface;

var interfaceName = "ListItemInterface"; //Required for all interfaces

//Constant that must be used by implementing class when creatig a dummy/empty entry.
var NO_ENTRY_CODE = cCodeableInterface.NO_ENTRY_CODE;

/**
 * Gets this list item's unique code. This is not displayed in the list.
 * @return a String that contains this list item's unique code.
 */
function getItemCode(){}

/**
 * Gets this list item's description. This is displayed in the list.
 * @return a String that contains this list item's description.
 */
function getItemDescription(){}
</script>
               <?templateDesigner expand 1?></variables>
            <subform w="100mm" h="50mm" name="delegate">
               <variables>
                  <script contentType="application/x-javascript" name="EmailDelegate">//
/*******************************************************************************
 * An object that responds to information requests sent to an email FormNode.
 *
 * Implements FormNodeDelegateInterface.
 */

//imports
var cLog = script.core.util.Log;

var _EMAIL_FORMAT_TYPE = "email";

/*******************************************************************************
 * Gets a new EmailDelegate. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * Note that this is only intended for use by FormNodeFactory. All instances
 * should be created by that class.
 * @return the new EmailDelegate instance
 */
function createInstance()
{
	return new EmailDelegateClass();
}

/**
 * Class implementation
 */
function EmailDelegateClass(somExpression)
{
	this.className = "EmailDelegate";

	this.formNode;

	/**
	 * Gets this node's default value, which is an internationalized value.
	 * This returns null since this uses a picklist.
	 * @param aNode the Adobe Node instance who's default value is required.
	 * @return a String that contains the internationalized default value for
	 *		   the passed Node. Null if this is not applicable.
	 */
    this.getDefaultValue = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * @param aNode the Adobe Node instance who's value must conform to a 
	 *		  specific format.
	 * @return a String that contains the type of format validation to be
	 *		   applied to data entered into this node in the UI. These must be
	 *		   types that are supported by the currently installed 
	 *		   FormatValidator. Null if this is not applicable.
	 */
    this.getFormatType = function(aNode)
    {
    	return _EMAIL_FORMAT_TYPE;
	}

	/**
	 * Gets this node's label to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's label is required.
	 * @return a String that contains the internationalized UI label for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getLabel = function(aNode)
    {
    	return null;
   	}

	/**
	 * Gets whether this node is mandatory (required).
	 * @param aNode the Adobe Node instance who's mandatory setting is required.
	 * @return a boolean - true if the country is Canada or the US, false if it
	 *		   is any other value, null if there was no node passed.
	 */
	this.isMandatory = function(aNode)
	{
		return null;
	}
		
	/**
	 * Gets a string that defines the pick list to be displayed in the UI for
	 * this node.
	 * @param aNode the Adobe Node instance who's pick list is required.
	 * @return a String that contains the definition of the pick list to be
	 *		   displayed in the UI for this node. The format is:
	 *		   "displayValue1, code1, displayValue2, code2...". Null if
	 *		   this is not applicable.
	 */
    this.getPickListValues = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets this node's tool tip to be displayed in the UI, which is an
	 * internationalized value. In this case it is null, since these are
	 * dependant on the subform that the field is in (must be handled by the
	 * FormNode itself).
	 * @param aNode the Adobe Node instance who's tool tip is required.
	 * @return a String that contains the internationalized UI tool tip for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getToolTip = function(aNode)
    {
    	return null;
	}

	/**
	 * Sets the FormNode that is using this delegate. It is mandatory that this
	 * is set to allow the delegate to access items in the FormNode as required.
	 * @param aFormNode the FormNode that is using this delegate.
	 */
    this.setFormNode = function(aFormNode)
    {
    	this.formNode = aFormNode;
	}

	/**
	 * Gets whether this delegate is used to validate node instances (e.g.
	 * mandatory fields, etc.) as well as their child nodes.
	 * @return a boolean -true if this should be called to perform validation.
	 */
	this.isUsedToValidateNodes = function()
	{
		return false;
	}
	
	/**
	 * Dummy function stub so the interface requirements are met.
	 */
	this.validateNode = function(aNodeInstance, updateDisplay,
								 aValidationFailure)
	{
		cLog.error(this.className 
				   + ".validateNode(): this does not do validation.");
	}
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    if (this.formNode != null)
	    {
	    	buffer += "formNode.somExpression= " + this.formNode.somExpression;
	    }
	    else
	    {
	    	buffer += "formNode= null";
	    }
		buffer += "]";
		return buffer;
	}
}
</script>
                  <script contentType="application/x-javascript" name="FormNodeDelegateInterface">//
/*******************************************************************************
 * This defines an Interface that is implemented by Objects that are injected
 * into FormNodes to replace their basic functionality with specialized, more
 * complex, functionality. Each FormNode that uses a delegate must be given its
 * own instance.
 *
 * Note that these must be implemented by custom Objects in the standard way;
 *	-The Class must contain a "createInstance" method.
 *	-The instance must contain a public "className" variable set to its name.
 *	-The instance must implement "asString()" to get descriptive information.
 */

var interfaceName = "FormNodeDelegateInterface"; //Required for all interfaces

/**
 * Gets this node's default value, which is an internationalized value.
 * @param aNode the Adobe Node instance who's default value is required.
 * @return a String that contains the internationalized default value for
 *		   the passed Node. Null if this is not applicable.
 */
function getDefaultValue(aNode){}
		
/**
 * Gets the type of format validation to be applied to data entered into
 * this node in the UI.
 * @param aNode the Adobe Node instance who's value must conform to a 
 *		  specific format.
 * @return a String that contains the type of format validation to be
 *		   applied to data entered into this node in the UI. These must be
 *		   types that are supported by the currently installed 
 *		   FormatValidator. Null if this is not applicable.
 */
function getFormatType(aNode){}

/**
 * Gets this node's label to be displayed in the UI, which is an
 * internationalized value.
 * @param aNode the Adobe Node instance who's label is required.
 * @return a String that contains the internationalized UI label for the
 *		   passed Node. Null if this is not applicable.
 */
function getLabel(aNode){}

/**
 * Gets whether this node is mandatory (required). This is usually set as a
 * field attribute in the UI definition, however sometimes it must be
 * changed based on business logic. This provides one way of doing this
 * through its delegates.
 * @param aNode the Adobe Node instance who's mandatory setting is required.
 * @return a boolean - true if the node instance should be set to mandatory
 *		   false if it should be set to optional, undefined if it shouldn't
 *		   be changed by this means.
 */
function isMandatory(aNode){}

/**
 * Gets a string that defines the pick list to be displayed in the UI for
 * this node.
 * @param aNode the Adobe Node instance who's pick list is required.
 * @return the object that contains the list values. This will be one of:
 *		   1)A String containing a comma delimited list of values to be
 *		  	 displayed in the list, of the format "displayValue1, code1,
 *			 displayValue2, code2...".
 *		   2)An Array of Objects that implement the ListItem Interface.
 *		   3)An Array of the Strings that are the values. Note that this
 *			 assumes these are not coded.
 *		   Null if this is not applicable, an empty String if any existing
 *		   pick list should be cleared.
 */
function getPickListValues(aNode){}
		
/**
 * Gets this node's tool tip to be displayed in the UI, which is an
 * internationalized value.
 * @param aNode the Adobe Node instance who's tool tip is required.
 * @return a String that contains the internationalized UI tool tip for the
 *		   passed Node. Null if this is not applicable.
 */
function getToolTip(aNode){}

/**
 * Sets the FormNode that is using this delegate. It is mandatory that this
 * is set to allow the delegate to access items in the FormNode as required.
 * @param aFormNode the FormNode that is using this delegate.
 */
function setFormNode(aFormNode){}

/**
 * Gets whether this delegate is used to validate node instances (e.g.
 * mandatory fields, etc.) as well as their child nodes.
 * @return a boolean -true if this should be called to perform validation.
 */
function isUsedToValidateNodes(){}

/**
 * Performs custom validation. This also validates all child FormNodes if
 * required. It may call the FormNode's _validateNode().
 * @param aNodeInstance (optional) the instance of Adobe Node that should
 *		  be validated. Required if this is below a collection of instances
 *		  (e.g. a repeating subform). When unspecified, this may use the
 *		  FormNode's getNodeInstances() to get all instances of this Node
 *		  to validate.
 * @param updateDisplay (optional) a boolean that indicates whether this
 *		  should automatically update the colour of the node to reflect
 *		  whether it passed validation. Defaults to true.
 * @param aValidationFailure (optional) the ValidationFailure that this
 *		  should append its validationFailures to. This is only used
 *		  internally when this is called recursively.
 * @return a ValidationFailure containing all failures that were
 *		   encountered. Returns aValidationFailure if that parameter was
 *		   used. Null if there were no failures.
 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
 *		   Node.
 */
function validateNode(aNodeInstance, updateDisplay, aValidationFailure){}

</script>
                  <script contentType="application/x-javascript" name="MandatoryCheckBoxDelegate">//
/*******************************************************************************
 * An object that responds to information requests sent to a set of check boxes
 * FormNode. This determines whether one of the children check boxes is checked
 * and responds accordingly.
 * Note that this assumes that the all check boxes are children to the same
 * parent.
 *
 * Implements FormNodeDelegateInterface.
 */

//imports
var cConfigurationManager = script.core.util.ConfigurationManager;
var cLog = script.core.util.Log;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;
var cTypeChecker = script.core.util.TypeChecker;
var cUiUtil = script.core.util.UiUtil;
var cValidationFailure = script.core.validation.ValidationFailure;

/*******************************************************************************
 * Gets a new MandatoryCheckBoxDelegate. Adobe does not allow object instances
 * to be created outside of their packaging, so it must be done here.
 * Note that this is only intended for use by FormNodeFactory. All instances
 * should be created by that class.
 * @return the new MandatoryCheckBoxDelegate instance
 */
function createInstance()
{
	return new MandatoryCheckBoxDelegateClass();
}

/**
 * Given a parent node which contains a set of checkBoxes in its
 * children, check if at least one of the checkboxes is checked.
 * @param aNode the parent Adobe Node instance that is being processed.
 * @return a boolean - true if at least one checkbox is checked.
 */
function isMandatoryCheckBoxPassed(aNode)
{
	var checkBoxArray = this._getCheckBoxNodeArray(aNode);
	return this._isOneCheckBoxChecked(checkBoxArray);
}

/**
 * Class implementation
 */
function MandatoryCheckBoxDelegateClass(somExpression)
{
	this.className = "MandatoryCheckBoxDelegate";

	this.formNode;

	/**
	 * Gets this node's default value, which is an internationalized value.
	 * This returns null since this uses a picklist.
	 * @param aNode the Adobe Node instance who's default value is required.
	 * @return a String that contains the internationalized default value for
	 *		   the passed Node. Null if this is not applicable.
	 */
    this.getDefaultValue = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * @param aNode the Adobe Node instance who's value must conform to a 
	 *		  specific format.
	 * @return a String that contains the type of format validation to be
	 *		   applied to data entered into this node in the UI. These must be
	 *		   types that are supported by the currently installed 
	 *		   FormatValidator. Null if this is not applicable.
	 */
    this.getFormatType = function(aNode)
    {
    	return null;
	}

	/**
	 * Gets this node's label to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's label is required.
	 * @return a String that contains the internationalized UI label for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getLabel = function(aNode)
    {
    	return null;
   	}

	/**
	 * Gets whether this node is mandatory (required).
	 * @param aNode the Adobe Node instance who's mandatory setting is required.
	 * @return a boolean - true if the country is Canada or the US, false if it
	 *		   is any other value, null if there was no node passed.
	 */
	this.isMandatory = function(aNode)
	{
    	if (aNode != undefined)
    	{
    		var childrenNodes = this._getChildrenNodes(aNode);
    	}
		return null;
	}
		
	/**
	 * Gets a string that defines the pick list to be displayed in the UI for
	 * this node.
	 * @param aNode the Adobe Node instance who's pick list is required.
	 * @return a String that contains the definition of the pick list to be
	 *		   displayed in the UI for this node. The format is:
	 *		   "displayValue1, code1, displayValue2, code2...". Null if
	 *		   this is not applicable.
	 */
    this.getPickListValues = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets this node's tool tip to be displayed in the UI, which is an
	 * internationalized value. In this case it is null, since these are
	 * dependant on the subform that the field is in (must be handled by the
	 * FormNode itself).
	 * @param aNode the Adobe Node instance who's tool tip is required.
	 * @return a String that contains the internationalized UI tool tip for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getToolTip = function(aNode)
    {
    	return null;
	}

	/**
	 * Sets the FormNode that is using this delegate. It is mandatory that this
	 * is set to allow the delegate to access items in the FormNode as required.
	 * @param aFormNode the FormNode that is using this delegate.
	 */
    this.setFormNode = function(aFormNode)
    {
    	this.formNode = aFormNode;
	}

	/**
	 * Gets whether this delegate is used to validate node instances (e.g.
	 * mandatory fields, etc.) as well as their child nodes.
	 * @return a boolean -true if this should be called to perform validation.
	 */
	this.isUsedToValidateNodes = function()
	{
		return true;
	}
	
	/**
	 * Performs custom validation. This also validates all child FormNodes if
	 * required. It may call the FormNode's _validateNode().
	 * @param aNodeInstance (optional) the instance of Adobe Node that should
	 *		  be validated. Required if this is below a collection of instances
	 *		  (e.g. a repeating subform). When unspecified, this may use the
	 *		  FormNode's getNodeInstances() to get all instances of this Node
	 *		  to validate.
	 * @param updateDisplay (optional) a boolean that indicates whether this
	 *		  should automatically update the colour of the node to reflect
	 *		  whether it passed validation. Defaults to true.
	 * @param aValidationFailure (optional) the ValidationFailure that this
	 *		  should append its validationFailures to. This is only used
	 *		  internally when this is called recursively.
	 * @return a ValidationFailure containing all failures that were
	 *		   encountered. Returns aValidationFailure if that parameter was
	 *		   used. Null if there were no failures.
	 * @throws an UnexpectedDataType Exception if aNodeInstance isn't an Adobe
	 *		   Node.
	 */
	this.validateNode = function(aNodeInstance, updateDisplay,
								 aValidationFailure)
	{
		// This is to perform all other validations beside the checkBoxes
		// It must be called before the checkBoxes validation to avoid being
		// overwirtten.
		this.formNode._validateNode(aNodeInstance, updateDisplay,
									aValidationFailure);

		var checkBoxArray = this._getCheckBoxNodeArray(aNodeInstance);

		// Check if none of the checkBoxes is checked
		if (!this._isOneCheckBoxChecked(checkBoxArray))
		{
			for (var i=0; i &lt; checkBoxArray.length; i++)
			{
				cUiUtil.setColour(checkBoxArray[i],
									cConfigurationManager.get("colourError"));
			}
			var newValidationFailure = cValidationFailure.createInstance(
										"CheckBoxSet",
										cResourceManager.get(
										"error_mandatoryCheckBoxSet"));
			if (aValidationFailure != null)
			{
				aValidationFailure.addNestedValidationFailure(newValidationFailure);
			}
			else
			{
				aValidationFailure = newValidationFailure;
			}
		}
		else
		{
			for (var i=0; i &lt; checkBoxArray.length; i++)
			{
				cUiUtil.resetColour(checkBoxArray[i]); //In case it previously failed
			}
		}
		
		return aValidationFailure;
	}
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    if (this.formNode != null)
	    {
	    	buffer += "formNode.somExpression= " + this.formNode.somExpression;
	    }
	    else
	    {
	    	buffer += "formNode= null";
	    }
		buffer += "]";
		return buffer;
	}

	//===== PRIVATE ============================================================
	/**
	 * Gets the children nodes from the given parent node and collect the ones
	 * that are checkBoxes into a node array. Issues a warning if the no children
	 * nodes can be found.
	 * @param aNode the parent Adobe Node instance that is being processed.
	 * @return an array - contains children nodes that are checkBoxes.
	 */
	this._getCheckBoxNodeArray = function(aNode)
	{
		var childrenNodeList = aNode.nodes;
		var checkBoxArray = new Array();

		if (childrenNodeList != null)
		{
			for(var i=0; i &lt; childrenNodeList.length; i++)
			{
				if (cTypeChecker.isCheckBox(childrenNodeList.item(i)))
				{
					checkBoxArray.push(childrenNodeList.item(i));
				}
			}
			return checkBoxArray;
		}
		cLog.warn("MandatoryCheckBoxDelegate._getCheckBoxNodeArray(aNode)"
				  + " couldn't find any child node for " + aNode.somExpression);
		return null;
	}

	/**
	 * Verify if at least one of the checkBox is checked in a checkBox array.
	 * @param aNodeArray the Adobe Node Array instance that is being processed.
	 * @return a boolean -true if at least one checkBox is checked.
	 */
	this._isOneCheckBoxChecked = function(aNodeArray)
	{
		for (var i=0; i &lt; aNodeArray.length; i++)
		{
			if (aNodeArray[i].rawValue == 1)
			{
				return true;
			}
		}
		return false;
	}
}
</script>
                  <script contentType="application/x-javascript" name="PostalZipDelegate">//
/*******************************************************************************
 * An object that responds to information requests sent to a postal/zip code
 * FormNode. This determines whether the country is Canada, the US, or other
 * value and responds accordingly.
 * Note that this assumes that the related country node instance is a peer to
 * this one (i.e. has the same parent).
 *
 * Implements FormNodeDelegateInterface.
 */

//imports
var cConfigurationManager = script.core.util.ConfigurationManager;
var cLog = script.core.util.Log;
var cResourceManager = script.core.lang.ResourceManager;

var _COUNTRY_NODE_NAME = null; //String
var _COUNTRY_NODE_NAME_KEY = "countryNodeName";
var _POSTAL_CODE_FORMAT_TYPE = "postalCode";
var _POSTAL_CODE_LABEL_KEY = "postalCode";
var _POSTAL_ZIP_CODE_LABEL_KEY = "postalZipCode";
var _ZIP_CODE_FORMAT_TYPE = "zipCode";
var _ZIP_CODE_LABEL_KEY = "zipCode";

/*******************************************************************************
 * Gets a new PostalZipDelegate. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * Note that this is only intended for use by FormNodeFactory. All instances
 * should be created by that class.
 * @return the new PostalZipDelegate instance
 */
function createInstance()
{
	return new PostalZipDelegateClass();
}

//===== PRIVATE ================================================================
/**
 * Gets the name of the country node. This is lazy loaded from the configuration
 * since the field naming conventions may vary between applications.
 * @return the name of country nodes in this form.
 */
function _getCountryNodeName()
{
	if (_COUNTRY_NODE_NAME == null)
	{
		_COUNTRY_NODE_NAME = cConfigurationManager.get(_COUNTRY_NODE_NAME_KEY);
		if (_COUNTRY_NODE_NAME == null)
		{
			cLog.warn("PostalZipDelegate._getCountryNodeName(): '"
					  + _COUNTRY_NODE_NAME_KEY + "' not found in the configuration");
		}
	}
	return _COUNTRY_NODE_NAME;
}

/**
 * Class implementation
 */
function PostalZipDelegateClass(somExpression)
{
	this.className = "PostalZipDelegate";

	this.formNode;

	/**
	 * Gets this node's default value, which is an internationalized value.
	 * This returns null since this uses a picklist.
	 * @param aNode the Adobe Node instance who's default value is required.
	 * @return a String that contains the internationalized default value for
	 *		   the passed Node. Null if this is not applicable.
	 */
    this.getDefaultValue = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * @param aNode the Adobe Node instance who's value must conform to a 
	 *		  specific format.
	 * @return a String that contains the type of format validation to be
	 *		   applied to data entered into this node in the UI. These must be
	 *		   types that are supported by the currently installed 
	 *		   FormatValidator. Null if this is not applicable.
	 */
    this.getFormatType = function(aNode)
    {
    	if (aNode != undefined)
    	{
    		var countryValue = this._getCountry(aNode);

			if(countryValue == "CA")
			{
    			return _POSTAL_CODE_FORMAT_TYPE;
			}
			else if(countryValue == "US")
			{
    			return _ZIP_CODE_FORMAT_TYPE;
			}
    	}
    	return null;
	}

	/**
	 * Gets this node's label to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's label is required.
	 * @return a String that contains the internationalized UI label for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getLabel = function(aNode)
    {
    	if (aNode != undefined)
    	{
    		var countryValue = this._getCountry(aNode);

			if(countryValue == "CA")
			{
    			return cResourceManager.get(_POSTAL_CODE_LABEL_KEY);
			}
			else if(countryValue == "US")
			{
    			return cResourceManager.get(_ZIP_CODE_LABEL_KEY);
			}
    	}
    	return cResourceManager.get(_POSTAL_ZIP_CODE_LABEL_KEY);
   	}

	/**
	 * Gets whether this node is mandatory (required).
	 * @param aNode the Adobe Node instance who's mandatory setting is required.
	 * @return a boolean - true if the country is Canada or the US, false if it
	 *		   is any other value, null if there was no node passed.
	 */
	this.isMandatory = function(aNode)
	{
    	if (aNode != undefined)
    	{
    		var countryValue = this._getCountry(aNode);

			return (countryValue == "CA" || countryValue == "US");
    	}
		return null;
	}
		
	/**
	 * Gets a string that defines the pick list to be displayed in the UI for
	 * this node.
	 * @param aNode the Adobe Node instance who's pick list is required.
	 * @return a String that contains the definition of the pick list to be
	 *		   displayed in the UI for this node. The format is:
	 *		   "displayValue1, code1, displayValue2, code2...". Null if
	 *		   this is not applicable.
	 */
    this.getPickListValues = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets this node's tool tip to be displayed in the UI, which is an
	 * internationalized value. In this case it is null, since these are
	 * dependant on the subform that the field is in (must be handled by the
	 * FormNode itself).
	 * @param aNode the Adobe Node instance who's tool tip is required.
	 * @return a String that contains the internationalized UI tool tip for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getToolTip = function(aNode)
    {
    	return null;
	}

	/**
	 * Sets the FormNode that is using this delegate. It is mandatory that this
	 * is set to allow the delegate to access items in the FormNode as required.
	 * @param aFormNode the FormNode that is using this delegate.
	 */
    this.setFormNode = function(aFormNode)
    {
    	this.formNode = aFormNode;
	}

	/**
	 * Gets whether this delegate is used to validate node instances (e.g.
	 * mandatory fields, etc.) as well as their child nodes.
	 * @return a boolean -true if this should be called to perform validation.
	 */
	this.isUsedToValidateNodes = function()
	{
		return false;
	}
	
	/**
	 * Dummy function stub so the interface requirements are met.
	 */
	this.validateNode = function(aNodeInstance, updateDisplay,
								 aValidationFailure)
	{
		cLog.error(this.className 
				   + ".validateNode(): this does not do validation.");
	}
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    if (this.formNode != null)
	    {
	    	buffer += "formNode.somExpression= " + this.formNode.somExpression;
	    }
	    else
	    {
	    	buffer += "formNode= null";
	    }
		buffer += "]";
		return buffer;
	}

	//===== PRIVATE ============================================================
	/**
	 * Gets the value of a country node. Issues a warning if the country node
	 * can't be found.
	 * @param aNode the Adobe Node instance that is being processed.
	 * @return the value of the related country node in this form.
	 */
	this._getCountry = function(aNode)
	{
		var countryNode = xfa.resolveNode(aNode.parent.somExpression + "."
										  + _getCountryNodeName());
				
		if (countryNode != null)
		{
    		return countryNode.rawValue;
		}
		cLog.info("PostalZipDelegate._getCountry couldn't find the country"
				  + " node for " + aNode.somExpression);
		return null;
	}
}
</script>
                  <script contentType="application/x-javascript" name="ProvinceStateDelegate">//
/*******************************************************************************
 * An object that responds to information requests sent to a province/state
 * FormNode. This determines whether the country is Canada, the US, or other
 * value and responds accordingly.
 * Note that this assumes that the related country node instance is a peer to
 * this one (i.e. has the same parent).
 *
 * Implements FormNodeDelegateInterface.
 */

//imports
var cConfigurationManager = script.core.util.ConfigurationManager;
var cLog = script.core.util.Log;
var cResourceManager = script.core.lang.ResourceManager;

var _COUNTRY_NODE_NAME = null; //String
var _COUNTRY_NODE_NAME_KEY = "countryNodeName";
var _PROVINCE_LABEL_KEY = "province";
var _PROVINCE_LIST_KEY = "provinceList";
var _PROVINCE_STATE_LABEL_KEY = "provinceState";
var _STATE_LABEL_KEY = "state";
var _STATE_LIST_KEY = "stateList";

/**
 * Gets a new ProvinceStateDelegate. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * Note that this is only intended for use by FormNodeFactory. All instances
 * should be created by that class.
 * @return the new ProvinceStateDelegate instance
 */
function createInstance()
{
	return new ProvinceStateDelegateClass();
}

//===== PRIVATE ================================================================
/**
 * Gets the name of the country node. This is lazy loaded from the configuration
 * since the field naming conventions may vary between applications.
 * @return the name of country nodes in this form.
 */
function _getCountryNodeName()
{
	if (_COUNTRY_NODE_NAME == null)
	{
		_COUNTRY_NODE_NAME = cConfigurationManager.get(_COUNTRY_NODE_NAME_KEY);
		if (_COUNTRY_NODE_NAME == null)
		{
			cLog.warn("ProvinceStateDelegate._getCountryNodeName(): '"
					  + _COUNTRY_NODE_NAME_KEY + "' not found in the configuration");
		}
	}
	return _COUNTRY_NODE_NAME;
}

/*******************************************************************************
 * Class implementation
 */
function ProvinceStateDelegateClass(somExpression)
{
	this.className = "ProvinceStateDelegate";

	this.formNode;

	/**
	 * Gets this node's default value, which is an internationalized value.
	 * This returns null since this uses a picklist.
	 * @param aNode the Adobe Node instance who's default value is required.
	 * @return a String that contains the internationalized default value for
	 *		   the passed Node. Null if this is not applicable.
	 */
    this.getDefaultValue = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * @param aNode the Adobe Node instance who's value must conform to a 
	 *		  specific format.
	 * @return a String that contains the type of format validation to be
	 *		   applied to data entered into this node in the UI. These must be
	 *		   types that are supported by the currently installed 
	 *		   FormatValidator. Null if this is not applicable.
	 */
    this.getFormatType = function(aNode)
    {
    	return null;
	}

	/**
	 * Gets this node's label to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's label is required.
	 * @return a String that contains the internationalized UI label for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getLabel = function(aNode)
    {
    	if (aNode != undefined)
    	{
    		var countryValue = this._getCountry(aNode);

			if(countryValue == "CA")
			{
    			return cResourceManager.get(_PROVINCE_LABEL_KEY);
			}
			else if(countryValue == "US")
			{
    			return cResourceManager.get(_STATE_LABEL_KEY);
			}
    	}
    	return cResourceManager.get(_PROVINCE_STATE_LABEL_KEY);
   	}

	/**
	 * Gets whether this node is mandatory (required).
	 * @param aNode the Adobe Node instance who's mandatory setting is required.
	 * @return a boolean - true if the country is Canada or the US, false if it
	 *		   is any other value, null if there was no node passed.
	 */
	this.isMandatory = function(aNode)
	{
    	if (aNode != undefined)
    	{
    		var countryValue = this._getCountry(aNode);

			return (countryValue == "CA" || countryValue == "US");
    	}
		return null;
	}
		
	/**
	 * Gets a string that defines the pick list to be displayed in the UI for
	 * this node.
	 * @param aNode the Adobe Node instance who's pick list is required.
	 * @return a String that contains the definition of the pick list to be
	 *		   displayed in the UI for this node. The format is:
	 *		   "displayValue1, code1, displayValue2, code2...". Null if this
	 *		   is not applicable, an empty String if any existing pick list
	 *		   should be cleared.
	 */
    this.getPickListValues = function(aNode)
    {
    	if (aNode != undefined)
    	{
    		var countryValue = this._getCountry(aNode);
    		
			if(countryValue == "CA")
			{
    			return cResourceManager.getPickList(_PROVINCE_LIST_KEY);
			}
			else if(countryValue == "US")
			{
    			return cResourceManager.getPickList(_STATE_LIST_KEY);
			}
    	}
    	return "";
	}
		
	/**
	 * Gets this node's tool tip to be displayed in the UI, which is an
	 * internationalized value. In this case it is null, since these are
	 * dependant on the subform that the field is in (must be handled by the
	 * FormNode itself).
	 * @param aNode the Adobe Node instance who's tool tip is required.
	 * @return a String that contains the internationalized UI tool tip for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getToolTip = function(aNode)
    {
    	return null;
	}

	/**
	 * Sets the FormNode that is using this delegate. It is mandatory that this
	 * is set to allow the delegate to access items in the FormNode as required.
	 * @param aFormNode the FormNode that is using this delegate.
	 */
    this.setFormNode = function(aFormNode)
    {
    	this.formNode = aFormNode;
	}

	/**
	 * Gets whether this delegate is used to validate node instances (e.g.
	 * mandatory fields, etc.) as well as their child nodes.
	 * @return a boolean -true if this should be called to perform validation.
	 */
	this.isUsedToValidateNodes = function()
	{
		return false;
	}
	
	/**
	 * Dummy function stub so the interface requirements are met.
	 */
	this.validateNode = function(aNodeInstance, updateDisplay,
								 aValidationFailure)
	{
		cLog.error(this.className 
				   + ".validateNode(): this does not do validation.");
	}
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    if (this.formNode != null)
	    {
	    	buffer += "formNode.somExpression= " + this.formNode.somExpression;
	    }
	    else
	    {
	    	buffer += "formNode= null";
	    }
		buffer += "]";
		return buffer;
	}

	//===== PRIVATE ============================================================
	/**
	 * Gets the value of a country node. Issues a warning if the country node
	 * can't be found.
	 * @param aNode the Adobe Node instance that is being processed.
	 * @return the value of the related country node in this form.
	 */
	this._getCountry = function(aNode)
	{
		var countryNode = xfa.resolveNode(aNode.parent.somExpression + "."
										  + _getCountryNodeName());
				
		if (countryNode != null)
		{
    		return countryNode.rawValue;
		}
		cLog.info("ProvinceStateDelegate._getCountry couldn't find the country"
				  + " node for " + aNode.somExpression);
		return null;
	}
}

</script>
                  <script contentType="application/x-javascript" name="TelephoneDelegate">//
/*******************************************************************************
 * An object that responds to information requests sent to a telephone/fax
 * FormNode.
 *
 * Implements FormNodeDelegateInterface.
 */

//imports
var cLog = script.core.util.Log;

var _TELEPHONE_FORMAT_TYPE = "telephone";

/*******************************************************************************
 * Gets a new PostalZipDelegate. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * Note that this is only intended for use by FormNodeFactory. All instances
 * should be created by that class.
 * @return the new PostalZipDelegate instance
 */
function createInstance()
{
	return new TelephoneDelegateClass();
}

/**
 * Class implementation
 */
function TelephoneDelegateClass(somExpression)
{
	this.className = "TelephoneDelegate";

	this.formNode;

	/**
	 * Gets this node's default value, which is an internationalized value.
	 * This returns null since this uses a picklist.
	 * @param aNode the Adobe Node instance who's default value is required.
	 * @return a String that contains the internationalized default value for
	 *		   the passed Node. Null if this is not applicable.
	 */
    this.getDefaultValue = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets the type of format validation to be applied to data entered into
	 * this node in the UI.
	 * @param aNode the Adobe Node instance who's value must conform to a 
	 *		  specific format.
	 * @return a String that contains the type of format validation to be
	 *		   applied to data entered into this node in the UI. These must be
	 *		   types that are supported by the currently installed 
	 *		   FormatValidator. Null if this is not applicable.
	 */
    this.getFormatType = function(aNode)
    {
    	return _TELEPHONE_FORMAT_TYPE;
	}

	/**
	 * Gets this node's label to be displayed in the UI, which is an
	 * internationalized value.
	 * @param aNode the Adobe Node instance who's label is required.
	 * @return a String that contains the internationalized UI label for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getLabel = function(aNode)
    {
    	return null;
   	}

	/**
	 * Gets whether this node is mandatory (required).
	 * @param aNode the Adobe Node instance who's mandatory setting is required.
	 * @return a boolean - true if the country is Canada or the US, false if it
	 *		   is any other value, null if there was no node passed.
	 */
	this.isMandatory = function(aNode)
	{
		return null;
	}
		
	/**
	 * Gets a string that defines the pick list to be displayed in the UI for
	 * this node.
	 * @param aNode the Adobe Node instance who's pick list is required.
	 * @return a String that contains the definition of the pick list to be
	 *		   displayed in the UI for this node. The format is:
	 *		   "displayValue1, code1, displayValue2, code2...". Null if
	 *		   this is not applicable.
	 */
    this.getPickListValues = function(aNode)
    {
    	return null;
	}
		
	/**
	 * Gets this node's tool tip to be displayed in the UI, which is an
	 * internationalized value. In this case it is null, since these are
	 * dependant on the subform that the field is in (must be handled by the
	 * FormNode itself).
	 * @param aNode the Adobe Node instance who's tool tip is required.
	 * @return a String that contains the internationalized UI tool tip for the
	 *		   passed Node. Null if this is not applicable.
	 */
    this.getToolTip = function(aNode)
    {
    	return null;
	}

	/**
	 * Sets the FormNode that is using this delegate. It is mandatory that this
	 * is set to allow the delegate to access items in the FormNode as required.
	 * @param aFormNode the FormNode that is using this delegate.
	 */
    this.setFormNode = function(aFormNode)
    {
    	this.formNode = aFormNode;
	}

	/**
	 * Gets whether this delegate is used to validate node instances (e.g.
	 * mandatory fields, etc.) as well as their child nodes.
	 * @return a boolean -true if this should be called to perform validation.
	 */
	this.isUsedToValidateNodes = function()
	{
		return false;
	}
	
	/**
	 * Dummy function stub so the interface requirements are met.
	 */
	this.validateNode = function(aNodeInstance, updateDisplay,
								 aValidationFailure)
	{
		cLog.error(this.className 
				   + ".validateNode(): this does not do validation.");
	}
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
	    if (this.formNode != null)
	    {
	    	buffer += "formNode.somExpression= " + this.formNode.somExpression;
	    }
	    else
	    {
	    	buffer += "formNode= null";
	    }
		buffer += "]";
		return buffer;
	}
}
</script>
                  <?templateDesigner expand 1?></variables>
               <bind match="none"/>
               <?templateDesigner expand 1?></subform>
            <subform w="100mm" h="50mm" name="factory">
               <variables>
                  <script contentType="application/x-javascript" name="FormNodeFactory">//
/*******************************************************************************
 * A class used to create instances of FormNode. Used by FormNodeManager.
 */

//imports
var cException = script.core.util.Exception;
var cFormNode = script.core.model.FormNode;
var cTypeEnforcer = script.core.util.TypeEnforcer;

//formNodeValue map keys
var _DEFAULT_VALUE_KEY = "defaultValueKey";
var _DELEGATE = "delegate";
var _FIELD_NUMBER = "fieldNumber";
var _FORMAT_TYPE = "formatType";
var _LABEL_KEY = "labelKey";
var _MANDATORY_KEY = "mandatory";
var _PARENT_NODE_KEY = "parentNodeKey";
var _PICK_LIST_KEY = "pickListKey";
var _SOM_EXPRESSION_KEY = "somExpression";
var _TOOL_TIP_KEY = "toolTipKey";
var _VALIDATED_SEPARATELY_KEY = "validatedSeparately";

/**
 * Creates a FormNode from the passed map of values. Note that it will require
 * additional post-processing to populate its parent and children.
 * @param key a String that uniquely identifies the node.
 * @param formNodeValues a simple map of the node's property values.
 * @return a FormNode populated from the passed formNodeValues.
 * @throws an UnexpectedDataType Exception if this is not passed a simple map,
 *		   if the FormNode's SOM expression was not populated (this is required
 *		   for each node), or if any of the values are of the wrong type.
 */
function createFormNode(key, formNodeValues)
{
	cTypeEnforcer.checkString(key, "FormNodeFactory", "createFormNode", "key");
	cTypeEnforcer.checkSimpleMap(formNodeValues, "FormNodeFactory",
								 "createFormNode", "formNodeValues");

	var formNode = cFormNode.createInstance(key);

	//Required:
	formNode.setSomExpression(cTypeEnforcer.checkString(
			 formNodeValues[_SOM_EXPRESSION_KEY], "FormNodeFactory",
			 "createFormNode", "formNodeValues." + _SOM_EXPRESSION_KEY));

	if (formNodeValues[_DEFAULT_VALUE_KEY] != undefined)
	{
		formNode.setDefaultValueKey(cTypeEnforcer.checkString(
				 formNodeValues[_DEFAULT_VALUE_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _DEFAULT_VALUE_KEY));
	}

	if (formNodeValues[_DELEGATE] != undefined)
	{
		var delegateSom = formNodeValues[_DELEGATE];

		cTypeEnforcer.checkString(delegateSom, "FormNodeFactory", 
					  "createFormNode", "formNodeValues." + _DELEGATE);

		var delegateClass = xfa.resolveNode(delegateSom);

		if (delegateClass == null)
		{
			throw cException.createInstance(
				"FormNodeFactory.createFormNode(): delegate '" 
				+ delegateSom + "' cannot be resolved",
				"UnexpectedDataType");
		}
		cTypeEnforcer.checkCustomObjectFactory(delegateClass, "FormNodeFactory", 
					  "createFormNode", "formNodeValues." + _DELEGATE);
		formNode.setDelegate(delegateClass.createInstance());
	}

	if (formNodeValues[_FIELD_NUMBER] != undefined)
	{
		formNode.setFieldNumber(cTypeEnforcer.checkString(
				 formNodeValues[_FIELD_NUMBER], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _FIELD_NUMBER));
	}

	if (formNodeValues[_FORMAT_TYPE] != undefined)
	{
		formNode.setFormatType(cTypeEnforcer.checkString(
				 formNodeValues[_FORMAT_TYPE], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _FORMAT_TYPE));
	}

	if (formNodeValues[_LABEL_KEY] != undefined)
	{
		formNode.setLabelKey(cTypeEnforcer.checkString(
				 formNodeValues[_LABEL_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _LABEL_KEY));
	}

	if (formNodeValues[_MANDATORY_KEY] != undefined)
	{
		formNode.setMandatory(cTypeEnforcer.checkBoolean(
				 formNodeValues[_MANDATORY_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _MANDATORY_KEY));
	}

	if (formNodeValues[_PARENT_NODE_KEY] != undefined)
	{
		formNode.setParentNodeKey(cTypeEnforcer.checkString(
				 formNodeValues[_PARENT_NODE_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _PARENT_NODE_KEY));
	}

	if (formNodeValues[_PICK_LIST_KEY] != undefined)
	{
		formNode.setPickListKey(cTypeEnforcer.checkString(
				 formNodeValues[_PICK_LIST_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _PICK_LIST_KEY));
	}

	if (formNodeValues[_TOOL_TIP_KEY] != undefined)
	{
		formNode.setToolTipKey(cTypeEnforcer.checkString(
				 formNodeValues[_TOOL_TIP_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _TOOL_TIP_KEY));
	}

	if (formNodeValues[_VALIDATED_SEPARATELY_KEY] != undefined)
	{
		formNode.setValidatedSeparately(cTypeEnforcer.checkBoolean(
				 formNodeValues[_VALIDATED_SEPARATELY_KEY], "FormNodeFactory",
				 "createFormNode", "formNodeValues." + _VALIDATED_SEPARATELY_KEY));
	}

	return formNode;
}

</script>
                  <?templateDesigner expand 0?></variables>
               <bind match="none"/>
               <?templateDesigner expand 0?></subform>
            <bind match="none"/>
            <?templateDesigner expand 1?></subform>
         <subform w="100mm" h="50mm" name="resources">
            <variables>
               <script contentType="application/x-javascript" name="core_en">//
/*******************************************************************************
 * A resource class that contains all keys and values for labels and messages in
 * English.
 */

var content = { //Required to wrap entries

close: "Close",
date: "Date (yyyy-mm-dd)",
english: "English",
french: "Français",
listItem_empty: " ", //Used in picklists
listItem_userDefined: "---Text Entry", //Used as the default value in comboBoxes
mandatory: "* - denotes mandatory",
max: "Max",
min: "Min",
modify: "Modify",
no: "No",
numberAbbreviation: "No.",
print: "Print",
remove: "remove",
trackingNumber: "Tracking Number",
urlLanguageParameter: "&amp;lang=eng", //Appended to a URL call so the users language is respected
validate: "Validate",
version: "VERSION",
yes: "Yes",

//==============================================================================
//===== Geographic Items =======================================================
city: "City/Town",
country: "Country",
postalCode: "Postal Code",
postalZipCode: "Postal/ZIP Code",
province: "Province",
provinceState: "Province/State",
state: "State",
zipCode: "ZIP Code",
//===== Geographic Items =======================================================
//==============================================================================

//Error messages
error_badEmailFormat: "Improperly formatted email address(es).",
error_badPostalCodeFormat: "Improperly formatted postal code(s).",
error_badTelephoneFormat: "Improperly formatted telephone number(s).",
error_badZipCodeFormat: "Improperly formatted zip code(s).",
error_mandatoryCheckBoxSet: "At least one of the check boxes has to be checked.",
error_mandatoryField: "Some required fields have not been filled.",
error_networkDetail: "Network error ({1}) for operation '{2}': {3}.",
error_networkGeneric: "Network error for operation '{1}': {2}.",
error_soapDetail: "Error '{1}' for operation '{2}'; faultCode: {3}; faultActor: {4}; faultDetail: {5}.",
error_soapGeneric: "Call technical support: Error '{1}' for operation '{2}'; {3}.",
error_validationFailure: "Please correct the following errors:",
error_webServiceGeneric: "Problem encountered when calling the {1} WebService.",

//Messages
message_locked: "Sorry, this form is locked.",
message_saveAs: "This form has encountered a problem. To prevent data corruption, please save the form using a different file name and send it to our help desk at nhp_initiative_psn@hc-sc.gc.ca.",

//NOT SURE THESE SHOULD BE HERE ================================================
english_tip: "This is for English tip",
french_tip: "This is for French tip",
SURNAME: "ABC *",
YES: "Yes",
NO: "No",
NA: "N/A",

// for LTG
containsCamphor: "This product contains more than 2.5% camphor.",
containsEucalyptus: "This product contains more than 25% Eucalyptus oil.",
exceptSituation: "(except in situations that",
flameProj: "Flame Projection Length/Flashback:",
gltQce: "QCE",
ltEcw: "KEEP OUT OF REACH OF CHILDREN, NOT TO BE TAKEN ORALLY",
ltgDuration: "Use of this product beyond &lt;DURATION&gt; &lt;DURATION_UNIT&gt;(s) is not recommended.",
ltgImporterNoneChecked: "At least one importer must be selected.",
ltSecurity: "Security feature is self-evident.",
mercuryYes: "This product contains mercury (",
p5Vallbltxt: "You must validate the label text before you can continue",
preservatives: "as preservatives.",
productContains: "This product also contains",
productUses: "This product uses",
sterile: "Sterile",
validationFailed: "Label Text Validation failed",
validationNotDone: "Label Text Validation not yet completed",
validationSuccess: "Label Text Validation completed"

}
</script>
               <script contentType="application/x-javascript" name="core_fr">//
/*******************************************************************************
 * A resource class that contains all keys and values for labels and messages in
 * French.
 */

var content = { //Required to wrap entries

close: "Fermer",
date: "Date (aaaa-mm-jj)",
english: "English",
french: "Français",
listItem_empty: " ", //Used in picklists
listItem_userDefined: "---Entrée de texte", //Used as the default value in comboBoxes
mandatory: "* - indique obligatoire",
max: "Max",
min: "Min",
modify: "Modifier",
no: "Non",
numberAbbreviation: "No.",
print: "Imprimer",
remove: "enlever",
trackingNumber: "Numéro de suivi",
urlLanguageParameter: "&amp;lang=fra", //Appended to a URL call so the users language is respected
validate: "Valider",
version: "VERSION",
yes: "Oui",

//==============================================================================
//===== Geographic Items =======================================================
city: "Ville",
country: "Pays",
postalCode: "Code postal",
postalZipCode: "Code postal/code de zone",
province: "Province",
provinceState: "Province/état",
state: "État",
zipCode: "Code de zone",
//===== Geographic Items =======================================================
//==============================================================================

//Error messages
error_badEmailFormat: "Le format de l'adresse courriel est incorrect.",
error_badPostalCodeFormat: "Le(s) code(s) postal(aux) n'a(ont) pas le bon format.",
error_badTelephoneFormat: "Le(s) numéro(s) de téléphone n'a(ont) pas le bon format.",
error_badZipCodeFormat: "Le(s) code(s) de zone n'a(ont) pas le bon format.",
error_mandatoryCheckBoxSet: "Au moins une des boîtes doit être cochée.",
error_mandatoryField: "Certains champs requis n’ont pas été remplis.",
error_networkDetail: "Erreur de réseau ({1}) pour l'opération '{2}': {3}.",
error_networkGeneric: "Erreur de réseau pour l'opération '{1}': {2}.",
error_soapDetail: "Erreur '{1}' pour l'opération '{2}'; Code de faute: {3}; Acteur de faute: {4}; Détail de faute: {5}.",
error_soapGeneric: "Veuillez contacter votre support technique: Erreur '{1}' pour l'opération '{2}'; {3}.",
error_validationFailure: "Veuillez corriger les erreurs suivantes (en plus symbole indique une erreur de validation):",
error_webServiceGeneric: "Problème lors de l'appel du service web {1}.",

//Messages
message_locked: "Désolé, mais ce formulaire est verrouillé.",
message_saveAs: "Ce formulaire a eu un problème.  Pour prévenir une altération des données, veuillez sauvegarder le formulaire en utilisant un autre nom pour le fichier et l'envoyer à notre bureau de service à nhp_initiative_psn@hc-sc.gc.ca",

//NOT SURE THESE SHOULD BE HERE ================================================
english_tip: "This is for English tip",
french_tip: "This is for French tip",
SURNAME: "DEF *",
YES: "Oui",
NO: "Non",
NA: "N/D",

// for LTG
containsCamphor: "Ce produit contient plus de 2.5% de camphre",
containsEucalyptus: "Ce produit contient plus de 25% d'huile d'eucalyptus",
exceptSituation: "(sauf dans les situations où",
flameProj: "Longueur de la projection ou retour de la flamme:",
gltQce: "QBE",
ltEcw: "TENIR HORS DE PORTÉE DES ENFANTS, NE PAS INGÉRER PAR VOIE ORALE",
ltgDuration: "L'utilisation de ce produit pendant plus de &lt;DURATION&gt; &lt;DURATION_UNIT&gt;(s) n'est pas recommandé.",
ltgImporterNoneChecked: "Au moins un importateur devrait être sélectionné.",
ltSecurity: "Le dispositif de sécurité est évident par lui-même.",
mercuryYes: "Ce produit contient du mercure (",
p5Vallbltxt: "Vous devez valider le texte d'étiquette avant de pouvoir continuer",
preservatives: "comme agent de conservation",
productContains: "Ce produit contient aussi",
productUses: "Ce produit utilise",
sterile: "Stérile",
validationFailed: "Validation du texte d'étiquette échouée",
validationNotDone: "Validation du texte d'étiquette pas encore terminée",
validationSuccess: "Validation du texte d'étiquette terminée"

}
</script>
               <script contentType="application/x-javascript" name="pickLists_en">//
/*******************************************************************************
 * A resource class that contains all pick lists in English. These are all
 * Arrays of Arrays, where the outer Array contains all of the list items in the
 * order they are to be displayed. The inner Arrays define list items and
 * contain the codes with their display values.
 */

var content = { //Required to wrap entries

countryList:[
	["CA","Canada"]
	,["US","United States"]
	,["AF","Afghanistan"]
	,["AX","Aland Islands"]
	,["AL","Albania"]
	,["DZ","Algeria"]
	,["AS","American Samoa"]
	,["AD","Andorra"]
	,["AO","Angola"]
	,["AI","Anguilla"]
	,["AQ","Antarctica"]
	,["AG","Antigua and Barbuda"]
	,["AR","Argentina"]
	,["AM","Armenia"]
	,["AW","Aruba"]
	,["AU","Australia"]
	,["AT","Austria"]
	,["AZ","Azerbaijan"]
	,["BS","Bahamas"]
	,["BH","Bahrain"]
	,["BD","Bangladesh"]
	,["BB","Barbados"]
	,["BY","Belarus"]
	,["BE","Belgium"]
	,["BZ","Belize"]
	,["BJ","Benin"]
	,["BM","Bermuda"]
	,["BT","Bhutan"]
	,["BO","Bolivia"]
	,["BA","Bosnia and Herzegowina"]
	,["BW","Bostswana"]
	,["BV","Bouvet Island"]
	,["BR","Brazil"]
	,["IO","British Indian Ocean Territory"]
	,["BN","Brunei Darussalam"]
	,["BG","Bulgaria"]
	,["BF","Burkina Faso"]
	,["BI","Burundi"]
	,["KH","Cambodia"]
	,["CM","Cameroon"]
	,["CV","Cape Verde"]
	,["KY","Cayman Islands"]
	,["CF","Central African Republic"]
	,["TD","Chad"]
	,["CL","Chile"]
	,["CN","China"]
	,["CX","Christmas Island"]
	,["CC","Cocos (Keeling) Islands"]
	,["CO","Colombia"]
	,["KM","Comoros"]
	,["CG","Congo"]
	,["CD","Congo, the Democratic Republic of the"]
	,["CK","Cook Islands"]
	,["CR","Costa Rica"]
	,["CI","Cote d'lvoire"]
	,["HR","Croatia (Hrvatska)"]
	,["CU","Cuba"]
	,["CY","Cyprus"]
	,["CZ","Czech Republic"]
	,["DK","Denmark"]
	,["DJ","Djibouti"]
	,["DM","Dominica"]
	,["DO","Dominican Republic"]
	,["TP","East Timor"]
	,["EC","Ecuador"]
	,["EG","Egypt"]
	,["SV","El Salvador"]
	,["GQ","Equatorial Guinea"]
	,["ER","Eritrea"]
	,["EE","Estonia"]
	,["ET","Ethiopia"]
	,["FK","Falkland Islands (Malvinas)"]
	,["FO","Faroe Islands"]
	,["FJ","Fiji"]
	,["FI","Finland"]
	,["FR","France"]
	,["FX","France, Metropolitan"]
	,["GF","French Guiana"]
	,["PF","French Polynesia"]
	,["TF","French Southern Territories"]
	,["GA","Gabon"]
	,["GM","Gambia"]
	,["GE","Georgia"]
	,["DE","Germany"]
	,["GH","Ghana"]
	,["GI","Gibraltar"]
	,["GR","Greece"]
	,["GL","Greenland"]
	,["GD","Grenada"]
	,["GP","Guadeloupe"]
	,["GU","Guam"]
	,["GT","Guatemala"]
	,["GN","Guinea"]
	,["GW","Guinea-Bissau"]
	,["GY","Guyana"]
	,["HT","Haiti"]
	,["HM","Heard and McDonald Islands"]
	,["VA","Holy See (Vatican City State)"]
	,["HN","Honduras"]
	,["HK","Hong Kong"]
	,["HU","Hungary"]
	,["IS","Iceland"]
	,["IN","India"]
	,["ID","Indonesia"]
	,["IR","Iran (Islamic Republic of)"]
	,["IQ","Iraq"]
	,["IE","Ireland"]
	,["IL","Israel"]
	,["IT","Italy"]
	,["JM","Jamaica"]
	,["JP","Japan"]
	,["JO","Jordan"]
	,["KZ","Kazakhstan"]
	,["KE","Kenya"]
	,["KI","Kiribati"]
	,["KP","Korea, Democratic People's Republic of"]
	,["KR","Korea, Republic of"]
	,["KW","Kuwait"]
	,["KG","Kyrgyzstan"]
	,["LA","Lao People's Democratic Republic"]
	,["LV","Latvia"]
	,["LB","Lebanon"]
	,["LS","Lesotho"]
	,["LR","Liberia"]
	,["LY","Libyan Arab Jamahiriya"]
	,["LI","Liechtenstein"]
	,["LT","Lithuania"]
	,["LU","Luxembourg"]
	,["MO","Macau"]
	,["MK","Macedonia, The Former Yugoslav Republic of"]
	,["MG","Madagascar"]
	,["MW","Malawi"]
	,["MY","Malaysia"]
	,["MV","Maldives"]
	,["ML","Mali"]
	,["MT","Malta"]
	,["MH","Marshall Islands"]
	,["MQ","Martinique"]
	,["MR","Mauritania"]
	,["MU","Mauritius"]
	,["YT","Mayotte"]
	,["MX","Mexico"]
	,["FM","Micronesia, Federated States of"]
	,["MD","Moldova, Republic of"]
	,["MC","Monaco"]
	,["MN","Mongolia"]
	,["MS","Montserrat"]
	,["MA","Morocco"]
	,["MZ","Mozambique"]
	,["MM","Myanmar"]
	,["NA","Namibia"]
	,["NR","Nauru"]
	,["NP","Nepal"]
	,["NL","Netherlands"]
	,["AN","Netherlands Antilles"]
	,["NC","New Caledonia"]
	,["NZ","New Zealand"]
	,["NI","Nicaragua"]
	,["NE","Niger"]
	,["NG","Nigeria"]
	,["NU","Niue"]
	,["NF","Norfolk Island"]
	,["MP","Northern Mariana Islands"]
	,["NO","Norway"]
	,["OM","Oman"]
	,["PK","Pakistan"]
	,["PW","Palau"]
	,["PA","Panama"]
	,["PG","Papua New Guinea"]
	,["PY","Paraguay"]
	,["PE","Peru"]
	,["PH","Philippines"]
	,["PN","Pitcairn"]
	,["PL","Poland"]
	,["PT","Portugal"]
	,["PR","Puerto Ricco"]
	,["QA","Qatar"]
	,["RE","Reunion"]
	,["RO","Romania"]
	,["RU","Russian Federation"]
	,["RW","Rwanda"]
	,["KN","Saint Kitts and Nevis"]
	,["LC","Saint Lucia"]
	,["VC","Saint Vincent and the Grenadines"]
	,["WS","Samoa"]
	,["SM","San Marino"]
	,["ST","Sao Tome and Principe"]
	,["SA","Saudi Arabia"]
	,["SN","Senegal"]
	,["SC","Seychelles"]
	,["SL","Sierra Leone"]
	,["SG","Singapore"]
	,["SK","Slovakia (Slovak Republic)"]
	,["SI","Slovenia"]
	,["SB","Solomon Islands"]
	,["SO","Somalia"]
	,["ZA","South Africa"]
	,["GS","South Georgia and the South Sandwich Islands"]
	,["ES","Spain"]
	,["LK","Sri Lanka"]
	,["SH","St. Helena"]
	,["PM","St. Pierre and Miquelon"]
	,["SD","Sudan"]
	,["SR","Suriname"]
	,["SJ","Svalbard and Jan Mayen Islands"]
	,["SZ","Swaziland"]
	,["SE","Sweden"]
	,["CH","Switzerland"]
	,["SY","Syrian Arab Republic"]
	,["TW","Taiwan, Province of China"]
	,["TJ","Tajikistan"]
	,["TZ","Tanzania, United Republic of"]
	,["TH","Thailand"]
	,["TG","Togo"]
	,["TK","Tokelau"]
	,["TO","Tonga"]
	,["TT","Trinidad and Tobago"]
	,["TN","Tunisia"]
	,["TR","Turkey"]
	,["TM","Turkmenistan"]
	,["TC","Turks and Caicos Islands"]
	,["TV","Tuvalu"]
	,["UG","Uganda"]
	,["UA","Ukraine"]
	,["AE","United Arab Emirates"]
	,["GB","United Kingdom"]
	,["UM","United States Minor Outlying Islands"]
	,["UY","Uruguay"]
	,["UZ","Uzbekistan"]
	,["VU","Vanuatu"]
	,["VE","Venezuela"]
	,["VN","Viet Nam"]
	,["VG","Virgin Islands (British)"]
	,["VI","Virgin Islands (U.S.)"]
	,["WF","Wallis and Futuna Islands"]
	,["EH","Western Sahara"]
	,["YE","Yemen"]
	,["YU","Yugoslavia"]
	,["ZM","Zambia"]
	,["ZW","Zimbabwe"]], 

languageList:[
	["en", "English"],
	["fr", "French"]],

provinceList:[
	["AB","Alberta"],
	["BC","British Columbia"],
	["MB","Manitoba"],
	["NB","New Brunswick"],
	["NL","Newfoundland and Labrador"],
	["NT","Northwest Territories"],
	["NS","Nova Scotia"],
	["NU","Nunavut"],
	["ON","Ontario"],
	["PE","Prince Edward Island"],
	["QC","Quebec"],
	["SK","Saskatchewan"],
	["YT","Yukon"]],

salutationList:[
	["mr", "Mr."],
	["ms", "Ms."],
	["dr","Dr."]],

stateList:[
	["AL","Alabama"],
	["AK","Alaska"],
	["AZ","Arizona"],
	["AR","Arkansas"],
	["CA","California"],
	["CO","Colorado"],
	["CT","Connecticut"],
	["DE","Delaware"],
	["DC","District of Columbia"],
	["FL","Florida"],
	["GA","Georgia"],
	["HI","Hawaii"],
	["ID","Idaho"],
	["IL","Illinois"],
	["IN","Indiana"],
	["IA","Iowa"],
	["KS","Kansas"],
	["KY","Kentucky"],
	["LA","Louisiana"],
	["ME","Maine"],
	["MD","Maryland"],
	["MA","Massachusetts"],
	["MI","Michigan"],
	["MN","Minnesota"],
	["MS","Mississippi"],
	["MO","Missouri"],
	["MT","Montana"],
	["NE","Nebraska"],
	["NV","Nevada"],
	["NH","New Hampshire"],
	["NJ","New Jersey"],
	["NM","New Mexico"],
	["NY","New York"],
	["NC","North Carolina"],
	["ND","North Dakota"],
	["OH","Ohio"],
	["OK","Oklahoma"],
	["OR","Oregon"],
	["PA","Pennsylvania"],
	["RI","Rhode Island"],
	["SC","South Carolina"],
	["SD","South Dakota"],
	["TN","Tennessee"],
	["TX","Texas"],
	["UT","Utah"],
	["VT","Vermont"],
	["VA","Virginia"],
	["WA","Washington"],
	["WV","West Virginia"],
	["WI","Wisconsin"],
	["WY","Wyoming"]],

yesNoList:[
	["Yes", "Yes"],
	["No", "No"]]

}
</script>
               <script contentType="application/x-javascript" name="pickLists_fr">//
/*******************************************************************************
 * A resource class that contains all pick lists in French. These are all
 * Arrays of Arrays, where the outer Array contains all of the list items in the
 * order they are to be displayed. The inner Arrays define list items and
 * contain the codes with their display values.
 */

var content = { //Required to wrap entries

countryList:[
	["CA","Canada"]
	,["US","États-Unis"]
	,["AF","Afghanistan"]
	,["ZA","Afrique du Sud"]
	,["AL","Albanie"]
	,["DZ","Algérie"]
	,["DE","Allemagne"]
	,["AD","Andorre"]
	,["AO","Angola"]
	,["AI","Anguilla"]
	,["AQ","Antarctique"]
	,["AG","Antigua-et-Barbuda"]
	,["AN","Antilles néerlandaises"]
	,["SA","Arabie saoudite"]
	,["AR","Argentine"]
	,["AM","Arménie"]
	,["AW","Aruba"]
	,["AU","Australie"]
	,["AT","Autriche"]
	,["AZ","Azerbaïdjan"]
	,["BS","Bahamas"]
	,["BH","Bahreïn"]
	,["BD","Bangladesh"]
	,["BB","Barbade"]
	,["BY","Bélarus"]
	,["BE","Belgique"]
	,["BZ","Belize"]
	,["BJ","Bénin"]
	,["BM","Bermudes"]
	,["BT","Bhoutan"]
	,["BO","Bolivie"]
	,["BA","Bosnie-Herzégovine"]
	,["BW","Botswana"]
	,["BR","Brésil"]
	,["BN","Brunei Darussalam"]
	,["BG","Bulgarie"]
	,["BF","Burkina Faso"]
	,["BI","Burundi"]
	,["KH","Cambodge"]
	,["CM","Cameroun"]
	,["CV","Cap-Vert"]
	,["CL","Chili"]
	,["CN","Chine"]
	,["CY","Chypre"]
	,["CO","Colombie"]
	,["CG","Congo"]
	,["CD","Congo (République démocratique du)"]
	,["KP","Corée (République populaire démocratique de) "]
	,["CR","Costa Rica"]
	,["CI","Côte d'lvoire"]
	,["HR","Croatie  (Hrvatska)"]
	,["CU","Cuba"]
	,["DK","Danemark"]
	,["DJ","Djibouti"]
	,["DM","Dominique"]
	,["EG","Égypte"]
	,["SV","El Salvador"]
	,["AE","Émirats arabes unis"]
	,["EC","Équateur"]
	,["ER","Érythrée"]
	,["ES","Espagne"]
	,["EE","Estonie"]
	,["ET","Éthiopie"]
	,["FO","Faroe Islands"]
	,["RU","Fédération de Russie"]
	,["FJ","Fidji"]
	,["FI","Finlande"]
	,["FR","France"]
	,["FX","France métropolitaine"]
	,["GA","Gabon"]
	,["GM","Gambie"]
	,["GE","Géorgie"]
	,["GS","Géorgie du Sud-et-les Îles Sandwich du Sud"]
	,["GH","Ghana"]
	,["GI","Gibraltar"]
	,["GR","Grèce"]
	,["GD","Grenade"]
	,["GL","Groenland"]
	,["GP","Guadeloupe"]
	,["GU","Guam"]
	,["GT","Guatemala"]
	,["GN","Guinée"]
	,["GQ","Guinée équatoriale"]
	,["GW","Guinée-Bissau"]
	,["GY","Guyana"]
	,["GF","Guyane française"]
	,["HT","Haïti"]
	,["HN","Honduras"]
	,["HK","Hong Kong"]
	,["HU","Hongrie"]
	,["BV","Île Bouvet"]
	,["CX","Île Christmas"]
	,["PM","Île de St-Pierre et Miquelon"]
	,["NF","Île Norfolk"]
	,["KY","Îles Caïmans"]
	,["CC","Îles Cocos (Keeling)"]
	,["KM","Îles Comores"]
	,["CK","Îles Cook"]
	,["FK","Îles Flakland (Malouines)"]
	,["HM","Îles Heard et McDonald"]
	,["MP","Îles Mariannes du Nord"]
	,["MH","Îles Marshall"]
	,["SB","Îles Salomon"]
	,["SJ","Îles Svalbard et Jan Mayen"]
	,["TC","Îles Turks et Caicos"]
	,["VI","Îles Vierges (américaines)"]
	,["VG","Îles Vierges (britanniques)"]
	,["WF","Îles Wallis-et-Futuna"]
	,["IN","Inde"]
	,["ID","Indonésie"]
	,["IR","Iran (République islamique d')"]
	,["IQ","Iraq"]
	,["IE","Irlande"]
	,["IS","Islande"]
	,["IL","Israël"]
	,["IT","Italie"]
	,["AX","Îles Åland"]
	,["JM","Jamaïque"]
	,["JP","Japon"]
	,["JO","Jourdain"]
	,["KZ","Kazakhstan"]
	,["KE","Kenya"]
	,["KG","Kirghizistan"]
	,["KI","Kiribati"]
	,["KW","Koweit"]
	,["LA","Laos (République démocratique populaire du)"]
	,["LS","Lesotho"]
	,["LV","Lettonie"]
	,["LB","Liban"]
	,["LR","Libéria"]
	,["LY","Libye (Jamahiriya arabe libyenne)"]
	,["LI","Liechtenstein"]
	,["LT","Lituanie"]
	,["LU","Luxembourg"]
	,["MO","Macao"]
	,["MK","Macédoine (Ancienne République yougoslave de)  "]
	,["MG","Madagascar"]
	,["MY","Malaisie"]
	,["MW","Malawi"]
	,["MV","Maldives"]
	,["ML","Mali"]
	,["MT","Malte"]
	,["MA","Maroc"]
	,["MQ","Martinique"]
	,["MU","Maurice"]
	,["MR","Mauritanie"]
	,["YT","Mayotte"]
	,["MX","Mexique"]
	,["FM","Micronésie (États fédérés de)"]
	,["MD","Moldova (République de) "]
	,["MC","Monaco"]
	,["MN","Mongolie"]
	,["MS","Montserrat"]
	,["MZ","Mozambique"]
	,["MM","Myanmar"]
	,["NA","Namibie"]
	,["NR","Nauru"]
	,["NP","Népal"]
	,["NI","Nicaragua"]
	,["NE","Niger"]
	,["NG","Nigeria"]
	,["NU","Nioué"]
	,["NO","Norvège"]
	,["NC","Nouvelle-Calédonie"]
	,["NZ","Nouvelle-Zélande"]
	,["OM","Oman"]
	,["UG","Ouganda"]
	,["UZ","Ouzbékistan"]
	,["PK","Pakistan"]
	,["PW","Palaos"]
	,["PA","Panama"]
	,["PG","Papouasie-Nouvelle-Guinée"]
	,["PY","Paraguay"]
	,["NL","Pays-Bas"]
	,["PE","Pérou"]
	,["UM","Petites îles excentriques des États-Unis"]
	,["PH","Philippines"]
	,["PN","Pitcairn"]
	,["PL","Pologne"]
	,["PF","Polynésie française "]
	,["PT","Portugal"]
	,["PR","Puerto Rico"]
	,["QA","Qatar"]
	,["SY","République arabe syrienne"]
	,["CF","République centrafricaine"]
	,["KR","République de Corée"]
	,["DO","République dominicaine"]
	,["CZ","République tchèque"]
	,["RE","Réunion"]
	,["RO","Roumanie"]
	,["GB","Royaume-Uni"]
	,["RW","Rwanda"]
	,["EH","Sahara-Occidental"]
	,["SH","Sainte-Hélène"]
	,["LC","Sainte-Lucie"]
	,["KN","Saint-Kitts-et-Nevis"]
	,["SM","Saint-Marin"]
	,["VA","Saint-Siège (État de la Cité du Vatican)"]
	,["VC","Saint-Vincent-et-les Grenadines"]
	,["WS","Samoa"]
	,["AS","Samoa Américaines"]
	,["ST","Sao Tomé-et-Principe"]
	,["SN","Sénégal"]
	,["SC","Seychelles"]
	,["SL","Sierra Leone"]
	,["SG","Singapour"]
	,["SK","Slovaquie (République slovaque)"]
	,["SI","Slovénie"]
	,["SO","Somalie"]
	,["SD","Soudan"]
	,["LK","Sri Lanka"]
	,["SE","Suède"]
	,["CH","Suisse"]
	,["SR","Suriname"]
	,["SZ","Swaziland"]
	,["TW","Taïwan (République de Chine)"]
	,["TJ","Tajikistan"]
	,["TZ","Tanzanie (République-Unie de)"]
	,["TD","Tchad"]
	,["TF","Terres australes françaises"]
	,["IO","Territoire britannique de l'océan Indien"]
	,["TH","Thaïlande "]
	,["TP","Timor-Oriental"]
	,["TG","Togo"]
	,["TK","Tokelau"]
	,["TO","Tonga"]
	,["TT","Trinité-et-Tobago"]
	,["TN","Tunisie"]
	,["TM","Turkménistan"]
	,["TR","Turquie"]
	,["TV","Tuvalu"]
	,["UA","Ukraine"]
	,["UY","Uruguay"]
	,["VU","Vanuatu"]
	,["VE","Vénézuéla"]
	,["VN","Vietnam"]
	,["YE","Yémen"]
	,["YU","Yougoslavie"]
	,["ZM","Zambie"]
	,["ZW","Zimbabwe"]],

languageList:[
	["en", "Anglais"],
	["fr", "Français"]],

provinceList:[
	["AB","Alberta"],
	["BC","Colombie-Britannique"],
	["PE","Île-du-Prince-Édouard"],
	["MB","Manitoba"],
	["NB","Nouveau-Brunswick"],
	["NS","Nouvelle-Écosse"],
	["NU","Nunavut"],
	["ON","Ontario"],
	["QC","Québec"],
	["SK","Saskatchewan"],
	["NL","Terre-Neuve et Labrador"],
	["NT","Territoires du Nord-Ouest"],
	["YT","Yukon"]],

salutationList:[
	["mr", "M."],
	["ms", "Mme"],
	["dr","Dr"]],

stateList:[
	["AL","Alabama"],
	["AK","Alaska"],
	["AZ","Arizona"],
	["AR","Arkansas"],
	["CA","Californie"],
	["NC","Caroline du nord"],
	["SC","Caroline du sud"],
	["CO","Colorado"],
	["CT","Connecticut"],
	["ND","Dakota du nord"],
	["SD","Dakota du sud"],
	["DE","Delaware"],
	["DC","District de Columbia"],
	["FL","Floride"],
	["GA","Géorgie"],
	["HI","Hawaii"],
	["ID","Idaho"],
	["IL","Illinois"],
	["IN","Indiana"],
	["IA","Iowa"],
	["KS","Kansas"],
	["KY","Kentucky"],
	["NY","L'état de New York"],
	["WA","L'état de washington"],
	["LA","Louisiane"],
	["ME","Maine"],
	["MD","Maryland"],
	["MA","Massachusetts"],
	["MI","Michigan"],
	["MN","Minnesota"],
	["MS","Mississippi"],
	["MO","Missouri"],
	["MT","Montana"],
	["NE","Nebraska"],
	["NV","Nevada"],
	["NH","New Hampshire"],
	["NJ","New Jersey"],
	["NM","Nouveau-mexique"],
	["OH","Ohio"],
	["OK","Oklahoma"],
	["OR","Oregon"],
	["PA","Pennsylvanie"],
	["RI","Rhode Island"],
	["TN","Tennessee"],
	["TX","Texas"],
	["UT","Utah"],
	["VT","Vermont"],
	["VA","Virginie"],
	["WV","Virginie-occidentale"],
	["WI","Wisconsin"],
	["WY","Wyoming"]],

yesNoList:[
	["Yes", "Oui"],
	["No", "Non"]]

}
</script>
               <?templateDesigner expand 1?></variables>
            <bind match="none"/>
            <?templateDesigner expand 1?></subform>
         <subform w="100mm" h="50mm" name="service">
            <variables>
               <script contentType="application/x-javascript" name="ObjectCache">//
/*******************************************************************************
 * A cache used by domain object factories to minimize memory requirements. When
 * loading complex objects, they should use this to store all shared child
 * objects that may appear in the resulting object graph multiple times. They
 * can then use it to have all references point to the same instance rather than
 * filling memory with copies each time they appear in SOAP responses.
 *
 * Note that this should be cleared after the complex objects have been populated
 * to free the used memory.
 */

//imports
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cMap = script.core.util.Map;
var cObjectUtil = script.core.util.ObjectUtil;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var _DELIMETER = "|";
var content = null;

/**
 * Clears all of the entries from this cache.
 */
function clear()
{
	content = null;
}

/**
 * Gets whether this cache contains the specified object instance.
 * @param objectType a String that contains the name / type of the object of
 *		  interest.
 * @param uniqueIdentifier a String that contains the unique identifier / code
 *		  of the instance.
 * @return a boolean - true if this cache contains an entry for the above
 *		   values.
 * @throws an UnexpectedDataType Exception if objectType or uniqueIdentifier is
 *		   undefined, null, or isn't a valid string.
 */
function containsObject(objectType, uniqueIdentifier)
{
	cTypeEnforcer.checkString(objectType, "ObjectCache", "containsObject",
							  "objectType");
	cTypeEnforcer.checkString(uniqueIdentifier, "ObjectCache", "containsObject",
							  "uniqueIdentifier");

	return _getContent().containsKey(objectType + _DELIMETER + uniqueIdentifier);
}

/**
 * Gets an object instance from this cache.
 * @param objectType a String that contains the name / type of the requested
 *		  object.
 * @param uniqueIdentifier a String that contains the unique identifier / code
 *		  of the instance.
 * @return the object instance with the above values.
 * @throws an UnexpectedDataType Exception if objectType or uniqueIdentifier is
 *		   undefined, null, or isn't a valid string.
 */
function getObject(objectType, uniqueIdentifier)
{
	cTypeEnforcer.checkString(objectType, "ObjectCache", "getObject",
							  "objectType");
	cTypeEnforcer.checkString(uniqueIdentifier, "ObjectCache", "getObject",
							  "uniqueIdentifier");

	return _getContent().get(objectType + _DELIMETER + uniqueIdentifier);
}
	
/**
 * Saves an object instance into this cache.
 * @param objectType a String that contains the name / type of the object.
 * @param uniqueIdentifier a String that contains the unique identifier / code
 *		  of the instance.
 * @param anObject the object instance to be saved.
 * @return the previous object instance associated with specified objectType and
 *		   uniqueIdentifier, or null if there was none.
 * @throws an UnexpectedDataType Exception if objectType or uniqueIdentifier is
 *		   undefined, null, or isn't a valid string, or if anObject is undefined
 *		   or null.
 */
function putObject(objectType, uniqueIdentifier, anObject)
{
	cTypeEnforcer.checkString(objectType, "ObjectCache", "putObject",
							  "objectType");
	cTypeEnforcer.checkString(uniqueIdentifier, "ObjectCache", "putObject",
							  "uniqueIdentifier");
	if (anObject == undefined)
	{
		throw cException.createInstance(
			  "ObjectCache.putObject(): anObject cannot be undefined or null",
			  "UnexpectedDataType");
	}

	return _getContent().put(objectType + _DELIMETER + uniqueIdentifier,
							 anObject);
}
	
/**
 * Lists the entries.
 * @return the entries.
 */
function asString()
{
	var buffer = "ObjectCache[\n";
	var isFirst = true;
	var keys = _getContent().keySet();
	
    for (var i=0; i &lt; keys.length; i++)
    {
	    if (isFirst)
	    {
			isFirst = false;
	    }
	    else
	    {
			buffer += ",\n";
	    }
		buffer += keys[i] + "= " + cObjectUtil.asString(_getContent().get(keys[i]));
    }    	
	buffer += "]";
	return buffer;
}

//===== PRIVATE ================================================================

/**
 * Gets the content map that stores all of the object instances. This is lazy
 * loaded.
 * @return the content map that stores all of the object instances.
 */
function _getContent()
{
	if (content == null)
	{
		content = cMap.createInstance();
	}
	return content;
}
</script>
               <script contentType="application/x-javascript" name="SoapResponse">//
//TODO What does a single complex object return look like?
/*******************************************************************************
 * This object contains the information returned from a WebService function
 * call. It provides functions that simplify extracting data from the returned
 * structure.
 * 
 * This supports responses that use 1 of the 3 following patterns:
 *
 * 1) Responses that contain a single value:
 * These use the "Base Result Accessor" methods to retrieve that value.
 * For example, getStringResult("testValue") will return the value of the
 * response if it is a string. If it isn't a string, it will throw an exception
 * stating that testValue should have been a string but wasn't.
 *
 * 2) Responses that contain multiple values:
 * These use the "Result Property Accessor" methods to retrieve those values.
 * For example, getStringResultByName("testValue") will return the value from
 * the response that is titled testValue if it is a string. If it isn't a string,
 * it will throw an exception stating that testValue should have been a string
 * but wasn't.
 *
 * Note that the above patterns expect a single response object and will throw
 * an exception if more than one is returned.
 *
 * 3) Responses that contain complex objects:
 * These first use getResponseValues() to retrieve an array of the base object
 * definition(s), then use the "Object Property Accessor" methods to retrieve
 * their individual property values.
 * For example, var testObjects = getResponseValues() retrieves the base object
 * definitions. Each array entry represents an object. These are, in fact,
 * arrays of their properties. Loop through the main array, putting each entry
 * into a variable "testObject". You can then retrieve its properties as follows:
 * getStringPropertyByName("testProperty", "aTestObject", testObject)
 * This will return the testProperty value from the testObject if it is a string.
 * If it isn't a string, it will throw an exception stating that
 * aTestObject.testValue should have been a string but wasn't.
 *
 * Note that this has been written with NHPD's Web Services in mind and may
 * require additional generalization to make it compatible with other Web
 * Services.
 */

//imports
var cDateUtil = script.core.util.DateUtil;
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cObjectUtil = script.core.util.ObjectUtil;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new SoapResponse. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * @param response an array that contains the response from a web service call
 *		  made through Adobe's SOAP functions.
 */
function createInstance(response)
{
	return new SoapResponseClass(response);
}

/**
 * Class implementation
 */
function SoapResponseClass(response)
{
	this.className = "SoapResponse";

	this.responseName;
	this.responseValues = new Array();
	this.singleResponseBase;
	
	/**
	 * Gets whether there is a single value at the base of this response.
	 * @return a boolean that contains thrue if there is a single value at the
	 *		   base of this response.
	 */
	this.hasSingleResponse = function()
	{
		return this.responseValues != null 
			   &amp;&amp; this.responseValues.length == 1;
	}
	
	/**
	 * Gets the name of this response.
	 * @return a string that contains the name of this response.
	 */
	this.getResponseName = function()
	{
		return this.responseName;
	}
	
	/**
	 * Gets the base value in this response when there should only be one. This
	 * is used as a starting point when processing object structures to get the
	 * object at the base of the response. This will return an array that can
	 * be used as a source for that object's property accessors.
	 * @return an array of this response's base value's properties. Returns
	 *		   null if no value was returned.
	 * @throws OutOfBounds Exception if more than one base value is found in
	 *		   the response.
	 */
	this.getResponseValue = function()
	{
		if (this.responseValues.length == 1)
		{
			return this.responseValues[0];
		}
		if(this.responseValues.length &gt; 1)
		{
			var message = "SoapResponse.getResponseValue(): "
						  + this.responseValues.length 
						  + " values were found when only one was expected.";
						  
			throw cException.createInstance(message, "OutOfBounds");
		}

		return null;
	}
		
	/**
	 * Gets the array of base values in this response. This is used as a
	 * starting point when processing object structures to get the object(s)
	 * at the base of the response. This will return an array of arrays that can
	 * be used as sources for the object property accessors.
	 * @return an array of base values in this response. Returns an empty Array
	 *		   if no values were returned.
	 */
	this.getResponseValues = function()
	{
		return this.responseValues;
	}

	//===== Base Result Accessors ==============================================

	/**
	 * Gets the data in this response as an Array. This is used if the response
	 * is intended to return a collection of objects. In that case, this will
	 * return an Array of Arrays (each one contains the property values for one
	 * of the objects).
	 * @param objectType a string that contains the type of objects this is to
	 *		  populate (for exception reporting).
	 * @param allowNull (optional) a boolean that contains true if this should
	 *		  allow an undefined or null value without throwing an exception.
	 *		  Defaults to false.
	 * @return the returned value as an Array. When allowNull is true, this
	 *		   returns an empty Array when the returned value is undefined
	 *		   or null.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid Array.
	 */
	this.getArrayResult = function(objectType, allowNull)
	{
		return cTypeEnforcer.checkArray(this._getSingleResponseBase("getArrayResult"),
			   "SoapResponse", "getArrayResult", objectType, allowNull);
	}
		
	/**
	 * Gets the data in this response as a boolean. This is used if the response
	 * is intended to return a single response value of this data type.
	 * @param propertyName a string that contains the name of the property this
	 *		  is to populate (for exception reporting).
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the returned boolean or null if allowNull is true. Strings and
	 *		   numbers are coerced using StringUtil and NumberUtil as required.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't able to be safely converted to a
	 *		   boolean.
	 */
	this.getBooleanResult = function(propertyName, allowNull)
	{
		var result = this._getSingleResponseBase("getBooleanResult");	

		if (result == null &amp;&amp; allowNull)
		{
			return result;
		}
		return cTypeEnforcer.checkBoolean(result, "SoapResponse",
			   "getBooleanResult", propertyName, allowNull, true);
	}
			
	/**
	 * Gets the data in this response as a Date. This is used if the response
	 * is intended to return a single response value of this data type.
	 * @param propertyName a string that contains the name of the property this
	 *		  is to populate (for exception reporting).
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the returned date or null if allowNull is true.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid Date.
	 */
	this.getDateResult = function(propertyName, allowNull)
	{
		var stringResult = this._getSingleResponseBase("getDateResult");	

		cTypeEnforcer.checkString(stringResult, "SoapResponse", "getDateResult",
								  propertyName, allowNull);
		if (stringResult != null)
		{
			try
			{
				return cDateUtil.parseIso8601Date(stringResult);
			}
			catch (exception)
			{
				throw cException.createInstance("SoapResponse.getDateResult("
					  + propertyName + ") encountered a problem: " + exception,
					  "UnexpectedDataType");
			}
		}
		return null;
	}
			
	/**
	 * Gets the data in this response as a number. This is used if the response
	 * is intended to return a single response value of this data type.
	 * @param propertyName a string that contains the name of the property this
	 *		  is to populate (for exception reporting).
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the returned value as a number primitive or null if allowNull is
	 *		   true. Note that this only uses basic JavaScript coersion to
	 *		   create the number.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid number.
	 */
	this.getNumericResult = function(propertyName, allowNull)
	{
		var result = this._getSingleResponseBase("getNumericResult");	

		if (result == null &amp;&amp; allowNull)
		{
			return result;
		}
		return cTypeEnforcer.checkNumber(result, "SoapResponse",
			   "getNumericResult", propertyName, allowNull);
	}
		
	/**
	 * Gets the data in this response as a String. This is used if the response
	 * is intended to return a single response value of this data type.
	 * @param propertyName a string that contains the name of the property this
	 *		  is to populate (for exception reporting).
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the returned value as a string or null if allowNull is true.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid string.
	 */
	this.getStringResult = function(propertyName, allowNull)
	{
		var result = this._getSingleResponseBase("getStringResult");	

		cTypeEnforcer.checkString(result, "SoapResponse", "getStringResult",
								  propertyName, allowNull);
		return result;
	}

	//===== Object Property Accessors ==========================================

	/**
	 * Gets the values of the named nodes from this response as an Array. This
	 * is used to retrieve individual object property values from the response
	 * when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @param objectName a string that contains the type of object this
	 *		  property is for (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the object in the response.
	 * @return the value of all of the nodes with the same name as an Array.
	 *		   Returns an empty Array if none are found.
	 */
	this.getArrayPropertyByName = function(propertyName, objectName, source)
	{
		return this._getNodeValuesByName(propertyName, source);
   	}
   		
	/**
	 * Gets the value of the named node from this response as a boolean. This is
	 * used to retrieve individual object property values from the response
	 * when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @param objectName a string that contains the type of object this
	 *		  property is for (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the object in the response.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as a boolean or null if allowNull is
	 *		   true. Strings and numbers are coerced using StringUtil and
	 *		   NumberUtil as required.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't able to be safely converted to a
	 *		   boolean.
	 */
	this.getBooleanPropertyByName = function(propertyName, objectName, source,
											 allowNull)
	{
		var result = this._getNodeValueByName(propertyName, objectName, source);	

		if (result == null &amp;&amp; allowNull)
		{
			return result;
		}
		return cTypeEnforcer.checkBoolean(result, "SoapResponse",
			   "getBooleanPropertyByName", objectName + "." + propertyName,
			   allowNull, true);
   	}
   		
	/**
	 * Gets the value of the named node from this response as a Date. This is
	 * used to retrieve individual object property values from the response
	 * when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @param objectName a string that contains the type of object this
	 *		  property is for (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the object in the response.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as a Date or null if allowNull is true.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid boolean.
	 */
	this.getDatePropertyByName = function(propertyName, objectName, source,
										  allowNull)
	{
		var stringResult = this._getNodeValueByName(propertyName, objectName,
													source);	

		cTypeEnforcer.checkString(stringResult, "SoapResponse",
			"getDatePropertyByName", objectName + "." + propertyName, allowNull);
		if (stringResult != null)
		{
			try
			{
				return cDateUtil.parseIso8601Date(stringResult);
			}
			catch (exception)
			{
				throw cException.createInstance("SoapResponse.getDatePropertyByName("
					  + objectName + "." + propertyName + ") encountered a problem: "
					  + exception, "UnexpectedDataType");
			}
		}
		return null;
   	}
   		   		
	/**
	 * Gets the value of the named node from this response as a number. This is
	 * used to retrieve individual object property values from the response
	 * when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @param objectName a string that contains the type of object this
	 *		  property is for (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the object in the response.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as as a number primitive or null if
	 *		   allowNull is true. Note that this only uses basic JavaScript
	 *		   coersion to create the number.
 	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid number.
	 */
	this.getNumericPropertyByName = function(propertyName, objectName, source,
											 allowNull)
	{
		var result = this._getNodeValueByName(propertyName, objectName, source);

		if (result == null &amp;&amp; allowNull)
		{
			return result;
		}
		return cTypeEnforcer.checkNumber(result, "SoapResponse",
			   "getNumericPropertyByName", objectName + "." + propertyName,
			   allowNull);
   	}

	/**
	 * Gets an array of soap reponse nodes that define a named child object's
	 * property values. This is used to retrieve the definition of a child
	 * object from the response.
 	 * @param propertyName a string that contains the name of the child object
	 *	 	  (i.e. soap response node whose value is to be returned).
	 * @param objectName a string that contains the type of object the parent
	 *		  is (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the parent object in the response.
	 * @return an array of soap reponse nodes that define an object's property
	 *		   values. Null if the definition isn't found.
	 * @throws an OutOfBounds Exception if there is more than one object defined
	 *		   with the passed propertyName.
	 * @throws an UnexpectedDataType Exception if the returned value isn't an
	 *		   array.
	 */
	this.getObjectDefinitionPropertyByName = function(propertyName, objectName,
													  source)
	{
		var objectDefinitions = this.getObjectDefinitionsPropertyByName(
									 propertyName, objectName, source);

		if (objectDefinitions.length == 0)
		{
			return null;
		}
		if (objectDefinitions.length &gt; 1)
		{
			var message = "SoapResponse.getObjectDefinitionPropertyByName(): "
				+ objectDefinitions.length  + " values were found for "
				+ objectName + ":" + propertyName 
				+ " when only one was expected."
			
			throw cException.createInstance(message, "OutOfBounds");
		}
		//This doesn't seem logical, but arrays can contain null elements!
		if (objectDefinitions[0] == null)
		{
			return null;
		}
		return cTypeEnforcer.checkArray(objectDefinitions[0], "SoapResponse",
			   "getObjectDefinitionPropertyByName",
			   objectName + "." + propertyName);
   	}

	/**
	 * Gets an array of named child object definitions, where each is an array
	 * of soap reponse nodes that define an individual child object's property
	 * values. This is used to retrieve the definitions of child objects from
	 * the response.
 	 * @param propertyName a string that contains the name of the child objects
	 *	 	  (i.e. soap response node whose value is to be returned).
	 * @param objectName a string that contains the type of object the parent
	 *		  is (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the parent object in the response.
	 * @return an array of arrays of soap reponse nodes, where each defines an
	 *		   individual child object's property values. An empty array if none
	 *		   are found.
	 */
	this.getObjectDefinitionsPropertyByName = function(propertyName, objectName,
													   source)
	{
		//TODO should add a check that this gets an array of arrays:
		return this._getNodeValuesByName(propertyName, source);
   	}
	
	/**
	 * Gets the values of the named nodes from this response as an Array of
	 * Strings. This is used to retrieve individual object property values from
	 * the response when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @param objectName a string that contains the type of object this
	 *		  property is for (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the object in the response.
	 * @return the value of all of the nodes with the same name as a String Array.
	 *		   Returns an empty Array if none are found.
	 * @throws an UnexpectedDataType Exception if the returned value isn't an
	 *		   array of valid strings.
	 */
	this.getStringArrayPropertyByName = function(propertyName, objectName, source)
	{
		var results = this._getNodeValuesByName(propertyName, source);
		
		cTypeEnforcer.checkStringArray(results, "SoapResponse",
						 "getStringArrayPropertyByName",
			   			 objectName + "." + propertyName);
		return results;
   	}
   			   			   		
	/**
	 * Gets the value of the named node from this response as a String. This is
	 * used to retrieve individual object property values from the response
	 * when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @param objectName a string that contains the type of object this
	 *		  property is for (for exception reporting).
 	 * @param source an array of soap reponse nodes to be searched. This is the
	 *		  root of the object in the response.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as a string or null if allowNull is true.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid string.
	 */
	this.getStringPropertyByName = function(propertyName, objectName, source,
											allowNull)
	{
		var result = this._getNodeValueByName(propertyName, objectName, source);	

		cTypeEnforcer.checkString(result, "SoapResponse",
			"getStringPropertyByName", objectName + "." + propertyName,
			allowNull);
		return result;
   	}

	//===== Result Property Accessors ==========================================

	/**
	 * Gets the values of the named nodes from this response as an Array. This
	 * is used to retrieve individually named values from the root of the
	 * single response when they are of this data type.
 	 * @param propertyName a string that contains the name of the soap response
	 *	 	  node whose value is to be returned.
	 * @return the value of all of the nodes with the same name as an Array.
	 *		   Returns an empty Array if none are found.
	 */
	this.getArrayResultByName = function(propertyName)
	{
		return this._getNodeValuesByName(propertyName, 
					this._getSingleResponseBase("getArrayResultByName"));
   	}
   		
	/**
	 * Gets the value of the named node from this response as a boolean. This is
	 * used to retrieve individually named values from the root of the single
	 * response when they are of this data type.
	 * @param name a string that contains the name of the soap response node
	 *	 	  whose value is to be returned.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
 	 * @return the value of the node as a boolean or null if allowNull is true.
 	 *		   Strings and numbers are coerced using StringUtil and NumberUtil
 	 *		   as required.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't able to be safely converted to a
	 *		   boolean.
	 */
	this.getBooleanResultByName = function(name, allowNull)
	{
		var result = this._getNodeValueByName(name, undefined,
						this._getSingleResponseBase("getBooleanResultByName"));
		
		if (result == null &amp;&amp; allowNull)
		{
			return result;
		}
		return cTypeEnforcer.checkBoolean(result, "SoapResponse",
			   "getBooleanResultByName", name, allowNull, true);
   	}
   		
	/**
	 * Gets the value of the named node from this response as a Date. This is
	 * used to retrieve individually named values from the root of thesingle 
	 * response when they are of this data type.
	 * @param name a string that contains the name of the soap response node
	 *	 	  whose value is to be returned.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as a Date or null if allowNull is true.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid boolean.
	 */
	this.getDateResultByName = function(name, allowNull)
	{
		var stringResult = this._getNodeValueByName(name, undefined, 
						   this._getSingleResponseBase("getDateResultByName"));	

		cTypeEnforcer.checkString(stringResult, "SoapResponse", "getDateResultByName",
							 	  name, allowNull);
		if (stringResult != null)
		{
			try
			{
				return cDateUtil.parseIso8601Date(stringResult);
			}
			catch (exception)
			{
				throw cException.createInstance("SoapResponse.getDateResultByName("
					  + name + ") encountered a problem: " + exception,
					  "UnexpectedDataType");
			}
		}
		return null;
   	}
   		   		
	/**
	 * Gets the value of the named node from this response as a number. This is
	 * used to retrieve individually named values from the root of thesingle 
	 * response when they are of this data type.
	 * @param name a string that contains the name of the soap response node
	 *	 	  whose value is to be returned.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as as a number primitive or null if
	 *		   allowNull is true. Note that this only uses basic JavaScript
	 *		   coersion to create the number.
 	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid number.
	 */
	this.getNumericResultByName = function(name, allowNull)
	{
		var result = this._getNodeValueByName(name, undefined,
				 	 this._getSingleResponseBase("getNumericResultByName"));
		
		if (result == null &amp;&amp; allowNull)
		{
			return result;
		}
		return cTypeEnforcer.checkNumber(result, "SoapResponse",
			   "getNumericResultByName", name, allowNull);
   	}
	   			   		   		   		   		   			
	/**
	 * Gets the value of the named node from this response as a String. This is
	 * used to retrieve individually named values from the root of thesingle 
	 * response when they are of this data type.
	 * @param name a string that contains the name of the soap response node
	 *	 	  whose value is to be returned.
	 * @param allowNull (optional) a boolean that contains true if this
	 *		  should allow an undefined or null value without throwing an
	 *		  exception. Defaults to false.
	 * @return the value of the node as a string or null if allowNull is true.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 * @throws an UnexpectedDataType Exception if the returned value is
	 *		   undefined, null, or isn't a valid string.
	 */
	this.getStringResultByName = function(name, allowNull)
	{
		var result = this._getNodeValueByName(name, undefined, 
					 this._getSingleResponseBase("getStringResultByName"));
		
		cTypeEnforcer.checkString(result, "SoapResponse",
					  "getStringResultByName", name, allowNull);
		return result;
   	}

    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		
		buffer += "responseName= " + this.responseName;
		buffer += ", responseValues= " + cObjectUtil.asString(this.responseValues);
		buffer += "]";		

		return buffer;
	}

	//===== PRIVATE ============================================================
	/**
	 * Gets an array of the items that are in a single response (those with
	 * single or multiple return values, not complex object structures). These
	 * values are actually stored within the top node, so this traverses down a
	 * level.
	 * @param callingMethodName the name of the calling method for exception
	 *		  reporting.
	 * @return an array of the items (soap response nodes or arrays of soap
	 *		   reponse nodes) that are in the single response node.
	 * @throws IllegalState Exception if more than one node is at the response
	 *		   base.
	 */
	this._getSingleResponseBase = function(callingMethodName)
	{
		if (this.singleResponseBase == null) {
			if (!this.hasSingleResponse())
			{
				var message = "More than one result encountered when processing "
							  + callingMethodName + "()";

				throw cException.createInstance(message, "IllegalState");
			}
			this.singleResponseBase = this.responseValues[0];
			/*	
			var responseValue = this.responseValues[0];				
	
			if (responseValue.soapValue != null)
			{
				this.singleResponseBase = responseValue.soapValue;
			}
			else
			{
				this.singleResponseBase = new Array();
			}*/					
		}
		return this.singleResponseBase;
	}
	
	/**
	 * Gets the value of the named node from this response. This may be a
	 * string, number, boolean, or array. The data type of the returned value
	 * should be verified as conforming to what was expected.
	 * @param name a string that contains the name of the soap response node
	 *	 	  whose value is to be returned.
 	 * @param objectType (optional) a string that contains the type of object
	 *		  this property is for when it is an object property (for
	 *		  exception reporting).
	 * @param source (optional) an array of soap reponse nodes to be searched.
	 *		  Defaults to the top collection of returned nodes.
	 * @return the value of the node that matched the requested name. Returns
	 *		   null if the value is not found.
	 * @throws OutOfBounds Exception if more than one node with the indicated
	 *		   name is found.
	 */
	this._getNodeValueByName = function(name, objectType, source)
	{
		var values = this._getNodeValuesByName(name, source);
		
		if(values.length == 1)
		{
			return values[0];
		}
		if(values.length &gt; 1)
		{
			var message = "SoapResponse._getItemByName(): " + values.length 
						  + " values were found for ";
						  
			if (objectType != undefined)
			{
				message += objectType + ":";
			}
			message += name + " when only one was expected."
			
			throw cException.createInstance(message, "OutOfBounds");
		}

		return null;
	}
		
	/**
	 * Gets an array of the values of the named nodes from this response. This
	 * may contain strings, numbers, booleans, or arrays.
	 * @param name a string that contains the name of the soap response nodes
	 *	 	  whose values are to be returned.
	 * @param source (optional) an array of soap reponse nodes to be searched.
	 *		  Defaults to the top collection of returned nodes.
	 * @return an array of the values of the nodes that match the requested
	 *		   name. Returns an empty array if none are found. Note that the
	 *		   order of the values is preserved.
	 */
	this._getNodeValuesByName = function(name, source)
	{
		var results = new Array();
		
		cTypeEnforcer.checkString(name, "SoapResponse", "_getNodeValuesByName",
								"name");
		cTypeEnforcer.checkArray(source, "SoapResponse", "_getNodeValuesByName",
								"source", true);

		if (source == undefined)
		{
			source = this.responseValues;
		}
		
		for(var i = 0; i &lt; source.length; i++) 
		{
			//Need to skip entries where the soapAttributes indicates it is nil (null)
			//This should only happen for text that is only available in one
			//language but not the other.
			if(source[i].soapName == name &amp;&amp; source[i].soapValue != undefined
			   &amp;&amp; (source[i].soapAttributes == null
			   	   || !(source[i].soapAttributes["http://www.w3.org/2001/XMLSchema-instance:nil"])))
			{
				results.push(source[i].soapValue); 
			}
		}
		return results;
	}
			
	/**
	 * This initializes this object by extracting the name and base values from
	 * the passed response.
	 * @param response an array that contains the response from a web service
	 *		  call made through Adobe's SOAP functions.
	 * @throws IllegalState Exception if the response was not formed as expected.
	 */
	this._load = function(response)
	{
		cTypeEnforcer.checkArray(response, "SoapResponse", "constructor",
							   "response");
							   
		if (response.length != 1) //Should never happen
		{
			throw cException.createInstance("SoapResponse.constructor() -response has "
				+ response.length + " items, should only have 1.", "IllegalState");
		}
		this.responseName = response[0].soapName;

		if (response[0].soapValue != null)
		{
		var baseResponseWrapper = response[0].soapValue;		

			if (baseResponseWrapper == null) //Should never happen
			{
				throw cException.createInstance("SoapResponse.constructor() -response "
					+ "doesn't have a soap response node wrapper.", "IllegalState");
			}
			for (var i=0; i &lt; baseResponseWrapper.length; i++)
			{
				if (baseResponseWrapper[i].soapValue != null)
				{
					this.responseValues.push(baseResponseWrapper[i].soapValue);
				}
			}
		}
	}
	
	//Constructor callout:
	this._load(response);
}
</script>
               <script contentType="application/x-javascript" name="WebService">//
/*******************************************************************************
 * This object provides support for communicating with a SOAP based Web Service.
 * It will only function properly when run from within an Adobe form, since it
 * uses Adobe's SOAP functions.
 *
 * Note that this has been written with NHPD's Web Services in mind and may
 * require additional generalization to make it compatible with other Web
 * Services.
 */

//imports
var cException = script.core.util.Exception;
var cLocalizedException = script.core.lang.LocalizedException;
var cLog = script.core.util.Log;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;
var cSoapResponse = script.core.service.SoapResponse;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new WebService. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * @param serviceUrl a string that contains the web service's URL (not to be
 *		  confused with the wsdl's URL).
 * @param serviceNameSpace a string that contains the namespace used for
 *		  requests.
 * @param debugMode (optional) a boolean as to whether this is in debug mode or
 *		  not. When in debug mode, this will dump the XML of the requests and
 *		  responses to the console. These may be very large. Defaults to false.
 * @return the new WebService instance
 * @throws UnexpectedDataType Exception if any of the parameters aren't as
 *		   indicated or if debugMode is not properly set in the configuration.
 */
function createInstance(serviceUrl, serviceNameSpace, debugMode)
{
	return new WebServiceClass(serviceUrl, serviceNameSpace, debugMode);
}

/**
 * Class implementation
 */
function WebServiceClass(serviceUrl, serviceNameSpace, debugMode)
{
	this.className = "WebService";

	this.debugMode = cTypeEnforcer.checkBoolean(debugMode, "WebService",
					 "constructor", "debugMode", true);
	this.serviceNameSpace = cTypeEnforcer.checkString(serviceNameSpace,
							"WebService", "constructor", "serviceNameSpace");
	this.serviceUrl = cTypeEnforcer.checkString(serviceUrl, "WebService",
					  "constructor", "serviceUrl"); 

	//Add this to control web service version in the header
	this.webServiceVersion = null;
	
	this.getWebServiceVersion = function(){
		return this.webServiceVersion;
	}
	
	this.setWebServiceVersion = function(version){
		this.webServiceVersion = new String(version);
	}
	
	/**
	 * Gets whether this is in debug mode or not. When in debug mode, this will
	 * dump the XML of the requests and responses to the console. These may be
	 * very large.
	 * @return a boolean as to whether this is in debug mode or not.
	 */
	this.isDebugMode = function()
	{
		return this.debugMode;
	}
		
	/**
	 * Sets whether this is in debug mode or not. When in debug mode, this will
	 * dump the XML of the requests and responses to the console. These may be
	 * very large.
	 * @param aBoolean a boolean as to whether this is in debug mode or not.
	 */
	this.setDebugMode = function(aBoolean)
	{
		this.debugMode = cTypeEnforcer.checkBoolean(aBoolean, "WebService",
						 "setDebugMode", "aBoolean");
	}
	
	/**
	 * Gets the namespace used for requests. This is used to prefix items that
	 * are fully qualified.
	 * @return a string that contains the namespace used for request items.
	 */
	this.getServiceNameSpace = function()
	{
		return this.serviceNameSpace;
	}
	
	/**
	 * Gets the web service's URL.
	 * @return a string that contains the web service's URL (not to be confused
	 *		   with the wsdl's url).
	 */
	this.getServiceUrl = function()
	{
		return this.serviceUrl;
	}

    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function ()
	{
		var buffer = this.className + "[";
		
		buffer += "serviceNameSpace= " + this.getServiceNameSpace();
		buffer += ", serviceUrl= " + this.getServiceUrl();
		buffer += ", debugMode= " + this.isDebugMode();
		buffer += "]";		

		return buffer;
	}
	
	/**
	 * This calls the named web service operation (function) using SOAP.
	 * @param string operationName a string containing the name of the
	 *		  operation to call.
	 * @param operationArguments (optional) either an array of simple maps or a
	 *		  single simple map. The map(s) contain the operation's arguments where
	 *		  the keys are the argument names and the values are their values.
	 * @return a SoapResponse that contains the response.
	 * @throws LocalizedException if there was a problem with the call
	 *		  (connecting to the service, problem with the soap request, etc.).
 	 * @throws UnexpectedDataType Exception if any of the parameters aren't as
 	 *		   indicated.
	 */
	this.callServiceOperation = function(operationName, operationArguments)
	{
		cTypeEnforcer.checkString(operationName, "WebService",
								  "callServiceOperation", "operationName");
		if (operationArguments != null 
			&amp;&amp; !cTypeChecker.isArray(operationArguments)
			&amp;&amp; !cTypeChecker.isSimpleMap(operationArguments))
		{
			throw cException.createInstance(
				  "WebService.callServiceOperation(operationArguments)" 
		  		  + " requires an array or simple map, not a " 
		  		  + cObjectUtil.getDescription(operationArguments),
				  "UnexpectedDataType");
		}

		var language = cResourceManager.getCurrentLanguage();
		var request = {};
		
		request["cURL"] = this.serviceUrl;
		request["bEncoded"] = false;
		request["cResponseStyle"] = SOAPMessageStyle.Message;
		request["oReqHeader"] = {soapAttributes: {"xml:lang": language}};
		if(this.webServiceVersion != null){
		  	request["oReqHeader"]["soapAttributes"]["xml:version"] = this.webServiceVersion; 
		}
		request["oRequest"] = {};
		request["oRequest"][this.serviceNameSpace + ":" + operationName] =
			   operationArguments;
		try 
		{
			return this._performSoapCall(request);
		}
		catch(e)
		{
			switch(e.name)
			{
				case "NetworkError":
					if(e.statusCode == -1)
					{
						throw cLocalizedException.createInstance(
							  "error_networkGeneric", operationName,
							  e.message);
					}
					else
					{
						throw cLocalizedException.createInstance(
							  "error_networkDetail", e.statusCode,
							  operationName, e.message);
					}
					break;
				case "SOAPError":
					if (this.isDebugMode())
					{
						cLog.error(cResourceManager.get("error_soapDetail",
							 e.message, operationName, e.faultCode, e.faultActor,
							 cObjectUtil.asString(e.faultDetail)));
					}
					//Let it drop through
				default:
					throw cLocalizedException.createInstance("error_soapGeneric",					
						  e.name, operationName, e.message);
					break;
			}
		}
	}


	//===== PRIVATE ============================================================

	/**
	* This calls the named web service operation (function) using SOAP.
	* @param request a map of the SOAP call's arguments.
	* @return the soap response.
	* @throws NetworkError Exception (Adobe) if there was a problem connecting
	*		  to the service.
	* @throws SOAPError Exception (Adobe) if there was a problem with the soap
	*		  request.
	* @throws Exception (Adobe) if any other problem occurs.
	*/
	this._performSoapCall = function(request)
	{
		Net.SOAP.wireDump = this.debugMode;
		return cSoapResponse.createInstance(Net.SOAP.request(request));	
	}
}
</script>
               <?templateDesigner expand 0?></variables>
            <bind match="none"/>
            <?templateDesigner expand 0?></subform>
         <subform w="100mm" h="50mm" name="test">
            <variables>
               <script contentType="application/x-javascript" name="FailureException">//
/*******************************************************************************
 * A FailureException represents an assertion failure (or a call to fail())
 * during the execution of a JsUnit Test Function. Note that, since over-
 * riding toString() is not supported and the console uses toString(), these
 * are actually using Adobe's Error class which has implemented toString().
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new FailureException. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * @param source (optional) a string that contains the source of the failure.
 * @param reason a string that contains the reason for the failure.
 * @return the new FailureException instance
 */
function createInstance(source, reason)
{
	cTypeEnforcer.checkString(reason, "FailureException", "constructor",
							  "reason");
	source = cTypeEnforcer.checkString(source, "FailureException",
									   "constructor", "source", true);

	var anError = new Error(reason + " [" + source + "]");

	anError.className = "FailureException";
	anError.name = "FailureException";
	anError.reason = reason;
	anError.source = source;

	//Add its custom methods

    /**
     * Gets the exception's message, which is typically the reason for the
     * failure.
     * @return a String that contains the message that describes the problem.
     */
    anError.getMessage = function ()
	{
		return this.message;
	}
        
    /**
     * Gets the reason for the failure.
     * @return a string that contains the reason for the failure.
     */    
	anError.getReason = function()
	{
		return this.reason;
	}

    /**
     * Gets the source of the failure.
     * @return a string that contains the source of the failure. Returns an
     *		   empty string if source is not specified.
     */    
	anError.getSource = function()
	{
		return this.source;
	}

    /**
     * Describes this object. This is implemented to get the same result as
     * its toString(), which is implemented by Error.
     * @return the description of this exception.
     */
    anError.asString = function ()
	{
		return this.toString();
	}

	return anError;
}
</script>
               <script contentType="application/x-javascript" name="JsUnit">//
/*******************************************************************************
 * A class that contains the implementation of the core JsUnit functionality:
 * assertions. Used for unit testing.
 * Based on work by Edward Hieatt, edward@jsunit.net (http://www.jsunit.net)
 */

//imports
var cException = script.core.util.Exception;
var cFailureException = script.core.test.FailureException;
var cLog = script.core.util.Log;

//For convenience, a variable that equals "undefined"
var JSUNIT_UNDEFINED_VALUE;
//Predicate used for testing JavaScript == (i.e. equality excluding type)
var DOUBLE_EQUALITY_PREDICATE = function(var1, var2)
	{
		return var1 == var2;
	};
//Predicate used for testing whether two obects' toStrings are equal
var TO_STRING_EQUALITY_PREDICATE = function(var1, var2)
	{
		return var1.toString() === var2.toString();
	};

//Predicate used for testing JavaScript === (i.e. equality including type)
var TRIPLE_EQUALITY_PREDICATE = function(var1, var2)
	{
		return var1 === var2;
	};
//Hash of predicates for testing equality by primitive type
var PRIMITIVE_EQUALITY_PREDICATES =
	{
    	'String':   DOUBLE_EQUALITY_PREDICATE,
    	'Number':   DOUBLE_EQUALITY_PREDICATE,
    	'Boolean':  DOUBLE_EQUALITY_PREDICATE,
    	'Date':     TO_STRING_EQUALITY_PREDICATE,
    	'Array':    TO_STRING_EQUALITY_PREDICATE,
    	'RegExp':   TO_STRING_EQUALITY_PREDICATE,
    	'Function': TO_STRING_EQUALITY_PREDICATE
	}

/**
 * Checks that an array is equal to another by checking that both are arrays and
 * then comparing their elements using assertObjectEquals
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the expected array
 * @param value the actual array
 * @throws FailureException if the actual value does not equal the expected value
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertArrayEquals()
{
    _validateArguments(2, arguments);
    var array1 = _nonCommentArg(1, 2, arguments);
    var array2 = _nonCommentArg(2, 2, arguments);

    if (_trueTypeOf(array1) != 'Array' || _trueTypeOf(array2) != 'Array')
    {
	    throw cFailureException.createInstance(_commentArg(1, arguments),
			  "Expected 2 arrays to compare but got a " 
			  + _displayStringForValue(array1) + "and a"
			  +  _displayStringForValue(array2));        
    }

    assertObjectEquals(_commentArg(2, arguments), _nonCommentArg(1, 2, arguments),
					   _nonCommentArg(2, 2, arguments));
}

/**
 * Checks that two arrays have the same contents, ignoring the order of the
 * contents.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param array1 first array
 * @param array2 second array
 * @throws FailureException if the two arrays have different contents
 * @throws AssertionArgument Exception if an incorrect number of arguments are
 *		   passed
 */
function assertArrayEqualsIgnoringOrder()
{
    _validateArguments(2, arguments);
    var var1 = _nonCommentArg(1, 2, arguments);
    var var2 = _nonCommentArg(2, 2, arguments);
    var notArraysMessage = "Expected arguments " + _displayStringForValue(var1) 
    					   + " and " + _displayStringForValue(var2) 
    					   + " to be arrays";
    var notEqualsMessage = "Expected arrays " + _displayStringForValue(var1) 
    					   + " and " + _displayStringForValue(var2) 
    					   + " to be equal (ignoring order)";

    _assert(_commentArg(2, arguments), _checkNotNull(var1), notEqualsMessage);
    _assert(_commentArg(2, arguments), _checkNotNull(var2), notEqualsMessage);

    _assert(_commentArg(2, arguments), _checkNotUndefined(var1.length),
    		notArraysMessage);
    _assert(_commentArg(2, arguments), _checkNotUndefined(var1.join), 
    		notArraysMessage);
    _assert(_commentArg(2, arguments), _checkNotUndefined(var2.length),
    		notArraysMessage);
    _assert(_commentArg(2, arguments), _checkNotUndefined(var2.join),
    		notArraysMessage);

    _assert(_commentArg(1, arguments), _checkEquals(var1.length, var2.length),
    		notEqualsMessage);

    for (var i = 0; i &lt; var1.length; i++)
    {
        var found = false;

        for (var j = 0; j &lt; var2.length; j++)
        {
            try
            {
                assertObjectEquals(notEqualsMessage, var1[i], var2[j]);
                found = true;
            }
            catch (ignored)
            {
            }
        }
        _assert(_commentArg(2, arguments), found, notEqualsMessage);
    }
}

/**
 * Checks that a collection contains a value by checking that
 * collection.indexOf(value) is not -1.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param collection the collection
 * @param value the value
 * @throws FailureException if the collection does not contain the value
 * @throws AssertionArgument Exception if an incorrect number of arguments are
 *		   passed
 */
function assertContains()
{
    _validateArguments(2, arguments);
    var value = _nonCommentArg(1, 2, arguments);
    var collection = _nonCommentArg(2, 2, arguments);

    assertTrue("Expected '" + collection + "' to contain '" + value + "'",
			   collection.indexOf(value) != -1);
}

/**
 * Checks that two values are equal (using ===)
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param expected the expected value
 * @param actual the actual value
 * @throws FailureException if the values are not equal
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertEquals()
{
    _validateArguments(2, arguments);
    var var1 = _nonCommentArg(1, 2, arguments);
    var var2 = _nonCommentArg(2, 2, arguments);

    _assert(_commentArg(2, arguments), _checkEquals(var1, var2),
           'Expected ' + _displayStringForValue(var1) + ' but was ' 
           + _displayStringForValue(var2));
}

/**
 * Checks that a value evaluates to false in the sense that value == false. It is
 * safer to use assertFalse(), since many values coerce to an unexpected boolean
 * equivalent.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the actual value does not evaluate to false
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertEvaluatesToFalse()
{
    _validateArguments(1, arguments);
    var booleanValue = _nonCommentArg(1, 1, arguments);

    if (booleanValue)
    {
	    throw cFailureException.createInstance(_commentArg(1, arguments),
			  'Expected false but was ' + _displayStringForValue(booleanValue));        
	}
}

/**
 * Checks that a value evaluates to true in the sense that value == true. It is
 * safer to use assertTrue(), since many values coerce to an unexpected boolean
 * equivalent.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the actual value does not evaluate to true
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertEvaluatesToTrue()
{
    _validateArguments(1, arguments);
    var booleanValue = _nonCommentArg(1, 1, arguments);

    if (!booleanValue)
    {
	    throw cFailureException.createInstance(_commentArg(1, arguments),
			  'Expected true but was ' + _displayStringForValue(booleanValue));        

    }
}

/**
 * Checks that the passed value is a boolean data type or object with a value of
 * false.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @value value that is expected to be false
 * @throws FailureException if the given value is not a boolean data type or
 *		   or object, or if its value isn't false
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertFalse()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);
    var isBoolean = false;

	if (typeof aVar == 'boolean')
	{
		isBoolean = true;
	}
	else if (typeof aVar == 'object')
	{
		var criterion = aVar.constructor.toString().match(/boolean/i);
		
 		if(criterion != null)
 		{
 			isBoolean = true;
		}
	}
	
	if (isBoolean)
	{
		assertEvaluatesToFalse(_commentArg(1, arguments), aVar);
	}
	else
	{
	    throw cFailureException.createInstance(_commentArg(1, arguments),
			  'Expected false but was ' + _displayStringForValue(aVar));        
	}
}

/**
 * Checks that a hash is has the same contents as another by iterating over the
 * expected hash and checking that each key's value is present in the actual
 * hash and calling assertEquals on the two values, and then checking that there
 * is no key in the actual hash that isn't present in the expected hash.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the expected hash
 * @param value the actual hash
 * @throws FailureException if the actual hash does not evaluate to true
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertHashEquals()
{
    _validateArguments(2, arguments);
    var var1 = _nonCommentArg(1, 2, arguments);
    var var2 = _nonCommentArg(2, 2, arguments);

    for (var key in var1)
    {
        assertNotUndefined("Expected hash had key " + key 
        				   + " that was not found", var2[key]);
        assertEquals("Value for key " + key + " mismatch - expected = " 
        			 + var1[key] + ", actual = " + var2[key],
					 var1[key], var2[key]);
    }

    for (var key in var2)
    {
        assertNotUndefined("Actual hash had key " + key 
        				   + " that was not expected", var1[key]);
    }
}

/**
 * Checks that a value is NaN (Not a Number)
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the value is a number
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertNaN()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);

    _assert(_commentArg(1, arguments), isNaN(aVar), 'Expected NaN');
}

/**
 * Checks that two values are not equal (using !==)
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value1 a value
 * @param value2 another value
 * @throws FailureException if the values are equal
 * @throws AssertionArgument Exception if an incorrect number of arguments
 *		   is passed
 */
function assertNotEquals()
{
    _validateArguments(2, arguments);
    var var1 = _nonCommentArg(1, 2, arguments);
    var var2 = _nonCommentArg(2, 2, arguments);

    _assert(_commentArg(2, arguments), var1 !== var2, 
    		'Expected not to be ' + _displayStringForValue(var2));
}

/**
 * Checks that a value is not NaN (i.e. is a number)
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the value is not a number
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertNotNaN()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);

    _assert(_commentArg(1, arguments), !isNaN(aVar), 'Expected not NaN');
}

/**
 * Checks that a value is not null
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the value is null
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertNotNull()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);

    _assert(_commentArg(1, arguments), _checkNotNull(aVar),
    		'Expected not to be ' + _displayStringForValue(null));
}

/**
 * Checks that a value is not undefined
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the value is undefined
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertNotUndefined()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);

    _assert(_commentArg(1, arguments), _checkNotUndefined(aVar), 
    		'Expected not to be ' + _displayStringForValue(JSUNIT_UNDEFINED_VALUE));
}

/**
 * Checks that a value is null
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the value is not null
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertNull()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);

    _assert(_commentArg(1, arguments), aVar === null, 
    		'Expected ' + _displayStringForValue(null) + ' but was ' 
    		+ _displayStringForValue(aVar));
}

/**
 * Checks that an object is equal to another using === for primitives and their
 * object counterparts but also descending into collections and calling
 * assertObjectEquals for each element.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the expected value
 * @param value the actual value
 * @throws FailureException if the actual value does not equal the expected value
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertObjectEquals()
{
    _validateArguments(2, arguments);
    var var1 = _nonCommentArg(1, 2, arguments);
    var var2 = _nonCommentArg(2, 2, arguments);

    if (var1 === var2)
    {
        return;
    }

    var failureMessage = "";
    var isEqual = false;
    var typeOfVar1 = _trueTypeOf(var1);
    var typeOfVar2 = _trueTypeOf(var2);
    
	if (_commentArg(2, arguments))
	{
		failureMessage = _commentArg(2, arguments);
	}

    if (typeOfVar1 == typeOfVar2)
    {
        var primitiveEqualityPredicate = PRIMITIVE_EQUALITY_PREDICATES[typeOfVar1];

        if (primitiveEqualityPredicate)
        {
            isEqual = primitiveEqualityPredicate(var1, var2);
        }
        else
        {
            var expectedKeys = _getKeys(var1).sort().join(", ");
            var actualKeys = _getKeys(var2).sort().join(", ");
            
            if (expectedKeys != actualKeys)
            {
                _assert(failureMessage, false,
                		'Expected keys "' + expectedKeys + '" but found "' 
                		+ actualKeys + '"');
            }
            for (var i in var1)
            {
                assertObjectEquals(failureMessage + ' found nested ' + typeOfVar1
                				   + '@' + i + '\n', var1[i], var2[i]);
            }
            isEqual = true;
        }
    }
    _assert(failureMessage, isEqual, 
    		'Expected ' + _displayStringForValue(var1) + ' but was ' 
    		+ _displayStringForValue(var2));
}

/**
 * Checks that two numeric values are within a tolerance of one another
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value1 a value
 * @param value1 another value
 * @param tolerance the tolerance
 * @throws FailureException if the two values are not within tolerance of each
 *		   other
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertRoughlyEquals()
{
    _validateArguments(3, arguments);
    var expected = _nonCommentArg(1, 3, arguments);
    var actual = _nonCommentArg(2, 3, arguments);
    var tolerance = _nonCommentArg(3, 3, arguments);

    assertTrue("Expected " + expected + ", but got " + actual 
    		   + " which was more than " + tolerance + " away",
        	   Math.abs(expected - actual) &lt; tolerance);
}

/**
 * Checks that the passed value is a boolean data type or object with a value of
 * true.
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @value value that is expected to be true
 * @throws FailureException if the given value is not a boolean data type or
 *		   or object, or if its value isn't true
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertTrue()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);
    var isBoolean = false;

	if (typeof aVar == 'boolean')
	{
		isBoolean = true;
	}
	else if (typeof aVar == 'object')
	{
		var criterion = aVar.constructor.toString().match(/boolean/i);
		
 		if(criterion != null)
 		{
 			isBoolean = true;
		}
	}
	
	if (isBoolean)
	{
		assertEvaluatesToTrue(_commentArg(1, arguments), aVar);
	}
	else
	{
	    throw cFailureException.createInstance(_commentArg(1, arguments),
			  'Expected true but was ' + _displayStringForValue(aVar));        
	}
}

/**
 * Checks that a value is undefined
 * @param comment optional, displayed in the case of failure. Typically the name
 * 		  of the function being tested.
 * @param value the value
 * @throws FailureException if the value is not undefined
 * @throws AssertionArgument Exception if an incorrect number of arguments is
 *		   passed
 */
function assertUndefined()
{
    _validateArguments(1, arguments);
    var aVar = _nonCommentArg(1, 1, arguments);

    _assert(_commentArg(1, arguments), aVar === JSUNIT_UNDEFINED_VALUE,
    		'Expected ' + _displayStringForValue(JSUNIT_UNDEFINED_VALUE) 
    		+ ' but was ' + _displayStringForValue(aVar));
}

/**
 * A convenience method that creates a log entry for the passed exception.
 * Note that this only properly deals with AssertionArgument Exceptions and
 * FailureExceptions.
 * @param exception the exception to log. If its unrecognized, this will log a
 *		  message to that effect.
 */
function logException(exception)
{
    if (exception.className == "FailureException")
    {
    	var message = "Test";
    	
		if (exception.getSource() != "")
		{
			message = message + " " + exception.getSource();		
		}
		message = message + " failed: " + exception.getReason();
		cLog.test(message);
    }
    else //Unrecognized
    {
		cLog.test("Unexpected exception", exception);
    }
}

/**
 * A convenience method that creates a log entry when an expected exception is
 * not thrown.
 * @param comment the name of the offending function.
 */
function logNonException(comment)
{
	cLog.test("Test " + comment
			 + " failed: expected an exception to be thrown");
}


//===== PRIVATE ================================================================

/**
 * @private
 */
function _argumentsIncludeComments(expectedNumberOfNonCommentArgs, args)
{
    return args.length == expectedNumberOfNonCommentArgs + 1;
}

/**
 * All assertions ultimately go through this method.
 * @private
 */
function _assert(comment, booleanValue, failureMessage)
{
    if (!booleanValue)
    {
    	throw cFailureException.createInstance(comment, failureMessage);
    }
}

/**
 * @private
 */
function _checkEquals(var1, var2)
{
    return var1 === var2;
}

/**
 * @private
 */
function _checkNotNull(aVar)
{
    return aVar !== null;
}

/**
 * @private
 */
function _checkNotUndefined(aVar)
{
    return aVar !== JSUNIT_UNDEFINED_VALUE;
}

/**
 * @private
 */
function _commentArg(expectedNumberOfNonCommentArgs, args)
{
    if (_argumentsIncludeComments(expectedNumberOfNonCommentArgs, args))
    {
        return args[0];
    }

    return null;
}

/**
 * @private
 */
function _displayStringForValue(aVar)
{
    var result = '&lt;' + aVar + '&gt;';

    if (!(aVar === null || aVar === JSUNIT_UNDEFINED_VALUE))
    {
        result += ' (' + _trueTypeOf(aVar) + ')';
    }
    return result;
}

/**
 * @private
 */
function _getKeys(obj)
{
    var keys = [];

    for (var key in obj)
    {
        keys.push(key);
    }
    return keys;
}

/**
 * @private
 */
function _nonCommentArg(desiredNonCommentArgIndex,
						expectedNumberOfNonCommentArgs, args) {
	if (_argumentsIncludeComments(expectedNumberOfNonCommentArgs, args))
	{
	    return args[desiredNonCommentArgIndex];
	}						
    return args[desiredNonCommentArgIndex - 1];
}

/**
 * @param Any object
 * @return String - the type of the given object
 * @private
 */
function _trueTypeOf(something)
{
    var result = typeof something;
    try {
        switch (result)
        {
            case 'string':
                break;
            case 'boolean':
                break;
            case 'number':
                break;
            case 'object':
            case 'function':
                switch (something.constructor)
                {
                    case new String().constructor:
                        result = 'String';
                        break;
                    case new Boolean().constructor:
                        result = 'Boolean';
                        break;
                    case new Number().constructor:
                        result = 'Number';
                        break;
                    case new Array().constructor:
                        result = 'Array';
                        break;
                    case new RegExp().constructor:
                        result = 'RegExp';
                        break;
                    case new Date().constructor:
                        result = 'Date';
                        break;
                    case Function:
                        result = 'Function';
                        break;
                    default:
                        var m = something.constructor.toString().match(/function\s*([^( ]+)\(/);
                        if (m)
                        {
                            result = m[1];
                        }
                        else
                        {
                            break;
                        }
                }
                break;
        }
    }
    finally 
    {
        result = result.substr(0, 1).toUpperCase() + result.substr(1);
        return result;
    }
}

/**
 * @private
 */
function _validateArguments(expectedNumberOfNonCommentArgs, args)
{
    if (!(args.length == expectedNumberOfNonCommentArgs
          ||(args.length == expectedNumberOfNonCommentArgs + 1 
             &amp;&amp; (typeof(args[0]) == 'string')
             || args[0] == null)))
    {
        throw cException.createInstance(
        	  'Incorrect arguments passed to assert function', 'AssertionArgument');
	}
}
</script>
               <script contentType="application/x-javascript" name="TestSuiteInterface">//
/*******************************************************************************
 * This defines an Interface that is implemented by JsUnit test suites, which
 * are collections of JsUnit tests.
 */

var interfaceName = "TestSuiteInterface"; //Required for all interfaces

/**
 * Gets the number of tests that failed on the last run.
 * @return number the number of test failures that occured.
 */
function getNumberOfFailures(){}

/**
 * Gets the number of tests that succeeded on the last run.
 * @return number the number of tests that were successful.
 */
function getNumberOfSuccesses(){}

/**
 * Runs all the tests in the suite. Logs all failures.
 * @return true if all of the tests passed.
 */
function runTests() {}

</script>
               <?templateDesigner expand 0?></variables>
            <bind match="none"/>
            <?templateDesigner expand 0?></subform>
         <subform w="100mm" h="50mm" name="util" presence="hidden">
            <bind match="none"/>
            <variables>
               <script contentType="application/x-javascript" name="ArrayUtil">//
/*******************************************************************************
 * A class that contains utility functions for manipulating Arrays.
 */

//imports
var cException = script.core.util.Exception;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var caseInsensitiveStringComparator = function(x, y){ 
		x = String(x).toUpperCase(); 
		y = String(y).toUpperCase(); 
		if (x &gt; y)
		{
			return 1;
		}
		if (x &lt; y)
		{
			return -1;
		}   
		return 0; 
	}

/**
 * Searches the passed Array to check if it contains the passed value.
 * This is not very efficient, since it needs to do a scan of the array's
 * contents looking for a match.
 * @param anArray the Array to be checked.
 * @param aValue the value that may be in the Array. Note that if aValue
 *		  is a custom Object that implements equals(), that function will
 *		  be used for equality testing. If it is a custom object that
 *		  doesn't implement that method, it will compare its asString()
 *		  value to other custom objects.
 * @return a boolean true if the passed Array contains the passed value.
 */
function contains(anArray, aValue)
{
	cTypeEnforcer.checkArray(anArray, "ArrayUtil", "contains", "anArray");
	if (aValue == undefined)
	{
		throw cException.createInstance(
			  "ArrayUtil.contains(aValue) was passed undefined", 
			  "UnexpectedDataType");
	}

	if (typeof aValue == 'object')
	{
		//If the object implements EqualityComparableInterface, then use its equals()
		if (aValue.equals != undefined)
		{
			for (var i=0; i &lt; anArray.length; i++)
			{
				if (aValue.equals(anArray[i]))
				{
					return true;
				}
			}
		}
		//If it is a custom object, compare its asString() to other custom objects
		else if (aValue.asString != undefined)
		{
			for (var i=0; i &lt; anArray.length; i++)
			{
				if (cTypeChecker.isCustomObject(anArray[i])
					&amp;&amp; aValue.asString() == anArray[i].asString())
				{
					return true;
				}
			}
		}
	}
	else
	{
		for (var i=0; i &lt; anArray.length; i++)
		{
			if (anArray[i] == aValue)
			{
				return true;
			}
		}
	}
						  
	return false;
}

/**
 * Sorts the passed String Array "in place" using a case insensitive sort.
 * @param aStringArray the String Array to be sorted.
 */
function sortStringArray(aStringArray)
{
	cTypeEnforcer.checkStringArray(aStringArray, "ArrayUtil", "sortStringArray",
								  "aStringArray");
						  
	aStringArray.sort(caseInsensitiveStringComparator);
}

</script>
               <script contentType="application/x-javascript" name="BarcodeUtil">//
/******************************************************************************
 * A class used to support forms that need to populate barcodes that contain
 * all of their data.
 */

// imports
var cException = script.core.util.Exception;
var cJsZip = script.core.zip.JsZip;
var cLog = script.core.util.Log;
var cNumberFormatter = script.core.util.NumberFormatter;
var cTypeEnforcer = script.core.util.TypeEnforcer;

// constants
// version 2.0 - must be two digits
var _BARCODE_VERSION = "20";
// maximum length in characters, not including 8 character header
var _BARCODE_LENGTH = 800;
// Name of the file in the zip
var _FILE_NAME = "formData.xml";

/**
 * Builds a String Array containing the data for a set of barcodes that will
 * contain all of the data in this form. Each array entry represents the data for
 * a single barcode. This barcode data conforms to version 2.0 of the NHPD
 * barcode specification, where each barcode contains a header block followed by
 * its content. When concatinated, the contents together represent base64 encoded
 * zip data that contains the XML dataset(s) from this form.
 *
 * Typically called by populateBarcodes(), but exposed to support custom use.
 *
 * Header Format (all entries are padded as required): 
 *	BARCODE_VERSION - 2 digits
 *	NUMBER_OF_BARCODES - 2 digits
 *	CURRENT_BARCODE_INDEX - 2 digits (0 based)
 *	CURRENT_BARCODE_LENGTH - 4 digits (number of characters)
 *
 * e.g. version 2.0, the last of 15 barcodes, length 500: 201514000500
 *
 * @return an array of strings of encoded data, suitable for creating individual
 *		   barcodes. 
 */
function buildBarcodeData()
{		
	var barcodeDataList = [];
	var encodedData = _encodeFormData();	
	var numberOfBarcodes = Math.ceil(encodedData.length / _BARCODE_LENGTH);

	cLog.trace("barcode payload: " + encodedData);
	for(var i = 0; i &lt; numberOfBarcodes; i++)
	{		
		var barcodeData = encodedData.substr(
			_BARCODE_LENGTH * i, // Starting index of this barcode's data
			_BARCODE_LENGTH);	 // Maximum length of this barcode's data
		
		// set this barcode's header and data
		barcodeDataList.push(
			_BARCODE_VERSION +		
			cNumberFormatter.pad(numberOfBarcodes, 2) + 
			cNumberFormatter.pad(i, 2) + 
			cNumberFormatter.pad(barcodeData.length, 4) + 
			barcodeData);
	}
	
	return barcodeDataList;
}

/**
 * Removes the barcodes from the form.
 * @param barcodeInstMgr the InstanceManager of the repeating subform that
 *		  contains the individual barcode fields. 
 * @throws an UnexpectedDataType Exception if barcodeInstMgr isn't an Adobe
 *		   instanceManager object.
 */
function clearBarcodes(barcodeInstMgr)
{
	cTypeEnforcer.checkInstanceManager(barcodeInstMgr, "BarcodeUtil",
									  "clearBarcodes", "barcodeInstMgr");

	barcodeInstMgr.setInstances(0);
}

/**
 * Draws a series of barcodes, containing base64 encoded zipped data on the 
 * form. The data comes from the form's default dataset. This assumes that the
 * barcode fields are named "barcodeField".
 * @param barcodeInstMgr the InstanceManager of the repeating subform that
 *		  contains the individual barcode fields. 
 * @throws an UnexpectedDataType Exception if barcodeInstMgr isn't an Adobe
 *		   instanceManager object.
 * @throws an UnexpectedState Exception if the "barcodeField" field isn't found
 *		   in the subform.
 */
function populateBarcodes(barcodeInstMgr)
{
	cTypeEnforcer.checkInstanceManager(barcodeInstMgr, "BarcodeUtil",
									  "populateBarcodes", "barcodeInstMgr");

	var barcodeDataList = buildBarcodeData();
	
	clearBarcodes(barcodeInstMgr);
	for(var i = 0; i &lt; barcodeDataList.length; i++)
	{
		var subformInstance = barcodeInstMgr.addInstance(1);
		var field = subformInstance.barcodeField;

		if (field != undefined)
		{
			field.rawValue = barcodeDataList[i];
		}
		else
		{
			throw cException.createInstance(
				 "BarcodeUtil.populateBarcodes() -barcodeField not found",
				 "UnexpectedState");
		}
	}
}

/** PRIVATE ******************************************************************/
/**
 * Gets the form's data as base64 encoded zip data that contains the XML
 * dataset(s).
 * @return a String containing the base64 encoded zipped dataset.
 */
function _encodeFormData()
{
	// extract the default dataset, beginning from the root node
	var rawDataset = xfa.resolveNode("datasets.data.#dataGroup[0]").saveXML();
	var zip = cJsZip.createInstance(cJsZip.DEFLATE);	
			
	zip.add(_FILE_NAME, rawDataset);
	return zip.generate();
}
</script>
               <script contentType="application/x-javascript" name="ConfigurationManager">//
/*******************************************************************************
 * A class that manages the form's configuration entries. It loads all
 * JavaScript classes in "config" packages (i.e. treats them as configuration
 * files). This creates a master configuration from all of these entries, so
 * individual entries can be over-ridden by those in files that are subsequently
 * loaded. Loading follows the ordering they are in the forms - proceding down
 * the first branches to the first leaves before proceding to the next leaves
 * and then the next branches.
 *
 * Configuration entry values can be of the following data types: Strings,
 * Numbers, Booleans, Dates, or Arrays.
 *
 * Note that this will fail to load without warning if there is a problem with
 * one of the script nodes (typically a JavaScript syntax problem that causes
 * the code to not compile)! If this is suspected to be the case, turn on
 * debugging in NodeUtil and check the Log for the last script processed - the
 * next one is the likely problem.
 */

//imports
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cMap = script.core.util.Map;
var cNodeUtil = script.core.util.NodeUtil;
var cObjectUtil = script.core.util.ObjectUtil;
var cStringUtil = script.core.util.StringUtil;

var content = null;

/**
 * Gets whether there is an entry for the specified key.
 * @param key the key whose presence in this configuration is to be tested.
 * @return a boolean - true if this configuration contains an entry for the
 *		   specified key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function containsKey(key)
{
	try
	{
		return _getContent().containsKey(key);
	}
	catch(exception)
	{
		throw cException.createInstance("ConfigurationManager.containsKey() "
			  + "encountered a problem: " + exception);
	}
}
	
/**
 * Gets the value for the specified key. Returns null if the configuration
 * doesn't contain an entry for this key.
 * @param key the key whose associated value is to be returned.
 * @return the value for the specified key, or null if the configuration
 *		   contains no entry for this key. Values can be of the following data
 *   	   types: Strings, Numbers, Booleans, Dates, or Arrays.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function get(key)
{
	try
	{
		return _getContent().get(key);
	}
	catch(exception)
	{
		throw cException.createInstance("ConfigurationManager.get() "
			  + "encountered a problem: " + exception.getMessage(),
    		  exception.getType());
	}
}
	
/**
 * Over-rides the value of the specified key in the configuration.
 * @param key the key whose associated value is to be added / updated. Note that
 *		  this is coerced to a String by JavaScript when enforcing uniqueness.
 *		  As a result, avoid using objects as keys since their String
 *		  equivalents are the same ("Object").
 * @param value the value to be associated with the specified key.
 * @return the previous value associated with specified key, or null if
 *		   there was no mapping for key. A null return can also indicate that
 *		   the configuration previously associated null with the specified key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function put(key, value)
{
	try
	{
		return _getContent().put(key, value);
	}
	catch(exception)
	{
		throw cException.createInstance("ConfigurationManager.put() "
			  + "encountered a problem: " + exception.getMessage(),
    		  exception.getType());
	}
}
	
/**
 * Lists the configuration entries.
 * @return the configuration entries.
 */
function asString()
{
	var buffer = "Configuration[\n";
	var isFirst = true;
	var keys = _getContent().keySet();
	
    for (var i=0; i &lt; keys.length; i++)
    {
	    if (isFirst)
	    {
			isFirst = false;
	    }
	    else
	    {
			buffer += ",\n";
	    }
		buffer += keys[i] + "= " + _getContent().get(keys[i]);
    }    	
	buffer += "]";
	return buffer;
}

//===== PRIVATE ================================================================

/**
 * Gets the content map that stores all of the configuration entries. This is
 * lazy loaded.
 * @return the content map that stores all of the configuration entries.
 */
function _getContent()
{
	if (content == null)
	{
		_load();
	}
	return content;
}

/**
 * Initializes the content Map by loading all JavaScript classes that are
 * emulating configuration files. These are in "config" script packages
 * (subforms) scattered through the code base.
 * @throws an InvalidConfigScript Exception if any of the configuration
 *		   scripts don't contain a content variable.
 * @throws an UnexpectedDataType Exception if any of the script packages are not
 *		   container nodes.
 */
function _load()
{
	var startTime = new Date().getTime();
	var configPackages = cNodeUtil.getScriptPackages("config");
	var scripts;

	content = cMap.createInstance();
	for (var i=0; i &lt; configPackages.length; i++)
	{
		try
		{
			scripts = cNodeUtil.getScripts(configPackages[i]);
		}
		catch(exception)
		{
			if (exception.className == "Exception")
			{
				throw cException.createInstance("ConfigurationManager._load():"
					  + "encountered a problem when processing script package '"
					  + cStringUtil.formatSomExpression(configPackages[i].somExpression) 
	    			  + "': " + exception.getMessage(),
	    			  exception.getType());
    		}
    		else
    		{
				throw cException.createInstance("ConfigurationManager._load():"
					  + "encountered a problem when processing script package '"
					  + cStringUtil.formatSomExpression(configPackages[i].somExpression) 
	    			  + "': " + exception,
	    			  "UnexpectedException");
    		}
		}
		for (var j=0; j &lt; scripts.length; j++)
		{
			_loadScript(scripts[j]);
		}
	}
	cLog.info("Configuration loaded with " + content.size() + " entries in "
			  + (new Date().getTime() - startTime) + "ms");
}

/**
 * Loads a specific JavaScript class that is emulating a configuration file.
 * @param aScript the JavaScript class that is emulating the file.
 * @throws an InvalidConfigScript Exception if aScript does not contain a
 *		   content variable.
 */
function _loadScript(aScript)
{
	if (aScript.content != undefined)
	{
	    content.putAll(cObjectUtil.getProperties(aScript.content));
    }
    else
    {
    	throw cException.createInstance("ConfigurationManager._loadScript():" 
    		  + " Configuration script '" 
    		  + cStringUtil.formatSomExpression(aScript.somExpression) 
    		  + "' does not contain a content variable",
    		  "InvalidConfigScript");
    }
}

</script>
               <script contentType="application/x-javascript" name="ControllerUtil">//
/*******************************************************************************
 * A class that contains utility functions for controllers.
 */

//imports
var cException = script.core.util.Exception;

/**
 * Checks that the passed value is a FormNode. These are heavily used by
 * controllers since they put a lot of these into constants. This is a simplified
 * function similar to those in TypeEnforcer;
 * - This only checks that the FormNode isn't null (not its data type),
 * - it does not return anything, and
 * - it creates an Exception message more appropriate to the situation.
 * @param value the value to be checked.
 * @param controllerName the name of the calling controller class for exception
 *		  reporting.
 * @param formNodeName the name of the FormNode in question for exception
 *		  reporting.
 * @throws an UnexpectedDataType Exception if value is undefined or null.
 */
function checkFormNode(value, controllerName, formNodeName)
{
	if (value == null)
	{
		throw cException.createInstance(controllerName + "." + formNodeName
										+ " is null");
  	}
}
</script>
               <script contentType="application/x-javascript" name="DataStore">//
/*******************************************************************************
 * A class used to store values that must persist. These are maintained in the
 * data DOM of the form so that they continue to exist after the form has been
 * saved and reopened.
 * This behaves in a similar way to a Map. At this point, it only supports keys
 * and values that are Strings.
 */

//imports
var cLog = script.core.util.Log;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var _BASE_SOM = "xfa.datasets"; //Where the data store is put
var _DATA_STORE_NODE_NAME = "dataStore";
var _DATA_STORE_SOM = _BASE_SOM + "." + _DATA_STORE_NODE_NAME;

var dataStoreNode = null;

/**
 * Gets whether there is an entry for the specified key.
 * @param key a string that contains the key whose presence in this data store
 *		  is to be tested.
 * @return a boolean - true if this data store contains an entry for the
 *		   specified key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function containsKey(key)
{
	cTypeEnforcer.checkString(key, "DataStore", "containsKey", "key");

	return (xfa.resolveNode(_DATA_STORE_SOM + "." + key) != null);
}
	
/**
 * Gets the value for the specified key. Returns null if the data store doesn't
 * contain an entry for this key.
 * @param key a string that contains the key whose associated value is to be
 *		  returned.
 * @return a String -the value for the specified key, or null if the data store
 *		   contains no entry for this key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function get(key)
{
	cTypeEnforcer.checkString(key, "DataStore", "get", "key");

	var dataNode = xfa.resolveNode(_DATA_STORE_SOM + "." + key);

	if (dataNode != null)
	{
		return dataNode.value;
	}
	return null;
}
	
/**
 * Sets the value of the specified key in the data store.
 * @param key a string that contains the key whose associated value is to be
 *		  added / updated.
 * @param value a String that contains the value to be associated with the
 *		  specified key. Note that if this is undefined or null, an empty String
 *		  will be stored.
 * @return a String -the previous value associated with specified key, or null
 *		   if there was no mapping for key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function put(key, value)
{
	cTypeEnforcer.checkString(key, "DataStore", "put", "key");
	value = cTypeEnforcer.checkString(value, "DataStore", "put", "value", true);

	var dataNode = xfa.resolveNode(_DATA_STORE_SOM + "." + key);
	var oldValue = null;

	if (dataNode == null) //Must be a new key
	{
		dataNode = xfa.datasets.createNode("dataValue", key);
		_getDataStoreNode().nodes.append(dataNode);
	}
	else
	{
		oldValue = dataNode.value;
	}
	dataNode.value = value;
	return oldValue;
}
	
/**
 * Removes the entry with the specified key from the data store.
 * @param key a string that contains the key whose associated value is to be
 *		  removed.
 * @return a String -the previous value associated with specified key, or null
 *		   if there was no mapping for key.
 * @throws an UnexpectedDataType Exception if key is undefined or null.
 */
function remove(key)
{
	cTypeEnforcer.checkString(key, "DataStore", "remove", "key");

	var dataNode = xfa.resolveNode(_DATA_STORE_SOM + "." + key);
	var oldValue = null;

	if (dataNode != null)
	{
		oldValue = dataNode.value;
		_getDataStoreNode().nodes.remove(dataNode);
	}
	return oldValue;
}
	
/**
 * Lists the configuration entries.
 * @return the configuration entries.
 */
function asString()
{
	var buffer = "DataStore[\n";
	var isFirst = true;
	var dataStoreNodes = _getDataStoreNode().nodes;
	
    for (var i=0; i &lt; dataStoreNodes.length; i++)
    {
	    if (isFirst)
	    {
			isFirst = false;
	    }
	    else
	    {
			buffer += ",\n";
	    }
		buffer += dataStoreNodes.item(i).name + "= " 
				  + dataStoreNodes.item(i).value;
    }    	
	buffer += "]";
	return buffer;
}

//===== PRIVATE ================================================================

/**
 * Gets the node that is used as a data store. This creates it if it doesn't
 * already exist.
 * @return the node that is used as a data store.
 */
function _getDataStoreNode()
{
	if (dataStoreNode == null)
	{
		dataStoreNode = xfa.resolveNode(_DATA_STORE_SOM);
		if (dataStoreNode == null) //Must be a new form
		{
			var baseNode = xfa.resolveNode(_BASE_SOM);
	
			dataStoreNode = xfa.datasets.createNode("dataGroup",
													_DATA_STORE_NODE_NAME);
			baseNode.nodes.append(dataStoreNode);
		}
	}
	return dataStoreNode;
}
</script>
               <script contentType="application/x-javascript" name="DateUtil">//
/*******************************************************************************
 * A class that contains utility functions for manipulating dates.
 */

//imports
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cNumberFormatter = script.core.util.NumberFormatter;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var ISO_8601_REGEXP = /(\d\d\d\d)(-)?(\d\d)(-)?(\d\d)(T)?(\d\d)(:)?(\d\d)(:)?(\d\d)(\.\d+)?(Z|([+-])(\d\d)(:)?(\d\d))/;

/**
 * Coerces the passed string to a Date. The string must follow the ISO 8601
 * standard. See "http://www.w3.org/TR/NOTE-datetime" for more details.
 * @param aString the string to be parsed.
 * @return a Date based on the passed String.
 * @throws an UnexpectedDataType Exception if aString is undefined, null, or not
 *		   a String.
 * @throws an InvalidArgument Exception if aString does not follow the ISO 8601
 * 		   standard.
 */
function parseIso8601Date(aString) {
	cTypeEnforcer.checkString(aString, "DateUtil", "parseIso8601Date",
							  "aString");

	var iso8601Date = aString.match(new RegExp(ISO_8601_REGEXP));

	if (iso8601Date != null)
	{
		var newDate = new Date();
		var offset = 0;
		 
		newDate.setUTCDate(1);
		newDate.setUTCFullYear(parseInt(iso8601Date[1],10));
		newDate.setUTCMonth(parseInt(iso8601Date[3],10) - 1);
		newDate.setUTCDate(parseInt(iso8601Date[5],10));
		newDate.setUTCHours(parseInt(iso8601Date[7],10));
		newDate.setUTCMinutes(parseInt(iso8601Date[9],10));
		newDate.setUTCSeconds(parseInt(iso8601Date[11],10));
		//Process the milliseconds if they are there
		if (iso8601Date[12])
		{
			newDate.setUTCMilliseconds(parseFloat(iso8601Date[12]) * 1000);
		}
		else
		{
			newDate.setUTCMilliseconds(0);
		}
		//Process the time zone offset, if it is there
		if (iso8601Date[13] != 'Z')
		{
			offset = (iso8601Date[15] * 60) + parseInt(iso8601Date[17],10);
			offset *= ((iso8601Date[14] == '-') ? -1 : 1);
			newDate.setTime(newDate.getTime() - offset * 60 * 1000);
		}
		return newDate;
	}
	throw cException.createInstance("DateUtil.parseIso8601Date(): '" + aString
		  + "' is not a valid ISO 8601 formatted date", "InvalidArgument");
}


/**
 * Converts the passed Date to a string that only includes the date portion.
 * This is a basic format identical to the date portion of an ISO 8601 date.
 * Equivalent to "yyyy-mm-dd"
 * @param aDate the Date to be converted.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return a String containing the formatted date portion of the passed Date.
 *		   Null if aDate was null.
 * @throws an UnexpectedDataType Exception if aDate is undefined, null, or not
 *		   a Date.
 */
function toDateString(aDate, allowUndefined) {
	cTypeEnforcer.checkDate(aDate, "DateUtil", "toDateString", "aDate",
							allowUndefined);

	if (aDate != null)
	{
		cLog.info("aDate: " + aDate.toDateString());
		return aDate.getFullYear() + "-" 
			   + cNumberFormatter.pad(aDate.getMonth() + 1, 2) + "-"
			   + cNumberFormatter.pad(aDate.getDate(), 2);
	}
	return null;
}
</script>
               <script contentType="application/x-javascript" name="Exception">//
/*******************************************************************************
 * A general Exception implementation. It provides the ability to specify the
 * exception name to minimize the need for subclassing. Note that, since over-
 * riding toString() is not supported and the console uses toString(), these
 * Exceptions are actually using Adobe's Error class which has implemented
 * toString().
 */

//imports
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;
 
/**
 * Gets a new Exception. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * @param message a string that contains the message the description of the
 *		  problem.
 * @param type (optional) a string that contains the type of the exception.
 * @return the new Exception instance
 * @throws UnexpectedDataType Exception if any of the parameters aren't as
 *		   indicated.
 */
function createInstance(message, type)
{
	cTypeEnforcer.checkString(message, "Exception","constructor", "message");
	cTypeEnforcer.checkString(type, "Exception", "constructor","type", true);

	var anError = new Error(message);

	anError.className = "Exception";

	if (type == undefined)
	{
		type = "Generic";
	}
	anError.type = type;
	anError.name = type + " Exception";
		
	//Add its custom methods
	/**
	 * Gets the details of this exception.
	 * @return a String listing this exception's properties.
	 */
	anError.getDetails = function()
	{	
		return script.core.util.Exception.getDetails(this);
	}

    /**
     * Gets the exception's message, which is typically the reason for the
     * failure.
     * @return a String that contains the message that describes the problem.
     */
    anError.getMessage = function()
	{
		return this.message;
	}
        
    /**
     * Gets the type of exception this is, if there is any specified.
     * @return a String that contains the type of exception. "Generic" if not
     *		   specified.
     */    
	anError.getType = function()
	{
		return this.type;
	}    

    /**
     * Describes this object. This is implemented to get the same result as
     * its toString(), which is implemented by Error.
     * @return the description of this exception.
     */
    anError.asString = function()
	{
		return this.toString();
	}

	return anError;
}

/**
 * Gets the details of the passed exception.
 * @param anException the exception, which can be anything. Usually this would
 *		  be an Adobe error or custom Exception.
 * @return a String. If passed an object (e.g. an Adobe error or custom
 *		   Exception), this lists its properties. Otherwise, it returns the
 *		   item it was passed.
 */
function getDetails(anException)
{	
	var buffer = "Exception Details:\n";

	if (typeof anException == 'object')
	{
	    for (var prop in anException)
	    {
	    	if (!cTypeChecker.isFunction(anException[prop]))
	    	{
		    	buffer += "* " + prop + ": " + anException[prop] + "\n";
	    	}
	    }
    }
    else
    {
    	buffer += anException + "\n";
    }
    return buffer;
}
</script>
               <script contentType="application/x-javascript" name="InstanceManagerUtil">//
/*******************************************************************************
 * This class provides functionality to augment Adobe's instanceManager object.
 * InstanceManagers are used to manage (add, remove, etc.) the instances of a
 * given subform.
 * Note that most of the provided methods require the subform's instanceManager
 * be passed as a parameter. These are obtained by prepending an underscore to
 * the name of the subform. For example, the instanceManager for
 * "Pla.subPla" is "Pla._subPla".
 */
//Dan changed reset and clear to use the minimum amount of active ingredients
//imports
var cLog = script.core.util.Log;
var cException = script.core.util.Exception;
var cFormNodeManager = script.core.model.FormNodeManager;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Adds a new instance of the subform being managed by the passed instanceManager
 * to the bottom of the collection.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @return the subform instance that was added.
 * @throws an UnexpectedDataType Exception if anInstanceManager isn't an Adobe
 *		   instanceManager object.
 */
function addInstance(anInstanceManager)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "addInstance", "anInstanceManager");

	var instance = anInstanceManager.addInstance(1);

	_updateNodeUI(instance);	
	return instance;		
}

/**
 * Removes all instances of the subform being managed by the passed
 * instanceManager.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @throws an UnexpectedDataType Exception if anInstanceManager isn't an Adobe
 *		   instanceManager object.
 */
function clearInstances(anInstanceManager)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "clearInstances", "anInstanceManager");

	for (var i=anInstanceManager.count; i &gt; anInstanceManager.min; )
	{
		removeInstance(anInstanceManager, --i );
	}
}

/**
 * Gets the number of instances there are of the subform being managed by the
 * passed instanceManager.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @return the number of subform instances that it is managing.
 * @throws an UnexpectedDataType Exception if anInstanceManager isn't an Adobe
 *		   instanceManager object.
 */
function getInstanceCount(anInstanceManager)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "getInstanceCount", "anInstanceManager");
	return anInstanceManager.count;
}

/**
 * Gets the instanceManager for the given somExpression, it reformats the
 * somExpression to the relative somExpression of its instanceManager.
 * @param aSomExpression a somExpression for an given Adobe node.
 * @return the instanceManager of the given somExpression.
 * @throws an UnexpectedDataType Exception if aSomExpression isn't a String.
 * @throws an InstanceManagerNotResolved Exception if aSomExpression can't
 *		   be resolved to an InstanceManager (it isn't a valid node, or the
 *		   node isn't repeating so doesn't have an InstanceManager).
 */
function getInstanceManagerForSom(aSomExpression)
{
	cTypeEnforcer.checkString(aSomExpression, "InstanceManagerUtil",
							  "getInstanceManagerForSom", "aSomExpression");

	var insMgrSom = aSomExpression;

	var lastDotIndex = aSomExpression.lastIndexOf(".");
	var lastBracketIndex = aSomExpression.lastIndexOf("[");

	if (lastBracketIndex != -1)
	{
		if (lastDotIndex &lt; lastBracketIndex)
		{
			// The regEx below removes the first "[number]" from the end
			insMgrSom = insMgrSom.replace(/\[\d*\]$/,"");
		}
	}

	// The regEx below removes everything from the end up to the last
	// "." and replace with "_"
	insMgrSom = insMgrSom.substr(0, lastDotIndex + 1) + "_" +
							insMgrSom.substr(lastDotIndex + 1);
	//insMgrSom = insMgrSom.replace(/[A-Za-z]*$/,"_") + 
	//						insMgrSom.substr(lastDotIndexNum + 1);

	var insMgr = xfa.resolveNode(insMgrSom);
	
	if (insMgr != null)
	{
		return insMgr;
	}
	else
	{
		var msg = "InstanceManagerUtil.getInstanceManagerForSom"
					+ "(aSomExpression): instance manager for " + 
					aSomExpression + " (" + insMgrSom 
					+ ") cannot be resolved.";
		throw cException.createInstance(msg, "InstanceManagerNotFound");
	}
}

/**
 * Gets whether the subform being managed by the passed instanceManager has any
 * instances.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @return true if there are any instances of the passed instanceManager's
 *		   subform.
 * @throws an UnexpectedDataType Exception if anInstanceManager isn't an Adobe
 *		   instanceManager object.
 */
function hasInstance(anInstanceManager)
{
	return getInstanceCount(anInstanceManager) &gt; 0;
}

/**
 * Makes sure that there is at least the indicated minimum number of instances of
 * the subform being managed by the passed instanceManager. New instances are added
 * to the bottom as required. Any existing instances are left untouched.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @param amount (optional) an integer representing the number of subform
 *		  instances there should be as a minimum. Defaults to 1.
 * @throws an UnexpectedDataType Exception if the amount isn't a number or if
 *		   anInstanceManager isn't an Adobe instanceManager object.
 */
function initializeInstances(anInstanceManager, amount)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "initializeInstances", "anInstanceManager");
	if(amount != undefined)
	{
		cTypeEnforcer.checkNumber(amount, "InstanceManagerUtil",
								 "initializeInstances", "amount");

		if (amount &lt; 0)
		{
			throw("InstanceManagerUtil.initializeInstances(amount): "
				  + amount + " must be &gt;= 0");		
		}
	}
	else
	{
		amount = 1;
	}

	if (anInstanceManager.count &lt; amount)
	{
		setNumberOfInstances(anInstanceManager, amount);
	}
}

/**
 * Inserts a new instance of the subform being managed by the passed
 * instanceManager to its collection at the passed index.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @param index an integer representing the 0 based index position of the subform
 *		  to insert.
 * @return the subform instance that was inserted.
 * @throws an UnexpectedDataType Exception if the index isn't a number, is out of
 *		   range, or if anInstanceManager isn't an Adobe instanceManager object.
 */
function insertInstance(anInstanceManager, index)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "insertInstance", "anInstanceManager");
	cTypeEnforcer.checkNumber(index, "InstanceManagerUtil", "insertInstance",
							 "index");

	if (index &lt; 0 || index &gt; anInstanceManager.count)
	{
		throw("InstanceManagerUtil.insertInstance(index): " + index
			  + " is out of range. There are " + anInstanceManager.count 
			  + " items" );		
	}

	var instance = anInstanceManager.insertInstance(index, 1);

	_updateNodeUI(instance);	
	return instance;		
}

/**
 * Removes an instance of the subform being managed by the passed instanceManager
 * from its collection at the passed index.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @param index an integer representing the 0 based index position of the subform
 *		  to remove.
 * @throws an UnexpectedDataType Exception if the index isn't a number, is out of
 *		   range, or if anInstanceManager isn't an Adobe instanceManager object.
 */
function removeInstance(anInstanceManager, index)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "removeInstance", "anInstanceManager");
	cTypeEnforcer.checkNumber(index, "InstanceManagerUtil", "removeInstance",
							 "index");

	if (index &lt; 0 || index &gt; (anInstanceManager.count - 1))
	{
		throw("InstanceManagerUtil.removeInstance(index): " + index
			  + " is out of range. There are " + anInstanceManager.count 
			  + " items" );		
	}

	anInstanceManager.removeInstance(index);
}

/**
 * Removes the passed subform or, optionally, the one with the specified index.
 * @param aSubform an Adobe subform object.
 * @param index (optional) an integer representing the 0 based index position of
 *		  the subform to remove.
 * @throws an UnexpectedDataType Exception if the index isn't a number, is out of
 *		   range, or if aSubform isn't an Adobe subform object.
 */
function removeSpecificInstance(aSubform, index)
{
	cTypeEnforcer.checkSubform(aSubform, "InstanceManagerUtil",
							  "removeSpecificInstance", "aSubform");

	if(index != undefined)
	{
		cTypeEnforcer.checkNumber(index, "InstanceManagerUtil",
								 "removeSpecificInstance", "index");

		if (index &lt; 0 || index &gt; (aSubform.instanceManager.count - 1))
		{
			throw("InstanceManagerUtil.removeSpecificInstance(index): "
				  + index + " is out of range. There are " 
				  + aSubform.instanceManager.count + " items" );		
		}
	}
	else
	{
		index = aSubform.index;
	}

	aSubform.instanceManager.removeInstance(index);
}

/**
 * Clears any existing instances of the subform being managed by the passed
 * instanceManager then adds the requested number of new instances.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @param amount an integer representing the number of new instances of the
 *        subform there should be.
 * @throws an UnexpectedDataType Exception if the amount isn't a number or if
 *		   anInstanceManager isn't an Adobe instanceManager object.
 */
function resetInstances(anInstanceManager, amount)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "resetInstances", "anInstanceManager");
	cTypeEnforcer.checkNumber(amount, "InstanceManagerUtil", "resetInstances",
							 "amount");

	clearInstances(anInstanceManager);
	for (var i=anInstanceManager.count; i &lt; amount; i++)
	{
		addInstance(anInstanceManager);
	}
}

/**
 * Sets the number of instances there are of the subform being managed by the
 * passed instanceManager. New instances are added to, or excess instances are
 * removed from, the bottom of the collection as required. Otherwise, existing
 * instances are left untouched.
 * @param anInstanceManager an Adobe subform's instanceManager object.
 * @param amount an integer representing the number of instances of the subform
 *        there should be.
 * @throws an UnexpectedDataType Exception if the amount isn't a number or if
 *		   anInstanceManager isn't an Adobe instanceManager object.
 */
function setNumberOfInstances(anInstanceManager, amount)
{
	cTypeEnforcer.checkInstanceManager(anInstanceManager, "InstanceManagerUtil",
									  "setNumberOfInstances", "anInstanceManager");
	cTypeEnforcer.checkNumber(amount, "InstanceManagerUtil", "setNumberOfInstances",
							 "amount");

	if (anInstanceManager.count &lt; amount)
	{
		for (var i=anInstanceManager.count; i &lt; amount; i++)
		{
			addInstance(anInstanceManager);
		}
	}
	else if (anInstanceManager.count &gt; amount)
	{
		for (var i=anInstanceManager.count; i &gt; amount; i--)
		{
			removeInstance(anInstanceManager, i - 1);
		}
	}
}

//===== PRIVATE ================================================================

/**
 * Updates the User Interface components of the passed Adobe Node instance. This
 * is typically called when a specific node of the form (and everything below it)
 * needs to be adjusted (e.g. labels need to be translated).
 * This will issue a warning if the passed Node does not have an equivalent
 * FormNode.
 * @param nodeInstance the instance of Adobe Node that should be updated.
 */
function _updateNodeUI(nodeInstance)
{
	var formNode = cFormNodeManager.getFormNodeForSom(nodeInstance.
													  somExpression);

	if (formNode != null)
	{
		formNode.updateUI(nodeInstance);
	}
	else
	{
		cLog.warn("InstanceManagerUtil._updateNodeUI(): no FormNode found for"
				  + " node instance '" 
				  + cStringUtil.formatSomExpression(nodeInstance.somExpression) 
				  + "'");
	}
}
</script>
               <script contentType="application/x-javascript" name="Log">//
/*******************************************************************************
 * This class is used to log messages, and behaves in a similar way to Log4j.
 * It will look for a "logLevel" entry in configuration for its settings.
 */

//imports
var cConfigurationManager = script.core.util.ConfigurationManager;
var cException = script.core.util.Exception;
var cHost = xfa.host;
var cObjectUtil = script.core.util.ObjectUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;
var cXfaLog = xfa.log;

var LEVEL_CRITICAL = 0; //Valid levels
var LEVEL_ERROR = 1;
var LEVEL_WARN = 2;
var LEVEL_INFO = 3;
var LEVEL_TRACE = 4;

var _BASE_FILE_NAME = "log";
var _FILE_EXTENSION = ".txt";
var _LEVEL_UNSET = 5;
var _LEVELS = ["Critical", "Error", "Warn", "Info", "Trace", "Unset"];
var _LOG_LEVEL_KEY = "Log_logLevel"; //In the configuration
var _MAX_CONSOLE_SIZE = 60000; //Number of characters
var _MAX_FILE_SIZE = 500000; //Number of characters
var _SHOW_EXCEPTION_DETAIL_KEY = "Log_showExceptionDetail"; //In the configuration
var _UNSET_WARNING = " &gt;Log level not set yet&lt;";
var _WRITE_TO_FILE_KEY = "Log_writeToFile"; //In the configuration

var acrobatDocument = null; //Document (used for writing the file)
var console_cache = "\r\nNew Log started: " + new Date() + "\r\n"; //Mirrors the console for writing to file
var console_size = 0; //Keeps track of the console size in characters
var isServer = (cHost.name == "XFAPresentationAgent");
var logLevel = _LEVEL_UNSET; //Until it is loaded from the configuration
var showExceptionDetail = false; //Until it is loaded from the configuration
var writeToFile = false; //Until it is loaded from the configuration

/**
 * Sets the Adobe Document object to be used when writing log entries into a
 * file. The easiest way to retrieve that object is by calling "event.target"
 * from an event. As a result, it is recommended that this be called as the
 * first thing in your form initialization event processing.
 * @param an Adobe Document object to be used when writing log entries to file.
 * @throws an UnexpectedDataType Exception if aDocument is undefined, null, or
 *		   isn't an Adobe Document object.
 */
function setAcrobatDocument(aDocument)
{
	if (aDocument == undefined ||
		aDocument.toString() != "[object Doc]")
	{
		throw cException("Log.setAcrobatDocument(aDocument) requires an Adobe"
			  + " document, but got a " + aDocument, "UnexpectedDataType");
	}
	acrobatDocument = aDocument;
}

/**
 * Gets the level of messages that are to be logged. Refer to the class
 * constants to understand the meaning of the values.
 * @return a number that indicates the level of messages that are to be logged.
 */
function getLogLevel()
{
	if (logLevel == _LEVEL_UNSET)
	{
		_loadFromConfig();
	}
	return logLevel;		
}

/**
 * Sets the level of messages that are to be logged. This must be set to one of
 * class constants.
 * @param aNumber the message to be logged.
 * @throws an UnexpectedDataType Exception if aNumber is undefined, null, or
 *		   isn't a number.
 * @throws an InvalidArgument Exception if aNumber is an invalid level.
 */
function setLogLevel(aNumber)
{
	cTypeEnforcer.checkNumber(aNumber, "Log", "setLogLevel", "aNumber");

	if (aNumber &gt; 0 &amp;&amp; aNumber &lt; _LEVELS.length)
	{
		logLevel = aNumber;		
		_logMessage("LOG: Log.logLevel set to " + _LEVELS[aNumber]);
	}
	else
	{
		throw cException.createInstance(
			  "Log.setLogLevel(aNumber) - invalid log level '" + aNumber + "'",
			  "InvalidArgument");
	}
}

/**
 * Gets whether an optional Exception, when passed, is displayed using its
 * toString() or shows its full detail (i.e. includes the stack trace).
 * @return a boolean that is true if Exceptions should have their full detail
 *		   displayed.
 */
function isShowExceptionDetail()
{
	return showExceptionDetail;		
}

/**
 * Sets whether an optional Exception, when passed, is displayed using its
 * toString() or shows its full detail (i.e. includes the stack trace).
 * @param aBoolean true if Exceptions should have their full detail displayed.
 * @throws an UnexpectedDataType Exception if aBoolean is undefined, null, or
 *		   isn't a boolean.
 */
function setShowExceptionDetail(aBoolean)
{
	cTypeEnforcer.checkBoolean(aBoolean, "Log", "setShowExceptionDetail",
							   "aBoolean");

	showExceptionDetail = aBoolean;		
	_logMessage("LOG: Log.showExceptionDetail set to " + showExceptionDetail);
}

/**
 * Gets whether this should also write log entries into a file. When set to true,
 * this will create a file attachment in the form with the log entries. These
 * entries are cached and written to the file when _MAX_CONSOLE_SIZE is exceeded
 * or when flushFileCache() is called.
 * Note: when using this feature, setAcrobatDocument() must be called from an
 * initialization event and flushFileCache() must be called from a preSave event.
 * @return a boolean true if this should also write log entries into a file.
 */
function iswriteToFile()
{
	return writeToFile;		
}

/**
 * Sets whether this should also write log entries into a file. When set to true,
 * this will create a file attachment in the form with the log entries. These
 * entries are cached and written to the file when _MESSAGE_MAX_SIZE is exceeded
 * or when flushFileCache() is called.
 * Note: when using this feature, setAcrobatDocument() must be called from an
 * initialization event and flushFileCache() must be called from a preSave event.
 * @param aBoolean true if this should also write log entries into a file.
 * @throws an UnexpectedDataType Exception if aBoolean is undefined, null, or
 *		   isn't a boolean.
 */
function setWriteToFile(aBoolean)
{
	cTypeEnforcer.checkBoolean(aBoolean, "Log", "setWriteToFile",
							   "aBoolean");

	writeToFile = aBoolean;		
	_logMessage("LOG: Log.writeToFile set to " + writeToFile);
}

/**
 * Logs a critical message. Typically used when an event has happened that will
 * cause the application to behave erratically or cease to function at all.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function critical(message, anException)
{
	if (getLogLevel() == _LEVEL_UNSET)
	{
		message += _UNSET_WARNING;
	}
	_logMessage("CRIT " + message, anException); //These are always logged
}

/**
 * Logs an error message. Typically used when an event has happened that is
 * unexpected / should never happen, but that the application can recover from.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function error(message, anException)
{
	var logLevel = getLogLevel();
	
	if (logLevel &gt;= LEVEL_ERROR)
	{
		if (logLevel == _LEVEL_UNSET)
		{
			message += _UNSET_WARNING;
		}
		_logMessage("ERR " + message, anException);		
	}
}

/**
 * Logs an information message. Used to indicate basic processing flow / values
 * for high-level debugging / code tracing.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function info(message, anException)
{
	var logLevel = getLogLevel();
	
	if (logLevel &gt;= LEVEL_INFO)
	{
		if (logLevel == _LEVEL_UNSET)
		{
			message += _UNSET_WARNING;
		}
		_logMessage("INFO " + message, anException);		
	}
}

/**
 * Logs a test result message. Used to record unit test results.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function test(message, anException)
{
	_logMessage("TEST " + message, anException);	//These are always logged	
}

/**
 * Logs a debug/trace message. Used for detailed debugging / code tracing. This
 * is used for the highest, most verbose level of activity reporting.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function trace(message, anException)
{
	var logLevel = getLogLevel();
	
	if (logLevel &gt;= LEVEL_TRACE)
	{
		if (logLevel == _LEVEL_UNSET)
		{
			message += _UNSET_WARNING;
		}
		_logMessage("TRACE " + message, anException);		
	}
}

/**
 * Logs a warning message. Typically used when an event has happened that may
 * indicate a potential problem. A situation that is permissible but unlikely.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function warn(message, anException)
{
	var logLevel = getLogLevel();
	
	if (logLevel &gt;= LEVEL_WARN)
	{
		if (logLevel == _LEVEL_UNSET)
		{
			message += _UNSET_WARNING;
		}
		_logMessage("WARN " + message, anException);		
	}
}

/**
 * When the Log is set to write log entries into a file, they are temporarily
 * cached in memory. This is called to append them to a file attachment in the
 * form and clear the cache. Note that the form must be subsequently saved for
 * the attachment to be preserved.
 * This should be called by a preSave event to make sure that all entries are
 * written to the file.
 */
function flushFileCache()
{
	if (writeToFile)
	{	
		_saveToFile(console_cache);
		console_cache = "";
		console_size = 0;
	}
}

//===== PRIVATE ================================================================

/**
* Gets whether a file (Data Object) with the passed fileName exists or not.
* Unfortunately, this has to do a sequential scan to determine this (it's the
* only safe way to do it).
* Note: this assumes that this is not running on a server and that acrobatDocument
* is not null.
* @param fileName a String that contains the name of the file in question.
* @return boolean true if the file is found, false otherwise.
*/
function _fileExists(fileName)
{
	var dataObjects = acrobatDocument.dataObjects;
	
	if (dataObjects != null)
	{
		for (var i = 0; i &lt; dataObjects.length; i++)
		{
			if (dataObjects[i].name == fileName)
			{
				return true;
			}
		}
	}
	return false;
}

/**
* Gets the name of a file to use for storing log output. This will look for the
* first available file that isn't already too large. It will create a new one if
* none of the existing files is appropriate.
* Note: this assumes that this is not running on a server and that
* acrobatDocument is not null.
* @return fileName a String that contains the name of the file to use for
*		  storing log output.
*/
function _getFileName()
{
	var fileName = _BASE_FILE_NAME + _FILE_EXTENSION;
	
	for (var i=2; i &lt; 100000; i++)
	{
		if(_fileExists(fileName))
		{
			//the file exists, check its size
			var dataObject = acrobatDocument.getDataObject(fileName);

			if (dataObject.size &lt; _MAX_FILE_SIZE) //TODO implement
			{
				return fileName;
			}
		}
		else
		{
			acrobatDocument.createDataObject(fileName, ""); //Put in an empty string for now
			return fileName;
		}
		fileName = _BASE_FILE_NAME + i + _FILE_EXTENSION;
	}

	//Should never happen
	return _BASE_FILE_NAME + 100001 + _FILE_EXTENSION;	
}

/**
 * Loads the logLevel, showExceptionDetail and writeToFile from the
 * configuration. They are only changed if the entries were found and loaded
 * correctly.
 */
function _loadFromConfig()
{	
	var logLevelEntry = cConfigurationManager.get(_LOG_LEVEL_KEY);
	var showExceptionDetailEntry = cConfigurationManager.get(
								   _SHOW_EXCEPTION_DETAIL_KEY);
	var writeToFileEntry = cConfigurationManager.get(_WRITE_TO_FILE_KEY);
							
	//Can't really issue any warnings here...

	//Do this one first so the others are recorded in the file		   	
	if (writeToFileEntry != null)
	{
		if (cTypeChecker.isBoolean(writeToFileEntry))
		{
			setWriteToFile(writeToFileEntry);
		}
		else
		{
			_logMessage("LOG: Log.writeToFile not set - configuration entry '" 
						+ writeToFileEntry + "' is not a boolean");
		}
	}

	if (logLevelEntry != null)
	{
		if (cTypeChecker.isNumber(logLevelEntry))
		{
			setLogLevel(logLevelEntry);
		}
		else
		{
			_logMessage("LOG: Log.logLevel not set - configuration entry '" 
						+ logLevelEntry + "' is not a valid level");
		}
	}
	
	if (showExceptionDetailEntry != null)
	{
		if (cTypeChecker.isBoolean(showExceptionDetailEntry))
		{
			setShowExceptionDetail(showExceptionDetailEntry);
		}
		else
		{
			_logMessage("LOG: Log.showExceptionDetail not set - configuration entry '" 
						+ showExceptionDetailEntry + "' is not a boolean");
		}
	}
}

/**
 * Logs the message to the destination. So far, only console logging is supported.
 * @param message the message to be logged.
 * @param anException (optional) an Exception that was thrown, This is appended
 *		  to the message when it is displayed.
 */
function _logMessage(message, anException)
{	
	if (anException != undefined)
	{
		message += ": ";
		if (showExceptionDetail)
		{
			message += cException.getDetails(anException);
		}
		else
		{
			message += cObjectUtil.asString(anException);
		}
	}
	
	if (isServer)
	{		
        cXfaLog.message(0, _safeguardConsole(message)); //Not really well supported
    }
	else
	{		
		console.println(_safeguardConsole(message));			
	}
}

/**
 * When this is set to write log entries into a file, they are temporarily
 * cached in memory. This is called to append them to a file attachment in the
 * form and clear the cache. Note that the form must be subsequently saved for
 * the attachment to be preserved.
 *
 * This should be called by the presave event.
 */
function _safeguardConsole(message)
{
	var allowedSize = _MAX_CONSOLE_SIZE - console_size;
	
	//If it's within limits
	if (message.length &lt;= allowedSize)
	{
		if (writeToFile)
		{	
			console_cache += message + "\r\n";
		}
		console_size += message.length + 1; //Allow for the carriage return
		return message;
	}
	
	//If it's not within limits
	console.clear();

	if (writeToFile)
	{	
		console_cache += message.substr(0, allowedSize);
		flushFileCache();
	}
	message = message.substr(allowedSize);
	console_size = 0;

	return _safeguardConsole(message);
}

/**
* Saves the passed string to a file that is contained within this pdf document.
* This appends it to an existing file if there is one that isn't already too
* large. Otherwise, it creates a new file.
* @param aString the String to append
*/
function _saveToFile(aString)
{
	if (isServer)
	{
		return;
	}

	if (acrobatDocument == null) //Hasn't been set yet!
	{
		//This must write directly to the console since we may be currently in
		//the process of writing to the Log.
		console.println("LOG: Log._appendToFile cannot write the log to a file"
				+ " since the Adobe Document object hasn't been set. Please"
				+ " refer to Log.setAcrobatDocument() for instructions.");
		return;
	}

	//Unfortunately there isn't an api to append data directly into an existing
	//file. This was originally done by updating the original file using
	//streams but that approach caused GPFs so a complete replacement is done.
	var fileName = _getFileName(); //Must already exist
	var fileContentStream = acrobatDocument.getDataObjectContents(fileName);
	var fileContent = SOAP.stringFromStream(fileContentStream, "utf-8");

	acrobatDocument.removeDataObject(fileName);
	acrobatDocument.createDataObject(fileName, fileContent + aString);
}
</script>
               <script contentType="application/x-javascript" name="Map">//
/*******************************************************************************
 * An object that maps keys to values. A map cannot contain duplicate keys; each
 * key can map to at most one value. Note that, although both the keys and
 * values can be any desired value, using Objects as keys should be avoided
 * since JavaScript coerces them to their String equivalents (which is always
 * "Object") when enforcing uniqueness.
 * This implements most of the methods in Java's Map interface.
 */

//imports
var cException = script.core.util.Exception;
var cObjectUtil = script.core.util.ObjectUtil;

/**
 * Gets a new Map. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * @return the new Map instance
 */
function createInstance()
{
	return new MapClass();
}

/**
 * Class implementation
 */
function MapClass()
{
	this.className = "Map";
	
	this.content = {};
	
	/**
	 * Returns a "simple" map with the values contained in this Map object.
	 * These are simple JavaScript objects created as follows: {key1: value1}
	 * Some of the Adobe custom objects expect these structures as parameters.
	 * @return a simple map of the values contained in this Map.
	 */
    this.asSimpleMap = function()
    {
    	var result = {};

	    for (var prop in this.content)
	    {
    		result[prop] = this.get(prop);
	    }    	
		return result;
	}
	
	/**
	 * Removes all mappings from this map.
	 */
    this.clear = function()
    {
	    this.content = {};    	
	}
	
	/**
	 * Returns whether this map contains a mapping for the specified key.
	 * Note that this is accurate even if the key maps to null or undefined.
	 * @param key the key whose presence in this map is to be tested.
	 * @return a boolean - true if this map contains a mapping for the
	 *		   specified key.
	 * @throws an UnexpectedDataType Exception if key is undefined or null.
	 */
    this.containsKey = function(key)
    {
		if (key == undefined)
		{
			throw cException.createInstance(
				  "Map.containsKey(): key cannot be undefined or null",
				  "UnexpectedDataType");
		}
		if(this.content[key] != undefined ){
			return true;
		}
		/* don't need to loop and find the key
	    for (var prop in this.content)
	    {
	    	if (prop == key)
	    	{
	    		return true;
	    	}
	    }*/    	
		return false;
	}
	
	/**
	 * Returns whether this map maps one or more keys to the specified value.
	 * @param value the value whose presence in this map is to be tested.
	 * @return a boolean - true if this map maps one or more keys to the
	 *		   specified value.
	 */
    this.containsValue = function(value)
    {
	    for (var prop in this.content)
	    {
    		if (this.get(prop) == value)
    		{
    			return true;
    		}
	    }   
	    return false;
	}
	
	/**
	 * Returns the value to which this map maps the specified key. Returns
	 * null if the map contains no mapping for this key. A return value
	 * of null does not necessarily indicate that the map contains no
	 * mapping for the key; it's also possible that the map explicitly maps
	 * the key to null or undefined.
	 * @param key the key whose associated value is to be returned.
	 * @return the value to which this map maps the specified key Null if
	 *		   the map contains no mapping for this key or if the key maps
	 *		   to null or undefined.
	 * @throws an UnexpectedDataType Exception if key is undefined or null.
	 */
    this.get = function(key)
    {
		if (key == undefined)
		{
			throw cException.createInstance(
				  "Map.get(): key cannot be undefined or null",
				  "UnexpectedDataType");
		}
		if (this.content[key] != undefined)
		{
			return this.content[key];
		}
		return null;		
	}
	
	/**
	 * Returns whether this map contains no key-value mappings.
	 * @return a boolean - true if this map contains no key-value mappings.
	 */
    this.isEmpty = function()
    {
		return this.size() == 0;
	}
	
	/**
	 * Returns an array of the keys contained in this map. The array is
	 * independant of this map, so changes to the map are not reflected in the
	 * array and vice-versa.
	 * @return an Array containing the keys contained in this map.
	 */
    this.keySet = function()
    {
    	var result = new Array();

	    for (var prop in this.content)
	    {
	    	result.push(prop);
	    }    	
		return result;
	}
	
	/**
	 * Associates the specified value with the specified key in this map. If
	 * the map previously contained a mapping for this key, the old value is
	 * replaced by the specified value.
	 * @param key the key whose associated value is to be added / updated.
	 *		  Note that this is coerced to a String by JavaScript when
	 *		  enforcing uniqueness. As a result, avoid using objects as keys
	 *		  since their String equivalents are the same ("Object").
	 * @param value the value to be associated with the specified key.
	 * @return the previous value associated with specified key, or null if
	 *		   there was no mapping for key. A null return can also indicate
	 *		   that the map previously associated undefined or null with the
	 *		   specified key.
	 * @throws an UnexpectedDataType Exception if key is undefined or null.
	 */
    this.put = function(key, value)
    {
		if (key == undefined)
		{
			throw cException.createInstance(
				  "Map.put(): key cannot be undefined or null",
				  "UnexpectedDataType");
		}

    	var existingValue = this.get(key);
    	
		this.content[key] = value;
		return existingValue;
	}
	
	/**
	 * Copies all of the mappings from the specified map to this map. The
	 * effect of this call is equivalent to that of calling put(k, v) on this
	 * map once for each mapping from key k to value v in the specified map.
	 * @param aMap the Map whose mappings are to be stored in this map.
	 * @throws an UnexpectedDataType Exception if key is undefined or null.
	 */
    this.putAll = function(aMap)
    {
    	var keys = aMap.keySet();
    	
		for (var i=0; i &lt; keys.length; i++)
		{
			this.put(keys[i], aMap.get(keys[i]));
		}
	}
	
	/**
	 * Removes the mapping for this key from this map if it is present.
	 * @param key key whose mapping is to be removed from the map.
	 * @return the previous value associated with specified key, or null if
	 *		   there was no mapping for key. A null return can also indicate
	 *		   that the map previously associated undefined or null with the
	 *		   specified key.
	 * @throws an UnexpectedDataType Exception if key is undefined or null.
	 */
    this.remove = function(key)
    {
		if (key == undefined || key == null)
		{
			throw cException.createInstance(
				  "Map.remove(): key cannot be undefined or null",
				  "UnexpectedDataType");
		}

    	var existingValue = this.get(key);
    	
		delete this.content[key];
		return existingValue;
	}
	
	/**
	 * Returns the number of key-value mappings in this map.
	 * @return the number of key-value mappings in this map.
	 */
    this.size = function()
    {
		return this.keySet().length;
	}
	
	/**
	 * Returns an array of the values contained in this map. The array is
	 * independant of this map, so changes to the map are not reflected in the
	 * array and vice-versa.
	 * @return an Array of the values contained in this map. This will not
	 *		   include values of undefined or null.
	 */
    this.values = function()
    {
    	var result = new Array();
    	var value;

	    for (var prop in this.content)
	    {
    		value = this.get(prop);
    		if (value  != undefined)
    		{
    			result.push(value);
    		}
	    }    	
		return result;
	}
		
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		var isFirst = true;
		
	    for (var prop in this.content)
	    {
    		if (isFirst)
    		{
				isFirst = false;
    		}
    		else
    		{
				buffer += ",\n";
    		}
			buffer += prop + "= " + cObjectUtil.asString(this.get(prop));
	    }    	
		buffer += "]";
		return buffer;
	}
}
</script>
               <script contentType="application/x-javascript" name="NodeUtil">//
/*******************************************************************************
 * This class provides functionality to augment Adobe's node object.
 *
 * Note that some of these routines are used to load the configuration, so Log
 * cannot be used for debugging since that will create an endless loop. Write
 * out directly to the console instead.
 */

//imports
var cException = script.core.util.Exception;
var cFormNodeManager = script.core.model.FormNodeManager;
var cLog = script.core.util.Log;
var cStringUtil = script.core.util.StringUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var TOP_SCRIPT_NODE = xfa.resolveNode("script");
var _DEBUG_MODE = false;
var _PADDING = "                                                                                                    ";
var _TAB_WIDTH = 2;

/**
 * A comparator used to sort nodes by their names.
 */
var caseInsensitiveNodeComparator = function(x, y){ 
	if (x.name == undefined) //Should never happen
	{
		throw cException.createInstance("Node '" 
    		  + StringUtil.formatSomExpression(x.somExpression) 
    		  + "' does not contain a valid name variable",
    		  "NodeWithoutName");
	}
	
	if (y.name == undefined) //Should never happen
	{
		throw cException.createInstance("Node '" 
    		  + StringUtil.formatSomExpression(y.somExpression) 
    		  + "' does not contain a valid name variable",
    		  "NodeWithoutName");
	}
	
	xString = String(x.name).toUpperCase();
	yString = String(y.name).toUpperCase();

	if (xString &gt; yString)
	{
		return 1;
	}
	if (xString &lt; yString)
	{
		return -1;
	}   
	return 0; 
}

/**
 * Gets the child node of the passed node with the passed FormNode key.
 * @param aNode the node whose child is of interest.
 * @param childFormNodeKey a String that contains the FormNode key of the child
 *		  node to be returned.
 * @return the child node with the specified key, or null if there is none
 *		   found for this key. This will issue a warning if the FormNode for the
 *		   child is not found. If there is nore than one child with this key,
 *		   the first will be returned.
 * @throws an UnexpectedDataType Exception if either of the parameters is
 *		   undefined, null, or the wrong data type.
 */
function getChildNode(aNode, childFormNodeKey)
{
	cTypeEnforcer.checkNode(aNode, "NodeUtil", "getChildNode", "aNode");
	cTypeEnforcer.checkString(childFormNodeKey, "NodeUtil", "getChildNode",
							  "childFormNodeKey");
	
	var childFormNode = cFormNodeManager.getFormNodeForKey(childFormNodeKey);
	
	if (childFormNode != null)
	{
		return xfa.resolveNode(aNode.somExpression + "." 
							   + childFormNode.getSomExpression());
	}
	return null;
}

/**
 * Convert the passed NodeList into String format.
 * @param aNodeList the Node List to be converted into String.
 * @return a String that contains a comma delimited list of node names. E.g.
 *		   "nodeList[node1, node2, node3]".
 */
function getNodeListAsString(aNodeList)
{

	cTypeEnforcer.checkSpecificCustomObject(aNodeList, "NodeUtil",
				  "getNodeListAsString", "aNodeList", "nodeList");

	var buffer = "nodeList[";
	var isFirst = true;
	
    for (var i=0; i &lt; aNodeList.length; i++)
    {
	    if (isFirst)
	    {
			isFirst = false;
	    }
	    else
	    {
			buffer += ", ";
	    }
		buffer += aNodeList.item(i).name;
    }    	
	buffer += "]";
	return buffer;
}

/**
 * Gets the peer node to the passed node with the passed FormNode key.
 * @param aNode the node whose peer is of interest.
 * @param peerFormNodeKey a String that contains the FormNode key of the peer
 *		  node to be returned.
 * @return the peer node with the specified key, or null if there is none
 *		   found for this key. This will issue a warning if the FormNode for the
 *		   peer is not found. If there is nore than one peer with this key,
 *		   the first will be returned.
 * @throws an UnexpectedDataType Exception if either of the parameters is
 *		   undefined, null, or the wrong data type.
 */
function getPeerNode(aNode, peerFormNodeKey)
{
	cTypeEnforcer.checkNode(aNode, "NodeUtil", "getPeerNode", "aNode");
	cTypeEnforcer.checkString(peerFormNodeKey, "NodeUtil", "getPeerNode",
							  "peerFormNodeKey");
	
	return getChildNode(aNode.parent, peerFormNodeKey);
}

/**
* Gets the first ancestor that is repeating (i.e. has 2 or more potential
* instances).
* @param aNode The node to start the upward traversal
* @param startAtParent(optional) a boolean that indicates whether the search
*		 include the passed node itself. True indicates that it should skip the
*		 node and start at its parent. Defaults to False.
* @return The Adobe Node if successful, or null if the traversal reaches the 
*		  form's root node.
*/
function getRepeatingAncestorNode(aNode, startAtParent)
{
	cTypeEnforcer.checkNode(aNode, "NodeUtil", "getRepeatingAncestorNode",
						    "aNode");
	startAtParent = cTypeEnforcer.checkBoolean(startAtParent, "NodeUtil",
					"getRepeatingAncestorNode", "startAtParent", true);
	
	if (startAtParent)
	{
		aNode = aNode.parent;						
	}
	// if we hit the root node, stop searching
	while(aNode.parent.className != "form")
	{
		// if this node repeats, return it
		if(aNode.className == "subform" &amp;&amp; aNode.occur.max != 1)
		{
			return aNode;
		}
		
		// otherwise, look at its parent node
		aNode = aNode.parent;						
	}
	
	// none of the ancestors repeat, return null;
	return null;
}

/**
 * Gets the JavaScript script nodes that are in the passed package (container
 * node). This only returns immediate children.
 * @param scriptPackage the container node that is the JavaScript package
 *		  (subfolder) to be checked.
 * @return an array of script nodes in the same order as they were in the
 *		   package. An empty array if there weren't any scripts nodes in the
 *		   package.
 * @throws an UnexpectedDataType Exception if scriptPackage is not a container
 *		   node.
 */
 function getScripts(scriptPackage) {
	if (!scriptPackage.isContainer)
	{
		throw cException.createInstance("NodeUtil.getScripts(): scriptPackage is"
			  + " not the correct type of node - it must be a container",
			  "UnexpectedDataType");
	}

	var children = scriptPackage.nodes; //list
	var results = new Array();
	
	if (children != null) //Just being safe
	{
		var scripts;

		for (var i=0; i &lt; children.length; i++)
		{
			//Scripts are in a variables node under the parent node
			if (children.item(i).className == "variables")
			{
				scripts = children.item(i).nodes;
				break;
			}
		}
		if (scripts != null)
		{
			for (var i=0; i &lt; scripts.length; i++)
			{
				if (scripts.item(i).className == "script")
				{
					results.push(scripts.item(i));
				}
			}
		}
	}
	
	return results;
}

/**
 * Gets all nodes with the indicated name that represent JavaScript packages.
 * @param packageName a string that contains the name of the script packages
 *		  of interest.
 * @return an array of nodes in the same order as they were found. An empty
 *		   array if there weren't any nodes with the indicated name.
 */
function getScriptPackages(packageName)
{
	var results = new Array();
	
	if (_DEBUG_MODE)
	{
		console.println("&gt;&gt;&gt; NodeUtil.getScriptPackages starting dump for "
						+ packageName + ":");
	}
	_searchForScriptPackageNode(TOP_SCRIPT_NODE, packageName, results);
	if (_DEBUG_MODE)
	{
		console.println("&gt;&gt;&gt; NodeUtil.getScriptPackages done. Returning " 
						+ results.length + " scripts");
	}
	return results;
}

/**
 * Gets the "peer" of the passed node in the template structure. The returned
 * node contains the settings that it had when it was originally defined in the
 * IDE.
 * @param aNode an Adobe node (field) on the form.
 * @return the equivalent Adobe node in the template structure. Null if the
 *		   passed node had no equivalent in the template (i.e. must have been
 *		   created programmatically).
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node.
 */
function getTemplate(aNode)
{
	cTypeEnforcer.checkNode(aNode, "NodeUtil", "hasProperty", "aNode");
	
	var som = cStringUtil.generalizeSomExpression(aNode.somExpression);

	som = som.replace(/xfa\.form/g, "xfa.template");

	return xfa.resolveNode(som);
}

/**
 * Gets whether the passed node has the passed property. As of Adobe 9, an
 * exception is thrown if code refers to a node property that doesn't exist.
 * This is non-standard behaviour - other objects simply return undefined.
 * Nodes now have an isPropertySpecified() method to test for the property's
 * existance, however that method always returns false in the current Adobe
 * implementation.
 * @param aNode an Adobe node (field) on the form.
 * @param propertyName a String that contains the name of the property in
 *		  question.
 * @return a boolean - true if the passed node has the passed property.
 * @throws an UnexpectedDataType Exception if either of the parameters is
 *		   undefined, null, or isn't the indicated data type.
 */
function hasProperty(aNode, propertyName)
{
	cTypeEnforcer.checkNode(aNode, "NodeUtil", "hasProperty", "aNode");
	cTypeEnforcer.checkString(propertyName, "NodeUtil", "hasProperty",
							  "propertyName");
	
	//Nodes that don't have the property will throw an exception.
	try
	{
		aNode[propertyName]; //Try to touch it
		return true;
	}
	catch (exception)
	{
		return false;
	}
}

/**
 * Sorts the passed array of Nodes "in place" using a case insensitive sort.
 * Node array is not being type checked because 
 * @param aNodeArray the Node List to be sorted.
 */
function sortNodeArray(aNodeArray)
{
	aNodeArray.sort(caseInsensitiveNodeComparator);
}

/**
 * Sets the value of the passed node to the passed value. Note that this does
 * not alter the node if its current value is the same as the one passed.
 * This is done to avoid unnecessary UI updates.
 * @param aNode an Adobe node (field) on the form.
 * @param value the new value for the field. This must be a String, boolean,
 *		  number, or null.
 * @return a boolean - true if the node was updated.
 * @throws an UnexpectedDataType Exception if the aNode is undefined, null, or
 *		   isn't an Adobe node or if the value isn't one of the required types.
 */
 //TODO Deprecated
function updateNode(aNode, value)
{
	cLog.warn("NodeUtil.updateNode() has been deprecated - please use UiUtil.updateNode()");
	cTypeEnforcer.checkNode(aNode, "NodeUtil", "updateNode", "aNode");
	if (value != null &amp;&amp; !cTypeChecker.isString(value))
	{
		if (cTypeChecker.isBoolean(value) 
			|| cTypeChecker.isNumber(value))
		{
			value = value.toString();
		}
		else
		{
			throw cException.createInstance("NodeUtil.updateNode(value) expected" 
	    		  + " a String, number, or boolean but got a " + value,
	    		  "UnexpectedDataType");
		}
	}

	if (aNode.rawValue != value)
	{
		aNode.rawValue = value;
		return true;
	}
	return false;
}

//===== PRIVATE ================================================================

/**
 * Gets all nodes with the indicated name that represent JavaScript packages
 * under the passed node. This is called recursively.
 *
 * Note that this specifically skips the script nodes since referencing them
 * causes them to be compiled and their variable definitions can create endless
 * loops if they initialize by calling the function called this. The symptom is
 * that this stops the processing thread with no warning. If this is suspected
 * to be the happening, turn on debugging and check the Log that all processing
 * completed as expected.
 * @param topNode the top script node to search for the script package nodes.
 * @param packageName a string that contains the name of the script packages
 *		  of interest.
 * @param results an array that stores the found nodes. This adds nodes to this
 *		  array as they are found.
 * @param level (optional) an integer that represents the number of levels of
 *		  indentation this should use. Defaults to 0. Used for debugging problems
 *		  when this doesn't return as it should.
 */
function _searchForScriptPackageNode(topNode, packageName, results, level) {
	if (topNode.isContainer)
	{
		if (topNode.name == packageName)
		{
			if (_DEBUG_MODE)
			{
				console.println("saving " + topNode.somExpression);
			}
			results.push(topNode);
		}
		else
		{
			if (level == undefined)
			{
				level = 0;
			}
			var indent = _PADDING.substring(0, level * _TAB_WIDTH);
			var children = topNode.nodes; //list

			for (var i=0; i &lt; children.length; i++)
			{
				//Skip instanceManagers and variables nodes. Variables nodes contain
				//scripts. These are dangerous to touch, since that causes them to be
				//compiled and their variable definitions could cause endless loops
				//in this process if they initialize using the class that called this. 
				if (children.item(i).className != "variables"
					&amp;&amp; children.item(i).className != "instanceManager")
				{
					if (_DEBUG_MODE)
					{
						console.println(indent + children.item(i).name);
					}
					_searchForScriptPackageNode(children.item(i), packageName,
												results, level + 1);
				}
			}
		}
	}
}
</script>
               <script contentType="application/x-javascript" name="NumberFormatter">//
/*******************************************************************************
 * A class that formats numbers.
 */

//imports
var cException = script.core.util.Exception;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var _PADDING = "000000000000000000000000000000000000000000000000000000000000";

/**
 * Formats a number with commas as thousands separators.
 * @param aNumber the number to be formatted.
 * @param decimalPlaces (optional) the number of decimal places to round to. If
 *		  0, the decimal is suppressed. If a negative number, it is rounded to
 *		  the left of the decimal by that amount (e.g. 1234 with -1 results in
 *		  1230). Defaults to not doing rounding.
 * @return a string containing the formatted number. "0" is substituted if
 *		   aNumber was undefined or null.
 * @throws an UnexpectedDataType Exception if aNumber or decimalPlaces (when
 *		   used) don't contain valid numbers.
 */
function formatNumber(aNumber, decimalPlaces)
{
	var number = cTypeEnforcer.checkNumber(aNumber, "NumberFormatter",
							  			  "formatNumber", "aNumber", true);


	if(decimalPlaces != undefined)
	{
		cTypeEnforcer.checkNumber(decimalPlaces, "NumberFormatter",
				 				  "formatNumber", "decimalPlaces");
  		number = round(number, decimalPlaces);
	}
	
	var decimals;
	var numberParts = new String(number).split(".");
	var regularExp = /(\d+)(\d{3})/; //Senses clusters of 3 digits
	var wholeNumber = numberParts[0];
	
	if (numberParts.length &gt; 1)
	{
		decimals = numberParts[1];
	}

	while (regularExp.test(wholeNumber)) {
		//Inserts a comma between clusters of 3 digits
		wholeNumber = wholeNumber.replace(regularExp, "$1" + "," + "$2");
	}
	if (decimals == undefined)
	{
		return wholeNumber;
	}
	return wholeNumber + "." + decimals;
}

/**
 * Formats a number as "$1,234.56".
 * @param aNumber the number to be formatted.
 * @return a string containing the formatted number. "$0.00" is substituted if
 *		   aNumber was undefined or null.
 * @throws an UnexpectedDataType Exception if aNumber doesn't contain a valid
 *		   number.
 */
function formatAsCurrency(aNumber)
{
	return "$" + formatNumber(aNumber, 2);
}

/**
 * Pads a number with leading 0's. This is only intended to be used with
 * positive numbers (negative signs will be within the padding).
 * @param aNumber the number to be padded. If null, this will be treated as 0.
 * @param width the number of characters to pad to.
 * @return a string containing the 0 padded number.
 * @throws an InvalidArgument Exception if aNumber has more characters in it
 *		   than width allows.
 * @throws an UnexpectedDataType Exception if aNumber or width don't contain
 *		   valid numbers.
 */
function pad(aNumber, width)
{
	var result = cTypeEnforcer.checkNumber(aNumber, "NumberFormatter", "pad",
							  			   "aNumber", true).toString();
	cTypeEnforcer.checkNumber(width, "NumberFormatter", "pad", "width");

	if (result.length &gt; width)
	{
		throw cException.createInstance("NumberFormatter.pad(): the number '" 
			  + aNumber + "' is wider than the specified width '" + width + "'",
			  "InvalidArgument");
	}

	if (result.length &lt; width)
	{
		return _PADDING.substr(0, (width - result.length)) + result;
	}
	return result;
}

/**
 * Rounds a number to a specific number of decimal places. It also pads it with
 * trailing 0's.
 * @param aNumber the number to be rounded.
 * @param decimalPlaces the number of decimal places to round to. If 0, the
 *		  decimal is suppressed. If a negative number, it is rounded to the left
 *		  of the decimal by that amount (e.g. 1234 with -1 results in 1230).
 * @return the rounded number as a String. 0 is substituted if aNumber was undefined or null.
 * @throws an UnexpectedDataType Exception if aNumber or decimalPlaces don't
 *		   contain valid numbers.
 */
function round(aNumber, decimalPlaces)
{
	var number = cTypeEnforcer.checkNumber(aNumber, "NumberFormatter", "round",
										  "aNumber", true);
	cTypeEnforcer.checkNumber(decimalPlaces, "NumberFormatter", "round",
							 "decimalPlaces");
										  										  
	return number.toFixed(decimalPlaces);
}
</script>
               <script contentType="application/x-javascript" name="NumberUtil">//
/*******************************************************************************
 * A class that contains utility functions for manipulating numbers.
 */

//imports
var cException = script.core.util.Exception;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Coerces the passed number to a boolean. This will only accept 1 as true and 0
 * as false.
 * @param aNumber the number to be converted.
 * @return a boolean equivalent to the number.
 * @throws an UnexpectedDataType Exception if aNumber is undefined, null, not a
 *		   number, or isn't one of the expected true or false values.
 */
function asBoolean(aNumber) {
	cTypeEnforcer.checkNumber(aNumber, "NumberUtil", "asBoolean", "aNumber");

	if (aNumber == 1)
	{
		return true;
	}
	if (aNumber == 0)
	{
		return false;
	}
	throw cException.createInstance("NumberUtil.asBoolean(): " + aNumber +
					" cannot be coerced to a boolean", "UnexpectedDataType");
}

/**
 * Rounds a number to a specific number of decimal places without padding it
 * with trailing 0's (this actually returns a number result rather than a
 * String).
 * @param aNumber the number to be rounded.
 * @param decimalPlaces the number of decimal places to round to. If a negative
 *		  number, it is rounded to the left of the decimal by that amount (e.g.
 *		  1234 with -1 results in 1230).
 * @return the rounded number as a number. 0 is substituted if aNumber was
 *		   undefined or null.
 * @throws an UnexpectedDataType Exception if aNumber or decimalPlaces don't
 *		   contain valid numbers.
 */
function round(aNumber, decimalPlaces)
{
	var number = cTypeEnforcer.checkNumber(aNumber, "NumberUtil", "round",
										  "aNumber", true);
	cTypeEnforcer.checkNumber(decimalPlaces, "NumberUtil", "round",
							 "decimalPlaces");
										  										  
	return new Number(number.toFixed(decimalPlaces));
}
</script>
               <script contentType="application/x-javascript" name="ObjectUtil">//
/*******************************************************************************
 * A class that contains utility functions for dealing with Objects.
 */

//imports
var cMap = script.core.util.Map;
var cNodeUtil = script.core.util.NodeUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var _ADOBE_FUNCTIONS = "|clone|isPropertySpecified|getElement|setElement|"
					   + "getAttribute|setAttribute|loadXML|saveXML|saveFilteredXML|"
					   + "applyXSL|assignNode|resolveNode|resolveNodes|";
//Used for indentation
var _PADDING = "                                                                                                    ";
var _TAB_WIDTH = 2;


/**
 * Lists the details of the passed Object. Note that, in the case of complex
 * Objects, functions are not listed. If this is one of our custom objects, this
 * will return its asString().
 * @param anObject the Object of interest. This is a "loose" sense of Object
 *		  - it can actually be anything.
 * @param level (optional) an integer that represents the number of levels of
 *		  indentation this should use. Defaults to 0. Used for listing nested
 *		  objects.
 * @param indentProperties (optional) a boolean that indicates whether only the
 *		  properties should be indented. Defaults to false (indent the entire
 *		  entry). Used for listing nested objects.
 * @return the string that lists the details of the passed Object.
 */
function asString(anObject, level, indentProperties) {
	var indent = "";
    var result = "";

	level = cTypeEnforcer.checkNumber(level, "ObjectUtil", "asString",
									  "level", true);
	indentProperties = cTypeEnforcer.checkBoolean(indentProperties, "ObjectUtil",
									 "asString", "indentProperties", true);
	if (level &gt; 0)
	{
		indent = _PADDING.substring(0, level * _TAB_WIDTH);
	}
    if (!indentProperties)
	{
		result = indent;
	}
	
	if (anObject === null)
	{
			return result + "null";
	}
	if (anObject === undefined)
	{
			return result + "undefined";
	}

	if (isComplexObject(anObject) || cTypeChecker.isArray(anObject))
	{
		if (!isXfaObject(anObject) &amp;&amp; anObject.asString != undefined) //Must be one of ours!
		{
			return result + anObject.asString();
		}

    	var objectType = getType(anObject);

		if (isXfaObject(anObject))
		{
			return result + _listXfaObject(anObject, objectType);
		}
    	if (objectType != null)
    	{
    		result += objectType + "[\n";
    	}
    	else
    	{
    		result += "[\n";
    	}
	    if (objectType == "Array")
	    {
    		result += _listArrayProperties(anObject, level + 1);
    	}
    	else
    	{
    		result += _listObjectProperties(anObject, level + 1);
    	}
    	result += "]";
    }
    else
    {
    	result += anObject; 
    }
	return result;
}

/**
 * Gets a simple description of the passed Object. This will be the type of the
 * Object, if that can be determined. Otherwise, it will be the object itself
 * (which will result in its toString() being used when printed).
 * @param anObject the Object of interest.
 * @return a string that contains a simple description of the passed Object, or
 *		   the object itself.
 */
function getDescription(anObject) {
	if (anObject === undefined)
	{
		return "undefined";
	}
	if (anObject === null)
	{
		return "null";
	}

	var type = getType(anObject);
	
	if (type != null)
	{
		return type;
	}
	return anObject;
}

/**
 * Gets an Array of the passed Object's functions' names. Note that this filters
 * out Adobe functions (all classes are wrapped by Adobe script objects that add
 * their own functions).
 * @param anObject the Object of interest.
 * @return a String Array that contains the names of the passed Object's
 *		   functions. Empty if this was not an Object.
 */
function getFunctions(anObject) {
	var functions = new Array();
	
	if (anObject != null &amp;&amp; typeof anObject == 'object')
	{
	    for (var prop in anObject)
	    {
	    	if (cTypeChecker.isFunction(anObject[prop])
	    		&amp;&amp; _ADOBE_FUNCTIONS.indexOf("|" + prop + "|") == -1)
	    	{
		    	functions.push(prop);
	    	}
	    }
    }
	return functions;
}

/**
 * Gets a Map of the passed Object's properties (variables), where the key
 * is the property name and the value is the property's value.
 * @param anObject the Object of interest.
 * @return a Map of the passed Object's properties not including its
 *		   functions. Empty if this was not an Object.
 */
function getProperties(anObject) {
	var properties = cMap.createInstance();
	
	if (anObject != null &amp;&amp; typeof anObject == 'object')
	{
	    for (var prop in anObject)
	    {
	    	if (!cTypeChecker.isFunction(anObject[prop]))
	    	{
		    	properties.put(prop, anObject[prop]);
	    	}
	    }
    }
	return properties;
}

/**
 * Gets the type (class) of the passed Object.
 * @param anObject the Object of interest.
 * @return a string that contains the passed Object's class. Null if it is
 *		   not an object, or if its type cannot be determined.
 */
function getType(anObject) {
	if (anObject != null &amp;&amp; typeof anObject == 'object')
	{
		if (anObject.className != undefined) //Must be a custom class (Adobe or ours)
		{
			return anObject.className;
		}

		if (cTypeChecker.isArray(anObject))
		{
			return "Array";
		}
		if (cTypeChecker.isBoolean(anObject))
		{
			return "Boolean";
		}
		if (cTypeChecker.isDate(anObject))
		{
			return "Date";
		}
		if (cTypeChecker.isSoapResponseNode(anObject))
		{
			return "SoapResponseNode";
		}
		if (cTypeChecker.isString(anObject))
		{
			return "String";
		}
    }
	return null;
}

/**
 * Gets whether the passed Object is "complex", which is to say that it is an
 * object that contains properties that won't display properly using its
 * toString().
 * @param anObject the Object of interest.
 * @return a boolean that indicates whether the passed Object is "complex".
 *		   False if it is not an Object.
 */
function isComplexObject(anObject) {
	return (anObject != null &amp;&amp; typeof anObject == "object"
			&amp;&amp; (anObject.toString() == "[object Object]"
				|| anObject.toString() == "[object XFAObject]"
				|| anObject.toString().indexOf("Aggregate") != -1));
}

/**
 * Gets whether the passed Object is an XFA object, which is provided by Adobe.
 * Not only will it not display properly using its toString(), its properties
 * cannot be dynamically dicovered.
 * @param anObject the Object of interest.
 * @return a boolean that indicates whether the passed Object is an XFA object.
 *		   False if it is not an Object.
 */
function isXfaObject(anObject) {
	return (anObject != null &amp;&amp; typeof anObject == "object"
			&amp;&amp; anObject.toString() == "[object XFAObject]");
}

//===== PRIVATE ================================================================

/**
 * Lists the items in the passed Array.
 * @param anArray the Array of interest.
 * @param level an integer that represents the number of levels of indentation
 *		  this should use.
 * @return the string that lists the items in the passed Array.
 */
function _listArrayProperties(anArray, level) {
	var indent = "";
	var isFirst = true;
    var result = "";

	if (level &gt; 0)
	{
		indent = _PADDING.substring(0, level * _TAB_WIDTH);
	}

    for (var prop in anArray)
    {
    	if (isFirst)
    	{
    		isFirst = false;
    	}
    	else
    	{
    		result += ",\n";
    	}
    	if (isComplexObject(anArray[prop]))
    	{
    		result +=  indent + asString(anArray[prop], level + 1, true);
    	}
    	else
    	{
    		result += indent + anArray[prop];
    	}
    }

	return result;
}

/**
 * Lists the properties (variables) of the passed Object. This does not include
 * its functions.
 * @param anObject the Object of interest.
 * @param level an integer that represents the number of levels of indentation
 *		  this should use.
 * @return the string that lists the properties of the passed Object.
 */
function _listObjectProperties(anObject, level) {
	var indent = "";
	var isFirst = true;
    var result = "";

	if (level &gt; 0)
	{
		indent = _PADDING.substring(0, level * _TAB_WIDTH);
	}

    for (var prop in anObject)
    {
    	if (!cTypeChecker.isFunction(anObject[prop]))
    	{
	    	if (isFirst)
	    	{
	    		isFirst = false;
	    	}
	    	else
	    	{
	    		result += ",\n";
	    	}
	    	if (isComplexObject(anObject[prop]))
	    	{
	    		result +=  indent + prop + "= "
	    				   + asString(anObject[prop], level + 1, true);
	    	}
	    	else
	    	{
	    		result += indent + prop + "= "+ anObject[prop];
	    	}
    	}
    }

	return result;
}

/**
 * Lists the details of the passed XFA Object. The definitions of these types of
 * objects cannot be discovered programatically. This supports callouts to other
 * functions that are used to describe them. Where these are not provided,
 * little information is available to return.
 * @param anObject the XFA Object of interest.
 * @param objectType the type of Object this is.
 * @return the string that describes the passed XFA Object as best as can be
 *		   done.
 */
function _listXfaObject(anObject, objectType) {
	if (objectType != null)
	{
		switch(objectType)
		{
			case "nodeList":
				return cNodeUtil.getNodeListAsString(anObject);
				break;
			default:
				return objectType + "[]";
		}
	}

	return anObject.toString(); //Nothing more we can determine
}
</script>
               <script contentType="application/x-javascript" name="SecurityUtil">//
/*******************************************************************************
 * Utility methods to support security.
 *
 * Includes the following:
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

// Configurable variables. You may need to tweak these to be compatible with
// the server-side, but the defaults work in most cases.
var hexcase = 0;  // hex output format. 0 - lowercase; 1 - uppercase
var b64pad  = ""; // base-64 pad character. "=" for strict RFC compliance
var chrsz   = 8;  // bits per input character. 8 - ASCII; 16 - Unicode

/**
 * Gets a base 64 representation of an MD5 hash of the passed String.
 * @param aString the String to be hashed.
 * @return a string containing the resulting base 64 MD5 hash.
 */
function getBase64MD5Hash(aString)
{
	return _binl2b64(_coreMd5(_str2binl(aString), aString.length * chrsz));
}

/**
 * Gets a hexadecimal representation of an MD5 hash of the passed String.
 * @param aString the String to be hashed.
 * @return a string containing the resulting hexadecimal MD5 hash.
 */
function getHexadecimalMD5Hash(aString)
{
	return _binl2hex(_coreMd5(_str2binl(aString), aString.length * chrsz));
}

/**
 * Gets an MD5 hash of the passed String.
 * @param aString the String to be hashed.
 * @return a string containing the resulting MD5 hash.
 */
function getMD5Hash(aString)
{
	return _binl2str(_coreMd5(_str2binl(aString), aString.length * chrsz));
}

//===== PRIVATE ================================================================

/**
 * Convert an array of little-endian words to a base-64 string
 */
function _binl2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * ( i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * ((i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * ((i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/**
 * Convert an array of little-endian words to a hex string.
 */
function _binl2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/**
 * Convert an array of little-endian words to a string
 */
function _binl2str(bin)
{
  var str = "";
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; mask);
  return str;
}

/**
 * Bitwise rotate a 32-bit number to the left.
 */
function _bitRotate(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/**
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function _coreMd5(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32);
  x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = _md5Ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = _md5Ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = _md5Ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = _md5Ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = _md5Ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = _md5Ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = _md5Ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = _md5Ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = _md5Ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = _md5Ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = _md5Ff(c, d, a, b, x[i+10], 17, -42063);
    b = _md5Ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = _md5Ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = _md5Ff(d, a, b, c, x[i+13], 12, -40341101);
    c = _md5Ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = _md5Ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = _md5Gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = _md5Gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = _md5Gg(c, d, a, b, x[i+11], 14,  643717713);
    b = _md5Gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = _md5Gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = _md5Gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = _md5Gg(c, d, a, b, x[i+15], 14, -660478335);
    b = _md5Gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = _md5Gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = _md5Gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = _md5Gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = _md5Gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = _md5Gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = _md5Gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = _md5Gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = _md5Gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = _md5Hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = _md5Hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = _md5Hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = _md5Hh(b, c, d, a, x[i+14], 23, -35309556);
    a = _md5Hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = _md5Hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = _md5Hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = _md5Hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = _md5Hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = _md5Hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = _md5Hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = _md5Hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = _md5Hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = _md5Hh(d, a, b, c, x[i+12], 11, -421815835);
    c = _md5Hh(c, d, a, b, x[i+15], 16,  530742520);
    b = _md5Hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = _md5Ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = _md5Ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = _md5Ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = _md5Ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = _md5Ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = _md5Ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = _md5Ii(c, d, a, b, x[i+10], 15, -1051523);
    b = _md5Ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = _md5Ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = _md5Ii(d, a, b, c, x[i+15], 10, -30611744);
    c = _md5Ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = _md5Ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = _md5Ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = _md5Ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = _md5Ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = _md5Ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = _safeAdd(a, olda);
    b = _safeAdd(b, oldb);
    c = _safeAdd(c, oldc);
    d = _safeAdd(d, oldd);
  }
  return Array(a, b, c, d);

}

/**
 * These functions implement the four basic operations the algorithm uses.
 */
function _md5Cmn(q, a, b, x, s, t)
{
  return _safeAdd(_bitRotate(_safeAdd(_safeAdd(a, q), _safeAdd(x, t)), s),b);
}

function _md5Ff(a, b, c, d, x, s, t)
{
  return _md5Cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);
}

function _md5Gg(a, b, c, d, x, s, t)
{
  return _md5Cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);
}

function _md5Hh(a, b, c, d, x, s, t)
{
  return _md5Cmn(b ^ c ^ d, a, b, x, s, t);
}

function _md5Ii(a, b, c, d, x, s, t)
{
  return _md5Cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/**
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function _safeAdd(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/**
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters &gt;255 have their hi-byte silently ignored.
 */
function _str2binl(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32);
  return bin;
}
</script>
               <script contentType="application/x-javascript" name="Set">//
/*******************************************************************************
 * A collection that contains no duplicate elements. Items in this structure are
 * indexed the same way as in an Array, so "for" loops will work. Only pop() and
 * push() (each taking a single argument) are implemented.
 *
 * Note that custom objects stored in this set that implement the
 * EqualityComparableInterface use their getEqualityKey() function to determine
 * uniqueness. Those that don't implement that interface use their asString()
 * function. Simple objects stored in this set use their toString() function to
 * determine uniqueness.
 */

//imports
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Gets a new Set. Adobe does not allow object instances to be created
 * outside of their packaging, so it must be done here.
 * @return the new Set instance
 */
function createInstance()
{
	return new SetClass();
}

/**
 * Class implementation
 */
function SetClass()
{
	this.className = "Set";
	
	this.contentControl = {}; //Keeps track of the objects that are in the Set
	this.length = 0;
	
	/**
	 * Returns an Array with the values contained in this Set object.
	 * @return an Array that contains this Set's entries.
	 */
    this.asArray = function()
    {
    	var result = new Array();

		for (var i=0; i &lt; this.length; i++)
	    {
			result.push(this[i]);
	    }    	
		return result;
	}	

	/**
	 * Gets whether the passed object is already in the set.
	 * @param anObject the object of interest.
	 * @return a boolean - true if the passed object is in the set.
	 */
    this.contains = function(anObject)
    {
    	var objectString = this._getObjectAsString(anObject);    	
    	return !(this.contentControl[objectString] === undefined);
	}

	/**
	 * Removes the last element of the Set (this will also change the length
	 * of the Set).
	 * @return the removed element. Undefined if the Set was already empty.
	 */
    this.pop = function()
    {
    	if (this.length &gt; 0)
    	{
    		this.length -= 1;
    		var removedObject = this[this.length];
			var removedObjectString = this._getObjectAsString(removedObject);
			
    		delete this.contentControl[removedObjectString];
    		delete this[this.length];
    		return removedObject;
	    }
	    return undefined;
	}

	/**
	 * Adds a new element to the end of the Set and returns the new length. The
	 * object is not added if there is already one in the Set.
	 * @param anObject the Object to add to the end of the Set.
	 * @return a number that contains the new length of the set.
	 */
    this.push = function(anObject)
    {
    	if (anObject != undefined)
    	{
	    	var objectString = this._getObjectAsString(anObject);
	    	if (this.contentControl[objectString] === undefined)
	    	{
	    		this.contentControl[objectString] = null; //As opposed to undefined
	    		this[this.length] = anObject;
	    		this.length += 1;
		    }
	    }
	    return this.length;
	}
	
	/**
	 * Copies all of the entries from the specified Array to this Set. The
	 * effect of this call is equivalent to that of calling push() on this
	 * Set once for each entry in the specified Array. As a result, order is
	 * preserved but duplicates are removed.
	 * @param anArray the Array whose entries are to be stored in this Set.
	 * @throws an UnexpectedDataType Exception if anArray is undefined, null,
	 *		   or not an Array.
	 */
    this.pushAll = function(anArray)
    {
		cTypeEnforcer.checkArray(anArray, "Set", "pushAll", "anArray");

		for (var i=0; i &lt; anArray.length; i++)
		{
			this.push(anArray[i]);
		}
	}

    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";
		var isFirst = true;
		
		for (var i=0; i &lt; this.length; i++)
	    {
    		if (isFirst)
    		{
				isFirst = false;
    		}
    		else
    		{
				buffer += ", ";
    		}
			buffer += this[i];
	    }    	
		buffer += "]";
		return buffer;
	}	
	
	/* Private ***************************************************************/
	/**
	* This method exists to provide custom and simple objects access to the Set
	* class, and to perform as efficient a means of comparison as possible.
	* Uses the EqualityComparableInterface if implemented, otherwise calls a
	* custom object's asString() function or a simple object's toString()
	* function. 
	* @param anObject the object to be converted to a String representation.
	* @return the String representation of the given Object
	*/
	this._getObjectAsString = function(anObject)
	{
		//If the object implements EqualityComparableInterface, then use its
		//equality key()
		if (typeof anObject == 'object' 
			&amp;&amp; anObject.getEqualityKey != undefined)
		{
			cLog.trace("Set object as key: "+anObject.getEqualityKey());
			return anObject.getEqualityKey();
		}
		if(cTypeChecker.isCustomObject(anObject))
		{
			cLog.trace("Set object as sting: "+anObject.asString());
			console.println("Set object as sting: "+anObject.asString());
			return anObject.asString();
		}
		return anObject.toString();
	}
}
</script>
               <script contentType="application/x-javascript" name="StringUtil">//
/*******************************************************************************
 * A class that contains utility functions for manipulating Strings.
 */

//imports
var cException = script.core.util.Exception;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var FALSE_VALUES = "|f|false|no|off|0|";
var RICH_TEXT_PREFIX = "&lt;body xmlns='http://www.w3.org/1999/xhtml' xmlns:xfa='http://www.xfa.org/schema/xfa-data/1.0/' xfa:APIVersion='2.4.5277.0'&gt;";
var RICH_TEXT_SUFFIX = "&lt;/body&gt;";
var SINGLE_WHITESPACE_REGEX = /\s/;
var TRUE_VALUES = "|t|true|yes|on|1|";

/**
 * Coerces the passed string to a boolean. This will trim the string and accept
 * the following values (case insensitive) as true: "t", "true", "yes", "on",
 * "1". Their opposites will be false.
 * @param aString the string to be converted.
 * @return a boolean equivalent to the string.
 * @throws an UnexpectedDataType Exception if aString is undefined, null, not a
 *		   string, or isn't one of the expected true or false values.
 */
function asBoolean(aString) {
	cTypeEnforcer.checkString(aString, "StringUtil", "asBoolean", "aString");

	aString = "|" + trim(aString).toLowerCase() + "|";
	if (TRUE_VALUES.indexOf(aString) != -1)
	{
		return true;
	}
	if (FALSE_VALUES.indexOf(aString) != -1)
	{
		return false;
	}
	throw cException.createInstance("StringUtil.asBoolean(): '" + aString +
					"' cannot be coerced to a boolean", "UnexpectedDataType");
}

/**
 * Converts the passed string to rich text by wrapping it in the required tags
 * for Adobe to recognize it as such. Note that this does not attempt to
 * validate or adjust the passed string to assure that it is valid rich text.
 * @param aString the string to be converted.
 * @return a String that will be recognized by Adobe as rich text.
 * @throws an UnexpectedDataType Exception if aString is undefined, null, or not
 *		   a string.
 */
function asRichText(aString) {
	cTypeEnforcer.checkString(aString, "StringUtil", "asRichText", "aString");

	return RICH_TEXT_PREFIX + aString + RICH_TEXT_SUFFIX;
}

/**
 * Pick list strings use commas to delimeter entries as well as the codes from
 * their descriptions. As a result, Adobe will get confused if either contain
 * embedded commas. This escapes any commas in the passed String with a
 * backslash.
 * @param aString the string used as a pick list code or description.
 * @return a string with any embedded commas properly escaped.
 * @throws an UnexpectedDataType Exception if aString is undefined, null, or not
 *		   a string.
 */
function cleanPickListEntry(aString) {
	cTypeEnforcer.checkString(aString, "StringUtil", "cleanPickListEntry",
							  "aString");
	return aString.replace(/\,/gi, "\\,");
}

/**
* Encodes characters that are incompatible with XML to XML entities
* @param s a string to encode
* @return an encoded string
*/
function encodeXml(s)
{
	if(s == null)
	{
		return "";
	}
	return s.replace(/&amp;/g, "&amp;amp;")	
		.replace(/&lt;/g, "&amp;lt;")
		.replace(/&gt;/g, "&amp;gt;")
		.replace(/\'/g, "&amp;apos;")
		//.replace(/\"/g, "&amp;quot;") //TODO uncomment this. For some reason, it's breaking the script
		.replace(/\n\r/g, "&lt;br /&gt;")
		.replace(/\n/g, "&lt;br /&gt;")
		.replace(/\r/g, "&lt;br /&gt;");	
}


/**
 * Formats the passed SOM expression for display. This removes the
 * "xfa[0].form[0]" prefix, as well as all instances of "[0]" and 
 * "#variables[0]" if they exist.
 * @param aSomExpression the string containing a SOM expression to be formatted.
 * @return a string containing the formatted SOM expression.
 * @throws an UnexpectedDataType Exception if aSomExpression is undefined, null,
 *		   or not a string.
 */
function formatSomExpression(aSomExpression) {
	cTypeEnforcer.checkString(aSomExpression, "StringUtil", "formatSomExpression",
							 "aSomExpression");

	if (aSomExpression.indexOf("xfa[0].form[0].") == 0)
	{
		aSomExpression = aSomExpression.substring(15); //strip it off
	}
	//remove all ".#variables[0]"
	aSomExpression = aSomExpression.replace(/.#variables\[0\]/gi, "");
	//remove all "[0]"
	aSomExpression = aSomExpression.replace(/\[0\]/gi, "");

	return aSomExpression;
}

/**
 * Generalizes the passed SOM expression by removing instance information. This
 * removes all instances of "[#]" where "#"  is any number.
 * @param aSomExpression the string containing a SOM expression to be
 *		  generalized.
 * @return a string containing the generalized SOM expression.
 * @throws an UnexpectedDataType Exception if aSomExpression is undefined, null,
 *		   or not a string.
 */
function generalizeSomExpression(aSomExpression) {
	cTypeEnforcer.checkString(aSomExpression, "StringUtil",
							  "generalizeSomExpression", "aSomExpression");
	return aSomExpression.replace(/\[\d*\]/gi, "");
}

/**
 * Splices a child SOM expression onto a base SOM expression, which is to say
 * that the lowest nodes of the child are replaced with those of the base. This
 * is commonly used to prepend a SOM expression with instance information to one
 * that has been generalized so that the result can be resolved to the child of
 * that instance.
 * For example, a base of "xfa[0].form[0].Pla[0].sfPart1[2]" and a child of
 * "xfa.form.Pla.sfPart1.sfSectionA1.sfRow1.sfHeading" would produce
 * "xfa[0].form[0].Pla[0].sfPart1[2].sfSectionA1.sfRow1.sfHeading", which
 * resolves to the sfHeading under the 3rd sfPart1.
 * @param aBaseSomExpression the string containing the base SOM expression that
 *		  includes instance information.
 * @param aChildSomExpression the string containing a (usually generalized)SOM
 *		  expression to a child node under the base.
 * @return a string containing the SOM expression that results from merging the
 *		   two.
 * @throws an UnexpectedDataType Exception if aBaseSomExpression or
 *		   aChildSomExpression is undefined, null, or not a string.
 * @throws an InvalidArgument Exception if aChildSomExpression doesn't have more
 *		   node levels than aBaseSomExpression.
 */
function spliceSomExpressions(aBaseSomExpression, aChildSomExpression) {
	cTypeEnforcer.checkString(aBaseSomExpression, "StringUtil",
							  "spliceSomExpressions", "aBaseSomExpression");
	cTypeEnforcer.checkString(aChildSomExpression, "StringUtil",
							  "spliceSomExpressions", "aChildSomExpression");

	var baseParts = aBaseSomExpression.split(".");
	var childParts = aChildSomExpression.split(".");
	
	if (baseParts.length &gt;= childParts.length)
	{
		throw cException.createInstance("StringUtil.spliceSomExpressions(): " 
			  + "aChildSomExpression must have more node levels than "
			  + "aBaseSomExpression ", "InvalidArgument");
	}

	childParts.splice(0, baseParts.length, aBaseSomExpression);
	return childParts.join(".");
}

/**
 * Converts the passed string to lower case.
 * @param aString the string to be converted to lower case.
 * @return the string converted to lower case. If passed an undefined or null,
 *		   an empty String will be returned.
 * @throws an UnexpectedDataType Exception if aString is not a string.
 */
function toLowerCase(aString) {
	return cTypeEnforcer.checkString(aString, "StringUtil", "toLowerCase",
									"aString", true).toLowerCase();
}

/**
 * Converts the passed string to upper case.
 * @param aString the string to be converted to upper case.
 * @return the string converted to upper case. If passed an undefined or null,
 *		   an empty String will be returned.
 * @throws an UnexpectedDataType Exception if aString is not a string.
 */
function toUpperCase(aString) {
	return cTypeEnforcer.checkString(aString, "StringUtil", "toUpperCase",
									"aString", true).toUpperCase();
}

/**
 * Strips whitespace from either end of the passed string.
 * @param aString the string to be trimmed
 * @return the string with leading and trailing whitespace removed. An empty
 *		   string if nothing remains. If passed an undefined or null, the same
 *		   value will be returned.
 * @throws an UnexpectedDataType Exception if aString is not a string.
 */
function trim(aString) {
	cTypeEnforcer.checkString(aString, "StringUtil", "trim", "aString", true);

    if (aString == undefined)
    {
        return aString;
	}

    var startIndex = 0;
    var endIndex = aString.length - 1;

	//aString = new String(aString); //Make sure that it's a String not a primitive
    while (aString.substring(startIndex, startIndex + 1)
    			  .match(SINGLE_WHITESPACE_REGEX))
    {
        startIndex++;
    }

    while (aString.substring(endIndex, endIndex + 1)
    			  .match(SINGLE_WHITESPACE_REGEX))
    {
        endIndex--;
    }

    if (endIndex &lt; startIndex)
    {
        return "";
    }

    return aString.substring(startIndex, endIndex + 1);
}

</script>
               <script contentType="application/x-javascript" name="TypeChecker">//
/*******************************************************************************
 * This class provides functionality to support type checking.
 */

//imports
var cArrayUtil = script.core.util.ArrayUtil;
var cException = script.core.util.Exception;
var cObjectUtil = script.core.util.ObjectUtil;
var cLog = script.core.util.Log;
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Checks that the passed value is a class or object that implements a specific
 * interface. To pass this test, the class or object being checked must
 * implement of all of the functions present in the interface. Unfortunately,
 * the function parameters and return type are not checked in this
 * implementation.
 * @param anObject the class or object to be checked.
 * @param anInterface a custom class that defines the interface. 
 * @return true if the class or object implements the passed interface,
 *		   otherwise false. Undefined and null return false.
 * @throws an UnexpectedDataType Exception if anInterface is undefined, null,
 *		   or isn't an interface definition.
 */
function implementsInterface(anObject, anInterface)
{
	if (!isInterface(anInterface))
	{
		throw cException.createInstance("TypeChecker.implementsInterface(" 
			+ "anInterface) expected an interface definition, not a " 
			+ cObjectUtil.getDescription(anInterface), "UnexpectedDataType");
	}
	
	if (anObject != undefined)
	{
		var implementedFunctions = cObjectUtil.getFunctions(anObject);
		var requiredFunctions = cObjectUtil.getFunctions(anInterface);

		for (var i=0; i &lt; requiredFunctions.length; i++)
		{
			if (!cArrayUtil.contains(implementedFunctions,
									 requiredFunctions[i]))
			{
				return false;
			}
		}
		return true;
  	}
	return false;
}

/**
 * Checks that the passed value is an Array object.
 * @param value the value to be checked.
 * @return true if it is an Array, otherwise false. Undefined and null return
 *		   false.
 */
function isArray(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
			var criterion = value.constructor.toString().match(/array/i);
			
	 		if(criterion != null)
	 		{
				return true;
			}
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a boolean or a Boolean object.
 * @param value the value to be checked.
 * @return true if it is a boolean, otherwise false. Undefined and null return
 *		   false.
 */
function isBoolean(value)
{
	if (value != undefined)
	{
		if (typeof value == 'boolean')
		{
			return true;
		}
		if (typeof value == 'object')
		{
			var criterion = value.constructor.toString().match(/function Boolean()/);
			
	 		if(criterion != null)
	 		{
				return true;
			}
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a check box object.
 * @param value the value to be checked.
 * @return true if it is a check box, otherwise false. Undefined and null return
 *		   false.
 */
function isCheckBox(value)
{
	if (value != undefined)
	{
		if (isSpecificCustomObject(value, "field"))
		{
			if (value.ui.oneOfChild.className == 'checkButton')
			{
		 		if(value.ui.oneOfChild.shape == 'square')
		 		{
					return true;
				}
			}
			return false;
		}
		return false;
  	}
	return false;
}

/**
 * Checks that the passed value is a collection (an Array or Set object). These
 * contains items that are indexed and can be processed with a "for" loop.
 * @param value the value to be checked.
 * @return true if it is a collection, otherwise false. Undefined and null
 *		   return false.
 */
function isCollection(value)
{
	return isArray(value) || isSet(value);
}

/**
 * Checks that the passed value is a comboBox field (a pickList that allows the
 * user to enter custom text).
 * @param value the value to be checked.
 * @return true if it is a comboBox, otherwise false. Undefined and null return
 *		   false.
 */
function isComboBox(value)
{
	if (value != undefined)
	{
		if (isSpecificCustomObject(value, "field"))		
 		{
			var choiceList = xfa.resolveNode(value.somExpression 
											 + ".ui.#choiceList")
		
			return (choiceList != null
					&amp;&amp; choiceList.textEntry == "1");
		}		
  	}
  	return false;
}

/**
 * Checks that the passed value is a custom object instance. To pass this test,
 * the object must populate a className variable and implement an asString()
 * function. This is only applicable to objects defined in this code base.
 * @param value the value to be checked.
 * @return true if it is a custom object instance, otherwise false. Undefined
 *		   and null return false.
 */
function isCustomObject(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
			//Adobe classes throw a General Error when they are asked for
			//properties that don't exist. Using isPropertySpecified()
			//doesn't always work (and you can't test for the availability
			//of that function) either.
			try
			{
		    	return (value.className != undefined
		    			&amp;&amp; isFunction(value.asString));
	    	}
	    	catch(exception) {} //Absorb it
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a custom class that can be used to create
 * object instances. To pass this test, the class must implement a
 * createInstance() function to retrieve object instances. This is only
 * applicable to objects defined in this code base.
 * @param value the value to be checked.
 * @return true if it is a custom class that can be used to create object
 *		   instances, otherwise false. Undefined and null return false.
 */
function isCustomObjectFactory(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
			//Adobe classes throw a General Error when they are asked for
			//properties that don't exist. Using isPropertySpecified()
			//doesn't always work (and you can't test for the availability
			//of that function) either.
			try
			{
	    		return isFunction(value.createInstance);
	    	}
	    	catch(exception) {} //Absorb it
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a Date.
 * @param value the value to be checked.
 * @return true if it is a Date, otherwise false. Undefined and null return
 *		   false.
 */
function isDate(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
			var criterion = value.constructor.toString().match(/function Date()/);
			
	 		if(criterion != null)
	 		{
				return true;
			}
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a function object.
 * @param value the value to be checked.
 * @return true if it is a function, otherwise false. Undefined and null return
 *		   false.
 */
function isFunction(value)
{
	if (value != undefined)
	{
		return (typeof value == "function");
  	}
	return false;
}

/**
 * Checks that the passed value is a custom Interface definition. To pass this
 * test, the object must populate an interfaceName variable. This is only
 * applicable to interfaces defined in this code base.
 * @param value the value to be checked.
 * @return true if it is a custom Interface definition, otherwise false.
 *		   Undefined and null return false.
 */
function isInterface(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
	    	return (value["interfaceName"] != undefined);
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a Map (dictionary).
 * @param value the value to be checked.
 * @return true if it is a Map, otherwise false. Undefined and null return
 *		   false.
 */
function isMap(value)
{
	if (value != undefined)
	{
		return isSpecificCustomObject(value, "Map");
  	}
	return false;
}

/**
 * Checks that the passed value is an instance of an Adobe Node. This isn't
 * failsafe, since it does so by testing for the presence of a somExpression
 * property (which other objects may also implement). This is necessary since
 * there are multiple Node subclasses.
 * @return true if it is an Adobe Node, otherwise false. Undefined and null
 *		   return false.
 */
function isNode(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
			//isPropertySpecified("somExpression") doesn't work!
		  	return (value.isPropertySpecified != undefined
		  			&amp;&amp; value.somExpression != undefined);
		}
  	}
	return false;
}

/**
 * Checks that the passed value is, or can be successfully converted to, a
 * number.
 * @param value the value to be checked.
 * @return true if it is a number, otherwise false. Undefined and null return
 *		   false.
 */
function isNumber(value)
{
	if (value == undefined || isNaN(value))
	{
		return false;
  	}
	return true;
}

/**
 * Checks that the passed value is a pickList field.
 * @param value the value to be checked.
 * @return true if it is a pickList, otherwise false. Undefined and null return
 *		   false.
 */
function isPickList(value)
{
	if (value != undefined)
	{
		if (isSpecificCustomObject(value, "field"))		
 		{
			var choiceList = xfa.resolveNode(value.somExpression 
											 + ".ui.#choiceList")
		
			return (choiceList != null);
		}		
  	}
	return false;
}

/**
 * Checks that the passed value is a radio button field.
 * @param value the value to be checked.
 * @return true if it is a radio button, otherwise false. Undefined and null
 *		   return false.
 */
function isRadioButton(value)
{
	if (value != undefined)
	{
		if (isSpecificCustomObject(value, "field")
			&amp;&amp; (value.parent.className == 'exclGroup') 
			&amp;&amp; (value.ui.oneOfChild.className == 'checkButton')
			&amp;&amp; (value.ui.oneOfChild.shape == 'round'))		
 		{
			return true;
		}		
  	}
	return false;
}

/**
 * Checks that the passed value is a Set (type of Array).
 * @param value the value to be checked.
 * @return true if it is a Set, otherwise false. Undefined and null return
 *		   false.
 */
function isSet(value)
{
	if (value != undefined)
	{
		return isSpecificCustomObject(value, "Set");
  	}
	return false;
}

/**
 * Checks that the passed value is a simple map / dictionary. These are simple
 * JavaScript objects created as follows: {key1: value1, key2: value2}
 * This is a very basic test, since it can only tell that it is passed an
 * Object. Note that it is preferable to use a true Map object (see isMap()).
 * @param value the value to be checked.
 * @return true if it is a simple map, otherwise false. Undefined and null return
 *		   false.
 */
function isSimpleMap(value)
{
	if (value != undefined)
	{
		if (typeof value == 'object')
		{
			var criterion = value.constructor.toString().match(/function Object()/);
			
	 		if(criterion != null)
	 		{
				return true;
			}
		}
  	}
	return false;
}

/**
 * Checks that the passed value is a node in a Web Services (SOAP) response.
 * These objects contain a soapName, soapQName, and soapValue. This does not
 * rely on soapValue being populated.
 * @param value the value to be checked.
 * @return true if it is a SOAP response node, otherwise false. Undefined and
 *		   null return false.
 */
function isSoapResponseNode(value)
{
	if (value != undefined)
	{
		return (typeof value == 'object' &amp;&amp; value.soapName != undefined);
  	}
	return false;
}

/**
 * Checks that the passed value is an instance of a specific custom Object. This
 * supports objects that an "instanceof" test won't work for but, as a result,
 * have included a "className" variable to use for this purpose. This includes
 * Adobe objects as well as those defined in this code base.
 * @param value the value to be checked.
 * @param className a string containing the name of the class. This value must be
 *		  set in a "className" variable in the object being tested for the test
 *		  to pass.
 * @return true if it is an object of the indicated type, otherwise false.
 *		   Undefined and null return false.
 * @throws an UnexpectedDataType Exception if className is undefined, null, or
 *		   isn't a String.
 */
function isSpecificCustomObject(value, className)
{
	cTypeEnforcer.checkString(className, "TypeChecker", "isSpecificCustomObject",
							  "className");

	if (value != undefined)
	{
		if (typeof value == 'object')
		{
		  	return (value.className == className);
		}
  	}
	return false;
}

/**
 * Checks that the passed value is an array that only contains instances of a
 * specific custom class. This supports objects that an "instanceof" test won't
 * work for but, as a result, have included a "className" variable to use for
 * this purpose. This includes Adobe objects as well as those defined in this
 * code base.
 * @param value the value to be checked.
 * @param className a string containing the name of the class. This value must be
 *		  set in a "className" variable in the object being tested for the test
 *		  to pass.
 * @return true if it is an array that is empty or only contains instances of the
 * 		   indicated custom class, otherwise false. Undefined and null return
 *		   false.
 * @throws an UnexpectedDataType Exception if className is undefined, null, or
 *		   isn't a String.
 */
function isSpecificCustomObjectArray(value, className)
{
	cTypeEnforcer.checkString(className, "TypeChecker",
							  "isSpecificCustomObjectArray", "className");

	if (isArray(value))
	{
		for (var i=0; i &lt; value.length; i++)
		{
			if(!isSpecificCustomObject(value[i], className))
			{
				return false;
			}
		}
		return true;
  	}
	return false;
}

/**
 * Checks that the passed value is a string or a String object.
 * @param value the value to be checked.
 * @return true if it is a string, otherwise false. Undefined and null return
 *		   false.
 */
function isString(value)
{
	if (value != undefined)
	{
		if (typeof value == 'string')
		{
			return true;
		}
		if (typeof value == 'object')
		{
			var criterion = value.constructor.toString().match(/function String()/);
			
	 		if(criterion != null)
	 		{
				return true;
			}
		}
  	}
	return false;
}

/**
 * Checks that the passed value is an array that only contains strings and/or
 * String objects.
 * @param value the value to be checked.
 * @param allowUndefinedContent (optional) true if this should allow the array to
 *		  contain undefined or null values. Defaults to false.
 * @return true if it is an array that is empty or only contains strings,
 *		   otherwise false. Undefined and null return false.
 * @throws an UnexpectedDataType Exception if allowUndefined isn't a boolean,
 *		   undefined, or null.
 */
function isStringArray(value, allowUndefinedContent)
{
	allowUndefinedContent = cTypeEnforcer.checkBoolean(allowUndefinedContent,
		"TypeChecker", "isStringArray", "allowUndefinedContent", true);

	if (isArray(value))
	{
		for (var i=0; i &lt; value.length; i++)
		{
			if (!isString(value[i])
				&amp;&amp; !(allowUndefinedContent &amp;&amp; value[i] == null))
			{
				return false;
			}
		}
		return true;
  	}
	return false;
}

</script>
               <script contentType="application/x-javascript" name="TypeEnforcer">//
/*******************************************************************************
 * This class provides functionality to enforce type checking. Its methods
 * throw exceptions when type checks fail and, in some cases, support type
 * coercion.
 */

//imports
var cException = script.core.util.Exception;
var cMap = script.core.util.Map;
var cNumberUtil = script.core.util.NumberUtil;
var cObjectUtil = script.core.util.ObjectUtil;
var cSet = script.core.util.Set;
var cStringUtil = script.core.util.StringUtil;
var cTypeChecker = script.core.util.TypeChecker;

var EXCLUSION_GROUP_CLASS = "exclGroup";
var FIELD_CLASS = "field";
var INSTANCE_MANAGER_CLASS = "instanceManager";
var SOAP_RESPONSE_CLASS = "SoapResponse";
var SUBFORM_CLASS = "subform";

/**
 * Checks that the passed value is an array object.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed array. When allowUndefined is true, this returns an empty
 *		   array when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   an array.
 */
function checkArray(value, callingClassName, callingMethodName, parameterName,
					allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkArray",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return new Array();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of an array");
  	}

	if (cTypeChecker.isArray(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires an array value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is a boolean or a Boolean object, or (optionally)
 * can be safely be coerced to one.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @param allowCoercion (optional) true if this should allow another data type
 *		  be coerced to a boolean. Defaults to false.
 * @return the passed boolean. When allowUndefined is true, this returns false
 *		   when value is undefined or null. When allowCoercion is true, this
 *		   will attempt to coerce numbers and strings to a boolean using
 *		   NumberUtil and StringUtil.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a valid boolean.
 */
function checkBoolean(value, callingClassName, callingMethodName, parameterName,
					  allowUndefined, allowCoercion)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkBoolean",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}
	if(allowCoercion != undefined)
	{
		checkBoolean(allowCoercion, "TypeEnforcer", "checkBoolean",
					 "allowCoercion");
	}
	else
	{
		allowCoercion = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return false;
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a boolean");
  	}

	if (cTypeChecker.isBoolean(value))
	{
		return value;
	}

	if (allowCoercion)
	{
		if (cTypeChecker.isString(value))
		{
			try
			{
				return cStringUtil.asBoolean(value);
			}
			catch (exception)
			{ //Nothing to do - let it drop through
			}
		}
		else if (cTypeChecker.isNumber(value))
		{
			try
			{
				return cNumberUtil.asBoolean(value);
			}
			catch (exception)
			{ //Nothing to do - let it drop through
			}
		}
	}

	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a boolean value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is a check box object,  To pass this test,
 * the object must populate a className variable and implement an asString()
 * function. This is only applicable to objects defined in this code base.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed boolean. When allowUndefined is true, this returns false
 *		   when value is undefined or null. When allowCoercion is true, this
 *		   will attempt to coerce numbers and strings to a boolean using
 *		   NumberUtil and StringUtil.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a valid boolean.
 */
function checkCheckBox(value, callingClassName, callingMethodName,
						   parameterName)
{
	if(cTypeChecker.isCheckBox(value))
	{
		return value;
	}
	
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a check box Object, not a " 
		  + cObjectUtil.getDescription(value));
}

/**
 * Checks that the passed value is a collection (an Array or Set).
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed collection. When allowUndefined is true, this returns an
 *		   empty Array when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   an Array or Set.
 */
function checkCollection(value, callingClassName, callingMethodName,
						 parameterName, allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkArray",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return new Array();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a collection");
  	}

	if (cTypeChecker.isCollection(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a collection value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is a custom object instance. To pass this test,
 * the object must populate a className variable and implement an asString()
 * function. This is only applicable to objects defined in this code base.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed custom object instance.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a custom object instance.
 */
function checkCustomObject(value, callingClassName, callingMethodName,
						   parameterName)
{
	if (cTypeChecker.isCustomObject(value))
	{
		return value;
	}

	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a custom Object, not a " 
		  + cObjectUtil.getDescription(value));
}

/**
 * Checks that the passed value is a custom class that can be used to create
 * object instances. To pass this test, the class must implement a
 * createInstance() function to retrieve object instances. This is only
 * applicable to objects defined in this code base.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed Field.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a custom class that can be used to create object instances.
 */
function checkCustomObjectFactory(value, callingClassName, callingMethodName,
								  parameterName)
{
	if (cTypeChecker.isCustomObjectFactory(value))
	{
		return value;
	}

	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a custom Object factory, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is a Date.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed map. When allowUndefined is true, this returns a new Date
 *		   when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a map.
 */
function checkDate(value, callingClassName, callingMethodName, parameterName,
				  allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkMap",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return new Date();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a Date");
  	}

	if (cTypeChecker.isDate(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a Date value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is an Adobe Exclusion Group (group of radio
 * buttons).
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed Field.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   an Adobe Exclusion Group.
 */
function checkExclusionGroup(value, callingClassName, callingMethodName,
							 parameterName)
{
	return checkSpecificCustomObject(value, callingClassName, callingMethodName,
					 				 parameterName, EXCLUSION_GROUP_CLASS);
}

/**
 * Checks that the passed value is an Adobe Field.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed Field.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   an Adobe Field.
 */
function checkField(value, callingClassName, callingMethodName,
					parameterName)
{
	return checkSpecificCustomObject(value, callingClassName, callingMethodName,
					 				 parameterName, FIELD_CLASS);
}

/**
 * Checks that the passed value is an Adobe InstanceManager.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed InstanceManager.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   an Adobe InstanceManager.
 */
function checkInstanceManager(value, callingClassName, callingMethodName,
							  parameterName)
{
	return checkSpecificCustomObject(value, callingClassName, callingMethodName,
					 				 parameterName, INSTANCE_MANAGER_CLASS);
}

/**
 * Checks that the passed value is a class or object that implements a specific
 * interface.
 * @param value the class or object to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param anInterface a custom class that defines the interface. The class or
 *		  object being checked must implement of all of the functions present in
 *		  the interface to pass. Unfortunately, the parameters and return types
 *		  are not checked in this implementation.
 * @return the passed class or object.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or does
 *		   not implement all of the required functions.
 */
function checkInterface(value, callingClassName, callingMethodName,
						parameterName, anInterface)
{
	if (!cTypeChecker.isInterface(anInterface))
	{
		throw _createUnexpectedDataTypeException( 
			  "TypeEnforcer.checkInterface(anInterface) was passed "
			  + cObjectUtil.getDescription(value) + " instead of an interface");
  	}
	if (value == undefined)
	{
		throw _createUnexpectedDataTypeException(callingClassName + "." 
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of an implementation of " 
			  + anInterface.interfaceName);
  	}

	if (cTypeChecker.implementsInterface(value, anInterface))
	{
		return value;
  	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName + ")" 
		  + " requires an implementation of " + anInterface.interfaceName + ", not a " 
		  + cObjectUtil.getDescription(value));
}

/**
 * Checks that the passed value is a Map (dictionary).
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed Map. When allowUndefined is true, this returns an empty
 *		   Map when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a Map.
 */
function checkMap(value, callingClassName, callingMethodName, parameterName,
				  allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkMap",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return cMap.createInstance();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a Map");
  	}

	if (cTypeChecker.isMap(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a Map value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is an Adobe Node. This isn't failsafe, since it
 * does so by testing for the presence of a somExpression property (which other
 * objects may also implement). This is necessary since there are multiple Node
 * subclasses.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed value.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a Node.
 */
function checkNode(value, callingClassName, callingMethodName, parameterName,
				  allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkNode",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return value;
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a Node");
  	}

	if (cTypeChecker.isNode(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a Node value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is an array of strings and/or String objects.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed value, even if its an empty array. When allowUndefined is
 *		   true, this returns an empty array when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a valid string.
 */
function checkNodeArray(value, callingClassName, callingMethodName,
						parameterName, allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkNodeArray",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return new Array();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "." 
			  + callingMethodName + "(" + parameterName + ")"
			  + " was passed undefined or null instead of a Node Array");
  	}

	if (cTypeChecker.isArray(value))
	{
		for (var i=0; i &lt; value.length; i++)
		{
			if(!isNode(value[i]))
			{
				throw _createUnexpectedDataTypeException(
					  callingClassName + "."  + callingMethodName + "(" 
					  + parameterName + ") requires a Node" 
					  + " Array value, but the Array contains a " 
					  + cObjectUtil.getDescription(value[i]));	
			}
		}
		return value;
  	}

	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName + ")"
		  + " requires a Node Array value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is, or can be successfully converted to, a
 * number.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed value as a number primitive. When allowUndefined is true,
 *		   this returns 0 when value is undefined or null. Note that this only
 *		   uses basic JavaScript coersion to create the number.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or
 *		   doesn't contain a valid number.
 */
function checkNumber(value, callingClassName, callingMethodName, parameterName,
					 allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkNumber",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return 0;
		}
		throw _createUnexpectedDataTypeException(callingClassName + "." 
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a number");
  	}
	if (cTypeChecker.isNumber(value))
	{
  		return (+ value); //Forces it to be converted to a number if it's a string
  	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a numeric value, not a " 
		  + cObjectUtil.getDescription(value));
}

/**
 * Checks that the passed value is a radio button field.
 *
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed radio button field.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a valid boolean.
 */
function checkRadioButton(value, callingClassName, callingMethodName,
						   parameterName)
{
	if(cTypeChecker.isRadioButton(value))
	{
		return value;
	}
	
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a radio button, not a " 
		  + cObjectUtil.getDescription(value));
}

/**
 * Checks that the passed value is a Set.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed collection. When allowUndefined is true, this returns an
 *		   empty Set when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a Set.
 */
function checkSet(value, callingClassName, callingMethodName, parameterName,
				  allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkArray",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return cSet.createInstance();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a Set");
  	}

	if (cTypeChecker.isSet(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a Set value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is a simple map / dictionary. These are simple
 * JavaScript objects created as follows: {key1: value1, key2: value2}
 * Note that it is prefereable to use a true Map object (see checkMap()).
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed map. When allowUndefined is true, this returns an empty
 *		   map when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a map.
 */
function checkSimpleMap(value, callingClassName, callingMethodName, parameterName,
				  allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkMap",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return {};
		}
		throw _createUnexpectedDataTypeException(callingClassName + "."
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a simple map");
  	}

	if (cTypeChecker.isSimpleMap(value))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName
		  + ") requires a simple map value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is a SoapResponse.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed SoapResponse.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a SoapResponse.
 */
function checkSoapResponse(value, callingClassName, callingMethodName,
						   parameterName)
{
	return checkSpecificCustomObject(value, callingClassName, callingMethodName,
					 				 parameterName, SOAP_RESPONSE_CLASS);
}

/**
 * Checks that the passed value is a specific custom class. This supports
 * objects that an "instanceof" test won't work for but, as a result, have
 * included a "className" variable to use for this purpose. This includes Adobe
 * objects as well as those defined in this code base.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param className a string containing the name of the class. This value must be
 *		  set in a "className" variable in the object being tested for the test
 *		  to pass.
 * @return the passed value.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or not
 *		   a custom object of the expected class.
 */
function checkSpecificCustomObject(value, callingClassName, callingMethodName,
								   parameterName, className)
{
	checkString(className, "TypeEnforcer", "checkSpecificCustomObject",
				"className");

	if (value == undefined)
	{
		throw _createUnexpectedDataTypeException(callingClassName + "." 
			  + callingMethodName + "(" + parameterName
			  + ") was passed undefined or null instead of a " 
			  + className);
  	}

	if (cTypeChecker.isSpecificCustomObject(value, className))
	{
		return value;
  	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName + ")" 
		  + " requires a " + className + ", not a " 
		  + cObjectUtil.getDescription(value));
}

/**
 * Checks that the passed value is a string or a String object.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @return the passed value as a string primitive. When allowUndefined is true,
 *		   this returns "" when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a valid string.
 */
function checkString(value, callingClassName, callingMethodName, parameterName,
					 allowUndefined)
{
	if(allowUndefined != undefined)
	{
		checkBoolean(allowUndefined , "TypeEnforcer", "checkString",
					 "allowUndefined");
	}
	else
	{
		allowUndefined = false;
	}

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return "";
		}
		throw _createUnexpectedDataTypeException(callingClassName + "." 
			  + callingMethodName + "(" + parameterName + ")"
			  + " was passed undefined or null instead of a string");
  	}

	if (cTypeChecker.isString(value))
	{
		if (typeof value == 'object')
		{
			return value.valueOf(); //Get its primitive
		}
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName + ")"
		  + " requires a String value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is an array of strings and/or String objects.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @param allowUndefined (optional) true if this should allow an undefined or
 *		  null value without throwing an exception. Defaults to false.
 * @param allowUndefinedContent (optional) true if this should allow the array
 *		  to contain undefined or null values without throwing an exception.
 *		  Defaults to false.
 * @return the passed value, even if its an empty array. When allowUndefined is
 *		   true, this returns an empty array when value is undefined or null.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   a valid string.
 */
function checkStringArray(value, callingClassName, callingMethodName,
						  parameterName, allowUndefined, allowUndefinedContent)
{
	allowUndefined = checkBoolean(allowUndefined , "TypeEnforcer",
					 "checkStringArray", "allowUndefined", true);
	allowUndefinedContent = checkBoolean(allowUndefinedContent, "TypeEnforcer",
							"checkStringArray", "allowUndefinedContent", true);

	if (value == undefined)
	{
		if (allowUndefined)
		{
			return new Array();
		}
		throw _createUnexpectedDataTypeException(callingClassName + "." 
			  + callingMethodName + "(" + parameterName + ")"
			  + " was passed undefined or null instead of a String Array");
  	}

	if (cTypeChecker.isStringArray(value, allowUndefinedContent))
	{
		return value;
	}
	throw _createUnexpectedDataTypeException(callingClassName + "." 
		  + callingMethodName + "(" + parameterName + ")"
		  + " requires a String Array value, not a " 
		  + cObjectUtil.getDescription(value));	
}

/**
 * Checks that the passed value is an Adobe Subform.
 * @param value the value to be checked.
 * @param callingClassName the name of the calling class for exception
 *		  reporting.
 * @param callingMethodName the name of the calling method for exception
 *		  reporting.
 * @param parameterName the name of the calling method's parameter for exception
 *		  reporting.
 * @return the passed Subform.
 * @throws an UnexpectedDataType Exception if value is undefined, null, or isn't
 *		   an Adobe Subform.
 */
function checkSubform(value, callingClassName, callingMethodName,
					  parameterName)
{
	return checkSpecificCustomObject(value, callingClassName, callingMethodName,
					 				 parameterName, SUBFORM_CLASS);
}

//===== PRIVATE ================================================================

/**
 * Creates an UnexpectedDataType Exception with the passed message.
 * @param message a string containing the Exception's message.
 * @return the new Exception.
 */
function _createUnexpectedDataTypeException(message)
{
	return cException.createInstance(message, "UnexpectedDataType");
}
</script>
               <script contentType="application/x-javascript" name="UiUtil">//
/*******************************************************************************
 * A class that contains utility functions for dealing with the user interface.
 */

// Import
var cCodeableInterface = script.core.model.CodeableInterface; 
var cConfigurationManager = script.core.util.ConfigurationManager;
var cException = script.core.util.Exception;
var cListItemInterface = script.core.model.ListItemInterface;
var cLog = script.core.util.Log;
var cNodeUtil = script.core.util.NodeUtil;
var cObjectUtil = script.core.util.ObjectUtil;
var cResourceManager = script.core.lang.ResourceManager;
var cStringUtil = script.core.util.StringUtil;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;

var focusTarget = null;

/**
 * Adjusts the passed pickList to allow the entry of custom text (behave like a
 * combo box) or not.
 * @param aPickList an Adobe field (pickList) on the form.
 * @param aBoolean - true if the pickList should allow the entry of custom text.
 * @throws an UnexpectedDataType Exception if the either of the passed
 *		   parameters are undefined, null, or aren't the expected data types.
 */
function allowCustomTextEntry(aPickList, aBoolean)
{
	cTypeEnforcer.checkField(aPickList, "UiUtil", "allowCustomTextEntry",
							"aPickList");
	cTypeEnforcer.checkBoolean(aBoolean, "UiUtil", "allowCustomTextEntry",
							   "aBoolean");

	var choiceList = xfa.resolveNode(aPickList.somExpression + ".ui.#choiceList")
	var entryValue = (aBoolean) ? "1" : "0";

	if (choiceList != null)
	{
		choiceList.textEntry = entryValue;
	}
	else
	{
		throw cException.createInstance("UiUtil.allowCustomTextEntry(aPickList)"
		  + " requires a PickList value, not a " 
		  + cObjectUtil.getDescription(aPickList), "UnexpectedDataType");
	}
}

/**
* Clears the contents of a given subform. This will remove every removeable 
*   instance, and clear every field that is a desenddent of the provided subform.
* @param aSubform the subform to clear
* @throws an UnexpectedDataType Exception if the passed node is undefined,
*		   null, or isn't an Adobe node.
*/
function clearContentsOfSubform(aSubform)
{
	cTypeEnforcer.checkNode(aSubform, "UiUtil", "clearContentsOfSubform", 	
		"aSubform");
	
	for(var i = aSubform.nodes.length - 1; i &gt;= 0; i--)
	{
		var childNode = aSubform.nodes.item(i);
		if(childNode.className == "field"
		|| childNode.className == "exclGroup"
		|| childNode.className == "subform")
		{
			_clearNode(childNode);
		}
	}
}

/**
* Clears a given node. This will remove every removeable instance, and clear 
*   every field that is a desenddent of the provided subform. This will also
*   clear the given node, if it is a removeable subform.
* @param aNode the node to clear
*/
function _clearNode(aNode)
{
	if(aNode.className == "subform")
	{
		if(aNode.occur.min &lt;= aNode.index)
		{
			aNode.instanceManager.removeInstance(aNode.index);
		}
		else
		{
			for(var i = aNode.nodes.length - 1; i &gt;= 0; i--)
			{
				var childNode = aNode.nodes.item(i);
				if(childNode.className == "field"
				|| childNode.className == "exclGroup"
				|| childNode.className == "subform")
				{
					_clearNode(childNode);
				}
			}
		}
	}
	else if(aNode.className == "field"
		 || aNode.className == "exclGroup")
	{
		aNode.rawValue = "";
	}
}

/**
 * Converts a collection of Objects that implement the ListItemInterface to a
 * comma-delimited String suitable for updating a picklist in the UI. This may
 * be a relatively expensive process.
 * @param aListItemCollection an Array or Set of the Objects that implement the
 *		  ListItemInterface that are to be displayed in the list.
 * @return a comma delimited String containing the valid values to be displayed
 *		   in a pick list. An empty String if aListItemCollection is empty.
 * @throws an UnexpectedDataType Exception if aListItemCollection is undefined,
 *		   null, or isn't an Array or Set.
 * @throws an InvalidArgument Exception if any of the items in
 *		   aListItemCollection don't implement the interface.
 */
function convertListItemsToString(aListItemCollection)
{
	cTypeEnforcer.checkCollection(aListItemCollection, "UiUtil",
				  "convertListItemsToString", "aListItemCollection");
	var item;
	var result = "";

	for (var i=0; i &lt; aListItemCollection.length; i++)
	{
		item = aListItemCollection[i];
		//A bit more efficient way of checking the interface than using
		//TypeChecker.implementsInterface(). Optimized for looping...
		if (item.getItemCode == null || item.getItemDescription == null)
		{
			throw cException.createInstance(
				  "UiUtil.convertListItemsToString(aListItemCollection): all"
				  + " items must implement the ListItemInterface",
				  "InvalidArgument");
		}
		if (i &gt; 0)
		{
			result += ",";
		}
		result += cStringUtil.cleanPickListEntry(item.getItemDescription());
		result += "," + cStringUtil.cleanPickListEntry(item.getItemCode());
	}
	return result;
}

/**
 * Makes the passed node invisible.
 * @param aNode an Adobe node (field) on the form.
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node.
 */
function hide(aNode)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "hide", "aNode");

	if (cNodeUtil.hasProperty(aNode, "presence"))
	{
		aNode.presence = "hidden";
	}
}

/**
 * Gets the value of the passed checkBox.
 * @param aRadioButtonNode the Adobe checkBox field node to check.
 * @return a boolean - true if the checkBox is checked.
 * @throws an UnexpectedDataType Exception if aCheckBoxNode is undefined, null,
 *		   or isn't an Adobe checkBox node.
 */
function isCheckBoxChecked(aCheckBoxNode)
{
	cTypeEnforcer.checkCheckBox(aCheckBoxNode, "UiUtil", "setCheckBox",
								"aCheckBoxNode");
	
	return aCheckBoxNode.rawValue == aCheckBoxNode.items.nodes.item(0).value;
}

/**
 * Gets whether the passed node is required (mandatory).
 * @param aNode an Adobe node (field) on the form.
 * @return a boolean - true if the passed node is mandatory. This will also
 *		   return false if the node doesn't have a mandatory property.
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node.
 */
function isMandatory(aNode)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "isMandatory", "aNode");

	if (cNodeUtil.hasProperty(aNode, "mandatory"))
	{	
		return (aNode.mandatory == "error");
	}
	return false;
}

/**
 * Gets whether the passed node is a required (mandatory) group. This
 * applies to a group of radio buttons where one must be selected.
 * @param aNode an Adobe node (field) on the form.
 * @return a boolean - true if the passed node is a mandatory radio button
 *		   group. This will also return false if the node isn't a radio button
 *		   group.
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node.
 */
function isMandatoryGroup(aNode)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "isInMandatoryGroup", "aNode");

	return (cTypeChecker.isSpecificCustomObject(aNode,
						 cTypeEnforcer.EXCLUSION_GROUP_CLASS)
			&amp;&amp; aNode.validate.nullTest == "error");
}

/**
 * Gets whether the passed checkButton (radio button) field node is selected
 * for the passed exclGroup node. This is done to avoid unnecessary UI updates.
 * @param aRadioButtonNode a checkButton field Adobe node (i.e. radio button)
 *        that is a child of the given exclGroup node
 * @return a boolean - true if the node was updated.
 * @throws an UnexpectedDataType Exception if the aNode is undefined, null, or
 *		   isn't an Adobe node or if the value isn't one of the required types.
 */
function isRadioButtonSelected(aRadioButtonNode)
{
	anExclusionGroupNode = aRadioButtonNode.parent;

	cTypeEnforcer.checkExclusionGroup(anExclusionGroupNode, "NodeUtil",
				  "selectRadioButton", "anExclusionGroupNode");
	cTypeEnforcer.checkRadioButton(aRadioButtonNode, "NodeUtil",
				  "selectRadioButton", "aRadioButtonNode");

	// aRadioButtonNode.items.nodes.item(0) should always exist
	return (anExclusionGroupNode.rawValue == 
							aRadioButtonNode.items.nodes.item(0).value); 
}

/**
 * Gets whether the passed node is read-only.
 * @param aNode an Adobe node (field) on the form.
 * @return a boolean - true if the passed node is read-only.
 * @throws an UnexpectedDataType Exception if the passed node is undefined, null,
 *		   or isn't an Adobe node.
 */
function isReadOnly(aNode)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "isReadOnly", "aNode");

	if (cNodeUtil.hasProperty(aNode, "access"))
	{
		return (aNode.access != "open");
	}
	return false;
}

/**
 * Gets whether the passed node is visible.
 * @param aNode an Adobe node (field) on the form.
 * @return a boolean - true if the passed node is visible.
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node.
 */
function isVisible(aNode)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "isVisible", "aNode");

	if (cNodeUtil.hasProperty(aNode, "presence"))
	{
		return (aNode.presence == "visible");
	}
	return false;
}

/**
 * Moves the focus to the target field that was set in setFocus(). Has no effect
 * if the target field has not been set. This should be called from a function
 * bound to a ready:layout event in the form. The target is automatically cleared
 * so it only happens once. See setFocus() for more details.
 */
function moveFocus()
{
	if (focusTarget != null)
	{
		xfa.host.setFocus(focusTarget);
		focusTarget = null;
	}
}

/**
 * Sets the colour of the passed field to its "normal" state. If it is
 * currently read-only, it is set to that color. If not, it is set to how it was
 * defined in the template (i.e. as it was originally coded in the IDE).
 * @param aField an Adobe field on the form.
 * @param force (optional) a Boolean. When true, this will set the field's color
 *		  to the value of its template even if it is read only.
 * @throws an UnexpectedDataType Exception if the passed field is undefined,
 *		   null, or isn't an Adobe field or if force isn't a booelan.
 * @throws a MissingDefinition Exception if the passed field was not defined in
 *		   the template.
 */
function resetColour(aField, force)
{		
	cTypeEnforcer.checkField(aField, "UiUtil", "resetColour", "aField");
	force = cTypeEnforcer.checkBoolean(force, "UiUtil", "resetColour", "force",
									   true);

	if (isReadOnly(aField) &amp;&amp; !(force))
	{
		setColour(aField, cConfigurationManager.get("colourReadOnly"));
	}
	else
	{
		var template = cNodeUtil.getTemplate(aField);
		
		if(template == null)
		{
			throw cException.createInstance("UiUtil.resetColour(aNode): No "
				  + "definition for field '" + aField.name + "' found in the template",
				  "MissingDefinition");
		}
		setColour(aField, template.fillColor);
	}
}

/**
 * Sets the value of the exclGroup node to the value of the passed checkButton
 * field node. Note that this does not alter the node if its current value is
 * the same as the one passed. This is done to avoid unnecessary UI updates.
 *
 * Relies on updateNode to perform the update.  This method extracts the value
 * from a checkButton and sends it to updateNode to do the job.
 * 
 * @param aRadioButtonNode a checkButton field Adobe node
 *        (i.e. the radio button) that is a child of the given exclGroup node
 * @return a boolean - true if the node was updated.
 * @throws an UnexpectedDataType Exception if the aNode is undefined, null, or
 *		   isn't an Adobe node or if the value isn't one of the required types.
 */
function selectRadioButton(aRadioButtonNode)
{
	anExclusionGroupNode = aRadioButtonNode.parent;

	cTypeEnforcer.checkExclusionGroup(anExclusionGroupNode, "UiUtil",
				  "selectRadioButton", "anExclusionGroupNode");
	cTypeEnforcer.checkRadioButton(aRadioButtonNode, "UiUtil",
				  "selectRadioButton", "aRadioButtonNode");
	
	// aRadioButtonNode.items.nodes.item(0) should always exist
	return updateNode(anExclusionGroupNode,
					  aRadioButtonNode.items.nodes.item(0).value); 
}

/**
 * Sets the caption (label) of a field. This handles both plain text and rich
 * text (XML). It will update the plain text if that is present on the node.
 * When dealing with plain text, it will automatically append an asterix to the
 * end of the label if the field is mandatory.
 * @param aNode an Adobe node (field) on the form.
 * @param text a String that contains the caption to be set on the field.
 * @throws an UnexpectedDataType Exception if the either of the passed
 *		   parameters are undefined, null, or aren't the expected data types.
 */
function setCaption(aNode, text)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "setCaption", "aNode");
	cTypeEnforcer.checkString(text, "UiUtil", "setCaption", "text");

	var plainTextNode;

	switch(aNode.className)
	{
		case "field":
			plainTextNode = xfa.resolveNode(aNode.somExpression 
										   + ".caption.value.#text");
			if (plainTextNode != null)
			{
				if (text.length &gt; 0 &amp;&amp; isMandatory(aNode))
				{
					text += " *";
				}
				plainTextNode.value = text;
			}
			else
			{
				var richTextNode = xfa.resolveNode(aNode.somExpression
								   + ".caption.value.exData");

				if (richTextNode != null)
				{
					try {
						richTextNode.loadXML(text);		

					} catch (exception) {
						cLog.warn("UiUtil.setCaption -problem updating "
							 + "the rich text for node '" + aNode.somExpression 
							 + "'", exception);
					}
				}
				else //Should never happen
				{
					cLog.warn("UiUtil.setCaption -node '" + aNode.somExpression
						 + "' doesn't have plain text or rich text to update");
				}
			}
			break;

		case "draw":
			plainTextNode = xfa.resolveNode(aNode.somExpression + ".value.#text");
			if (plainTextNode != null)
			{
				plainTextNode.value = text;
			}
			else
			{
				var richTextNode = xfa.resolveNode(aNode.somExpression 
												  + ".value.exData");

				if (richTextNode != null)
				{
					try {
						richTextNode.loadXML(text);		

					} catch (exception) {
						cLog.warn("UiUtil.setCaption -problem updating the "
							 + "rich text for node '" + aNode.somExpression + "'",
							 exception);
					}
				}
				else //Should never happen
				{
					cLog.warn("UiUtil.setCaption -node '"
							  + aNode.somExpression 
							  + "' doesn't have plain text or rich text to update");
				}
			}
			break;
	}
}

/**
 * Sets the colour of the passed field.
 * @param aNode an Adobe field on the form.
 * @param colour a String that contains the colour as comma delimited RGB
 *		  numeric values (e.g. "230,125,125").
 * @throws an UnexpectedDataType Exception if the either of the passed
 *		   parameters are undefined, null, or aren't the expected data types.
 */
function setColour(aField, colour)
{		
	cTypeEnforcer.checkField(aField, "UiUtil", "setColour", "aField");
	cTypeEnforcer.checkString(colour, "UiUtil", "setColour", "colour");
	
	if (aField.fillColor != colour)
	{
		var previousPresence = aField.border.edge.presence;
	
		aField.border.fill.presence = "visible";
		aField.fillColor = colour;		
		aField.border.edge.presence = previousPresence; //Gets reset	
	}
}

/**
 * This is used to move focus to a specific field. Focus cannot be moved
 * directly using the Adobe functions, since JavaScript is processed before the
 * form layout is ready to be rendered. It will have no effect. Instead, this
 * method is used to set the target field so that it can be moved to when the
 * layout is ready.
 * For this to work, a call to moveFocus() should be made from a function bound
 * to a ready:layout event in the form. That will move the focus to the target
 * field and clear it so it only happens once.
 * @param aField an Adobe field node where focus should be passed to.
 * @throws an UnexpectedDataType Exception if the passed field is undefined,
 *		   null, or isn't an Adobe field.
 */
function setFocus(aField)
{
	cTypeEnforcer.checkField(aField, "UiUtil", "setFocus", "aField");

	focusTarget = aField;
}

/**
 * Sets whether the passed node is required (mandatory). This is usually part of
 * its UI definition, but it occasionally needs to be changed based on business
 * rules.
 * @param aNode an Adobe node (field) on the form.
 * @param aBoolean a boolean - true if the passed node should be mandatory.
 * @throws an UnexpectedDataType Exception if the either of the passed
 *		   parameters are undefined, null, or aren't the expected data types.
 */
function setMandatory(aNode, aBoolean)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "setMandatory", "aNode");
	cTypeEnforcer.checkBoolean(aBoolean, "UiUtil", "setMandatory", "aBoolean");
	
	if (cNodeUtil.hasProperty(aNode, "mandatory"))
	{
		if (aBoolean)
		{
			aNode.mandatory = "error";
		}
		else
		{
			aNode.mandatory = "";
		}
	}
	else
	{
		cLog.warn("UiUtil.setMandatory(aNode): node '" 
				  + cStringUtil.formatSomExpression(aNode.somExpression) 
				  + "' does not have a mandatory property");
	}
}

/**
 * Sets a pick list for a given field, based on the passed object that contains
 * the values. This will automatically add an empty item to the top of the list
 * if the field isn't mandatory. It will also automatically select the item from
 * the list if there is only one.
 * @param aNode an Adobe node (field) on the form.
 * @param anObject the object that contains the list values. This must be one of:
 *		  1)A String containing a comma delimited list of values to be displayed
 *		  	in the list. This assumes 2 columns (see numberOfColumns in
 *			setPickListFromString() for interpretation details).
 *		  2)An Array or Set of Objects that implement the ListItem Interface.
 *		  3)An Array or Set of the Strings that are the values. Note that this
 *			assumes these are not coded (i.e. 1 column).
 *		  4)Null, which will clear the list.
 * @throws an UnexpectedDataType Exception if the aNode is undefined, null, or
 *		   isn't an Adobe Node.
 * @throws an InvalidArgument Exception if anObject isn't one of the required
 *		   types.
 */
function setPickList(aNode, anObject)
{
	cTypeEnforcer.checkField(aNode, "UiUtil", "setPickList", "aNode");

	if (anObject == null || cTypeChecker.isString(anObject))
	{
		setPickListFromString(aNode, anObject, 2, false);
		return;
	}
	
	if (cTypeChecker.isCollection(anObject))
	{
		if (anObject.length == 0)
		{
			aNode.clearItems();
			return;
		}
		if (cTypeChecker.isString(anObject[0]))
		{
			var pickListString = "";

			for (var i=0; i &lt; anObject.length; i++)
			{
				if (i &gt; 0)
				{
					pickListString += ",";
				}
				pickListString += cStringUtil.cleanPickListEntry(anObject[i]);
			}
			setPickListFromString(aNode, pickListString, 1, false);
			return;
		}
		if (cTypeChecker.implementsInterface(anObject[0], cListItemInterface))
		{
			setPickListFromString(aNode, convertListItemsToString(anObject), 2,
								  false);
			return;
		}
	}

	throw cException.createInstance("UiUtil.setPickList(anObject): all items"
		  + "must implement the ListItemInterface", "InvalidArgument");
}

/**
 * Sets a pick list for a given field, based on a comma-delimited string. This
 * will automatically add an empty item to the top of the list if the field isn't
 * mandatory. It will also automatically select the item from the list if there
 * is only one.
 * @param aNode an Adobe node (field) on the form.
 * @param commaDelimitedString a String containing the valid values to be
 *		 displayed in the list. Any embedded commas in the values must be escaped
 *		 with an additional comma. See numberOfColumns for interpretation details.
 *		 If passed null or an empty String, the list will be cleared.
 * @param numberOfColumns (optional) a number that indicates the number of
 *		  columns of data there are. When used, this must be a 1 or 2. When it is
 *		  1, the commaDelimitedString is interpreted as "value1,value2,value3...".
 *		  When it is 2, the commaDelimitedString is interpreted as
 *		  "displayValue1,code1,displayValue2,code2,...". Defaults to 2.
 * @param forceClear (optional) a boolean that indicates whether this should
 *		  always clear the selected value. If false, this only clears it if it
 *		  isn't in the new pick list. Defaults to false.
 * @throws an UnexpectedDataType Exception if the passed parameters are
 *		   undefined, null, or aren't the expected data types.
 * @throws an InvalidArgument Exception if numberOfColumns isn't 1 or 2.
 */
function setPickListFromString(aNode, commaDelimitedString, numberOfColumns,
							   forceClear)
{
	cTypeEnforcer.checkField(aNode, "UiUtil", "setPickListFromString",
							 "aNode");
	commaDelimitedString = cTypeEnforcer.checkString(commaDelimitedString,
			"UiUtil", "setPickListFromString", "commaDelimitedString", true);
	cTypeEnforcer.checkNumber(numberOfColumns, "UiUtil",
		 		  "setPickListFromString", "numberOfColumns", true);
	forceClear = cTypeEnforcer.checkBoolean(forceClear, "UiUtil",
							   "setPickListFromString", "forceClear", true);

	if (numberOfColumns == undefined)
	{
		numberOfColumns = 2;
	}
	else if (numberOfColumns != 1 &amp;&amp; numberOfColumns != 2)
	{
		throw cException.createInstance("UiUtil.setPickList(numberOfColumns)"
		+ " was " + numberOfColumns 
		+ ", but must be 1 or 2.", "InvalidArgument");
	}
	
	if (commaDelimitedString.length &gt; 0 &amp;&amp; !isMandatory(aNode) 
		&amp;&amp; !cTypeChecker.isComboBox(aNode))
	{
		if (numberOfColumns == 2)
		{
			commaDelimitedString = cResourceManager.get("listItem_empty") 
								   + "," + cCodeableInterface.NO_ENTRY_CODE
								   + "," + commaDelimitedString;
		}
		else //Assume that it's 1
		{
			commaDelimitedString = cResourceManager.get("listItem_empty")
								   + "," + commaDelimitedString;
		}
	}
	aNode.setItems(commaDelimitedString, numberOfColumns);

	if (aNode.length == 1 &amp;&amp; !cTypeChecker.isComboBox(aNode))
	{
		aNode.selectedIndex = 0;
	}
	if (forceClear || aNode.selectedIndex == -1)
	{
		if (cTypeChecker.isComboBox(aNode))
		{
			if (aNode.rawValue == null || aNode.rawValue == "")
			{
				aNode.rawValue = cResourceManager.get("listItem_userDefined");
			}
		}
		else
		{
			aNode.rawValue = "";
		}
	}
}

/**
 * Sets whether the passed node is read-only. Note that this also adjusts the
 * colour.
 * @param aNode an Adobe node (field) on the form.
 * @param aBoolean - true if the passed node is read-only.
 * @throws an UnexpectedDataType Exception if the either of the passed
 *		   parameters are undefined, null, or aren't the expected data types.
 */
function setReadOnly(aNode, aBoolean)
{	
	cTypeEnforcer.checkNode(aNode, "UiUtil", "setReadOnly", "aNode");
	cTypeEnforcer.checkBoolean(aBoolean, "UiUtil", "setReadOnly", "aBoolean");
		
	if (cNodeUtil.hasProperty(aNode, "access"))
	{
		if (aBoolean)
		{
			aNode.access = "readOnly";
			setColour(aNode, cConfigurationManager.get("colourReadOnly"));
		}
		else
		{
			aNode.access = "open";
			resetColour(aNode);
		}
	}
	else
	{
		cLog.warn("UiUtil.setReadOnly(aNode): node '" 
				  + cStringUtil.formatSomExpression(aNode.somExpression) 
				  + "' does not have an access property");
	}
}

/**
 * Sets the plain-text tool tip of a field.
 * @param aNode an Adobe node (field) on the form.
 * @param plainText a String that contains the tooltip to be set on the field.
 *		  Undefined or null are treated the same as an empty string - they clear
 *		  any existing tool tip
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node, or if the plainText isn't a String.
 */
function setToolTip(aNode, plainText)
{
	//cTypeEnforcer.checkField(aNode, "UiUtil", "setToolTip", "aNode");
	cTypeEnforcer.checkNode(aNode, "UiUtil", "setToolTip", "aNode");
	plainText = cTypeEnforcer.checkString(plainText, "UiUtil", "setToolTip",
										  "plainText", true);	

	if(!plainText)
	{
		aNode.assist.speak.disable = "0";
	}
	else
	{
		//dan added start
		if(isMandatory(aNode)){
			plainText += " *";
		}		
		aNode.assist.toolTip.value = plainText;			
	}
	
}

/**
 * Makes the passed node visible.
 * @param aNode an Adobe node (field) on the form.
 * @throws an UnexpectedDataType Exception if the passed node is undefined,
 *		   null, or isn't an Adobe node.
 */
function show(aNode)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "show", "aNode");

	if (cNodeUtil.hasProperty(aNode, "presence"))
	{
		aNode.presence = "visible";
	}
}

/**
 * Sets the value of the passed checkBox to the passed boolean.
 * @param aRadioButtonNode the Adobe checkBox field node to update.
 * @param aBoolean true if the checkBox should be checked.
 * @throws an UnexpectedDataType Exception if aCheckBoxNode is undefined, null,
 *		   or isn't an Adobe checkBox node.
 * @throws an UnexpectedDataType Exception if aBoolean is undefined, null, or
 *		   isn't a boolean.
 */
function updateCheckBox(aCheckBoxNode, aBoolean)
{
	cTypeEnforcer.checkCheckBox(aCheckBoxNode, "UiUtil", "setCheckBox",
								"aCheckBoxNode");
	cTypeEnforcer.checkBoolean(aBoolean, "UiUtil", "setCheckBox",
							   "aBoolean");
	
	var index = aBoolean? 0 : 1;

	aCheckBoxNode.rawValue = aCheckBoxNode.items.nodes.item(index).value; 
}

/**
 * Sets the value of the passed node to the passed value. Note that this does
 * not alter the node if its current value is the same as the one passed.
 * This is done to avoid unnecessary UI updates.
 * @param aNode an Adobe node (field or exclusion group) on the form.
 * @param value the new value for the field. This must be a String, boolean,
 *		  number, or null.
 * @return a boolean - true if the node was updated.
 * @throws an UnexpectedDataType Exception if the aNode is undefined, null, or
 *		   isn't an Adobe node or if the value isn't one of the required types.
 */
function updateNode(aNode, value)
{
	cTypeEnforcer.checkNode(aNode, "UiUtil", "updateNode", "aNode");
	
	// STEP 1: coerce the value, if necessary

	//The UI shows "empty" for values of undefined
	if (value === undefined)
	{
		value == null;
	}

	if (value != null &amp;&amp; !cTypeChecker.isString(value))
	{
		if (cTypeChecker.isBoolean(value) 
			|| cTypeChecker.isNumber(value))
		{
			value = value.toString();
		}
		else
		{
			throw cException.createInstance("UiUtil.updateNode(value) expected" 
	    		  + " a String, number, or boolean but got a " + value,
	    		  "UnexpectedDataType");
		}
	}
	
	// STEP 2: update the node
	var richTextNode = xfa.resolveNode(aNode.somExpression
						   + ".value.exData");

	// the field uses RichText, store the XML
	if (richTextNode != null)
	{
		try {
			richTextNode.loadXML(value);		

		} catch (exception) {
			cLog.warn("UiUtil.updateNode -problem updating "
				 + "the rich text for node '" + aNode.somExpression 
				 + "'", exception);
		}
		return true;
	}
	// the field uses plain text, store the text
	else if (aNode.rawValue != value)
	{
		aNode.rawValue = value;
		return true;
	}

	return false;
}
</script>
               <?templateDesigner expand 1?></variables>
            <?templateDesigner expand 1?></subform>
         <subform w="100mm" h="50mm" name="validation">
            <variables>
               <script contentType="application/x-javascript" name="BasicFormatValidator">//
/*******************************************************************************
 * An object that supports validating the format of Adobe Field values against
 * some basic formatting masks. This may be extended by custom implementations
 * that support additional formats.
 *
 * Implements FormatValidatorInterface.
 */

//imports
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cResourceManager = script.core.lang.ResourceManager;
var cTypeEnforcer = script.core.util.TypeEnforcer;

//Supported format types:
var EMAIL = "email";
var POSTAL_CODE = "postalCode";
var TELEPHONE = "telephone";
var ZIP_CODE = "zipCode";

/**
 * Gets a new BasicFormatValidator. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * @return the new BasicFormatValidator instance
 */
function createInstance()
{
	return new BasicFormatValidatorClass();
}

/**
 * Class implementation
 */
function BasicFormatValidatorClass()
{
	this.className = "BasicFormatValidator";
	
	/**
	 * Gets whether this implementation of format validator supports the passed
	 * format type.
	 * @param formatType a String that contains the name (key) of the format
	 *		  type in question.
	 * @return a boolean - true if the passed format type is supported.
	 * @throws an UnexpectedDataType Exception if formatType is undefined,
	 *		   null, or isn't a String.
	 */
	 this.supportsFormatType = function(formatType)
	 {
		cTypeEnforcer.checkString(formatType, "BasicFormatValidator",
								  "supportsFormatType", "formatType");

		return (formatType == EMAIL || formatType == POSTAL_CODE 
				|| formatType == TELEPHONE || formatType ==  ZIP_CODE);
	 }
	
	/**
	 * Validates the format of the value of the passed Adobe Field.
	 * @param aField the Adobe Field to validate.
	 * @param formatType a String that contains the name (key) of the format
	 *		  validation to apply to the field.
	 * @return a String containing the internationalized error message for any
	 *		   detected problem with the format of the value of the passed
	 *		   field. Null if there were no problems.
	 * @throws an UnexpectedDataType Exception if either of the parameters is
	 *		   undefined, null, or isn't the expected data type.
	 * @throws an UnsupportedFormatType Exception if the formatType is
	 *		   unrecognized or unsupported by the implementation.
	 */
	 this.validateFieldFormat = function(aField, formatType)
	 {
		cTypeEnforcer.checkField(aField, "BasicFormatValidator",
								 "validateFieldFormat", "aField");
		cTypeEnforcer.checkString(formatType, "BasicFormatValidator",
								  "validateFieldFormat", "formatType");

		switch(formatType)
		{
			case EMAIL: 
				return this._validateEmail(aField.rawValue);
			case POSTAL_CODE: 
				return this._validatePostalCode(aField.rawValue);
			case TELEPHONE: 
				return this._validateTelephone(aField.rawValue);
			case ZIP_CODE: 
				return this._validateZipCode(aField.rawValue);
		}
		throw cException.createInstance(
			"BasicFormatValidator.validateFieldFormat(): formatType '" 
			+ formatType + "' not supported", "UnsupportedFormatType");
	 }
			
    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		return this.className + "[]";
	}

	//===== PRIVATE ============================================================

	/**
	 * Validates the passed email address.
	 * @param aString a String that contains the email address to validate.
	 * @return a String containing the internationalized error message if there
	 *		   is problem with the format. Null if there were no problems.
	 */
	this._validateEmail = function(aString)
	{
	    var regExp = /^[a-z0-9_\-\.]+\@[a-z0-9_\-\.]+\.[a-z]+$/i;
	    
		if (regExp.test(aString))
		{
			return null; 
		}
		return cResourceManager.get("error_badEmailFormat");
	}

	/**
	 * Validates the passed postal code.
	 * @param aString a String that contains the postal code to validate.
	 * @return a String containing the internationalized error message if there
	 *		   is problem with the format. Null if there were no problems.
	 */
	this._validatePostalCode = function(aString)
	{
		var cpcRegExp = /^[a-z]\d[a-z](\s)?\d[a-z]\d$/i ;
		
		if (cpcRegExp.test(aString))
		{
			return null; 
		}
		return cResourceManager.get("error_badPostalCodeFormat");
	}
	
	/**
	 * Validates the passed telephone number.
	 * This makes sure that it contains between 9 and 16 digits once non-digit
	 * characters have been removed.
	 * @param aString a String that contains the telephone number to validate.
	 * @return a String containing the internationalized error message if there
	 *		   is problem with the format. Null if there were no problems.
	 */
	this._validateTelephone = function(aString)
	{
	    var filtered = "";   

	    for(var i = 0; i &lt; aString.length; i++)
	    {
	    	var chr = aString.charAt(i);

	    	if(chr &gt;= 0 &amp;&amp; chr &lt;= 9)
	    	{
	    		filtered += chr;
	    	}
	    }
	    
		if (filtered.length  &gt;= 9 &amp;&amp; filtered.length &lt;= 18) //IMSD 4814 European Phone Style extends to 18
		{
			return null; 
		}
		return cResourceManager.get("error_badTelephoneFormat");
	}	
	
	/**
	 * Validates the passed zip code.
	 * @param aString a String that contains the zip code to validate.
	 * @return a String containing the internationalized error message if there
	 *		   is problem with the format. Null if there were no problems.
	 */
	this._validateZipCode = function(aString)
	{
		var uspcRegExp = /^\d{5}([-\s])?(\d{4})?$/i ;
		
		if (uspcRegExp .test(aString))
		{
			return null; 
		}
		return cResourceManager.get("error_badZipCodeFormat");
	}
}

</script>
               <script contentType="application/x-javascript" name="FailureReporter">//
/*******************************************************************************
 * A class used to summarize and format Validation Failures for display
 * purposes.
 */

//imports
var cResourceManager = script.core.lang.ResourceManager;
var cSet = script.core.util.Set;
var cTypeEnforcer = script.core.util.TypeEnforcer;

//Used for indentation
var _PADDING = "                                                                                                    ";
var _TAB_WIDTH = 2;

/**
 * Gets a summary of the error messages in the passed ValidationFailure. This
 * will automatically traverse all nested structures to report on all errors.
 * All instances of the same message are collapsed into one and the specifics
 * about the originator of the messages is lost.
 * @param aValidationFailure the ValidationFailure that contains the error
 *		  messages to be reported. 
 * @return a String that contains a summary of error messages. 
 * @throws UnexpectedDataType Exception if any of aValidationFailure is null,
 *		   undefined, or not a ValidationFailure.
 */
/*function getFailureSummary(aValidationFailure)
{
	cTypeEnforcer.checkSpecificCustomObject(aValidationFailure,
		"FailureReporter", "getFailureSummary", "aValidationFailure",
		"ValidationFailure");

	var errorMessages = cSet.createInstance();
	
	_accumulateErrors(aValidationFailure, errorMessages);
	if (errorMessages.length &gt; 0)
	{
		var buffer = cResourceManager.get("error_validationFailure") + "\n\n";
		
		for (var i=0; i &lt; errorMessages.length; i++)
		{
			//Don't put a dash in front of lines that start with carriage returns
			if (errorMessages[i] != null 
				&amp;&amp; errorMessages[i].indexOf("\n") != 0)
			{
				buffer += "- ";
			}
			buffer += errorMessages[i] + "\n";
		}
		return buffer;
	}
	return ""; //Should never happen
}*/


/**
 * Gets a summary of the error messages in the passed ValidationFailure. This
 * will automatically traverse all nested structures to report on all errors.
 * All instances of the same message are collapsed into one and the specifics
 * about the originator of the messages is lost.
 * @param aValidationFailure the ValidationFailure that contains the error
 *		  messages to be reported. 
 * @return a String that contains a summary of error messages. 
 * @throws UnexpectedDataType Exception if any of aValidationFailure is null,
 *		   undefined, or not a ValidationFailure.
 */
function getFailureSummary(aValidationFailure)
{
	cTypeEnforcer.checkSpecificCustomObject(aValidationFailure,
		"FailureReporter", "getFailureSummary", "aValidationFailure",
		"ValidationFailure");

	var errorMessages = cSet.createInstance();
	
	_accumulateErrors(aValidationFailure, errorMessages);
	if (errorMessages.length &gt; 0)
	{
		var buffer = cResourceManager.get("error_validationFailure") + "\n\n";
		
		for (var i=0; i &lt; errorMessages.length; i++)
		{
			//Don't put a dash in front of lines that start with carriage returns
			if (errorMessages[i] != null 
				&amp;&amp; errorMessages[i].indexOf("\n") != 0)
			{
				buffer += "- ";
			}
			buffer += errorMessages[i] + "\n";
		}
		return buffer;
	}
	return ""; //Should never happen
}


/**
 * Gets a detailed listing of the error messages in the passed ValidationFailure.
 * This will automatically traverse all nested structures to report on all
 * errors. All messages are reported separately in an indented structure under
 * the sections that they happened in.
 * @param aValidationFailure the ValidationFailure that contains the error
 *		  messages to be reported. 
 * @return a String that contains the details of the error messages. 
 * @throws UnexpectedDataType Exception if any of aValidationFailure is null,
 *		   undefined, or not a ValidationFailure.
 */
function getFailureDetails(aValidationFailure)
{
	cTypeEnforcer.checkSpecificCustomObject(aValidationFailure,
		"FailureReporter", "getFailureDetails", "aValidationFailure",
		"ValidationFailure");

	var buffer = cResourceManager.get("error_validationFailure") + "\n";

	if (aValidationFailure.getSourceName() == undefined)
	{ //Must be the base FormNode
		for (var i=0; 
			 i &lt; aValidationFailure.getNestedValidationFailures().length; i++)
		{
			buffer += _recordErrors(
					  aValidationFailure.getNestedValidationFailures()[i],
					  0);
		}	
	}
	else
	{
		buffer += _recordErrors(aValidationFailure, 0);
	}
	return buffer;
}

//===== PRIVATE ================================================================

/**
 * Traverses through the nested structures in the passed ValidationFailure,
 * adding all of the discovered error messages to the passed Set which, by its
 * nature, removes duplicates.
 * This is called recursively as part of the structure traversal.
 * @param aValidationFailure the ValidationFailure that contains the error
 *		  messages to be reported and structures to be traversed. 
 * @param aSet the Set to add error messages to as they are encountered. 
 */
function _accumulateErrors(aValidationFailure, aSet)
{
	if (aValidationFailure.hasFailureMessages())
	{
		aSet.pushAll(aValidationFailure.getFailureMessages());
	}

	if (aValidationFailure.hasNestedValidationFailures())
	{
		for (var j=0; 
			 j &lt; aValidationFailure.getNestedValidationFailures().length; j++)
		{
			_accumulateErrors(
				aValidationFailure.getNestedValidationFailures()[j], aSet);
		}
	}
}

/**
 * Traverses through the nested structures in the passed ValidationFailure,
 * creating a String that lists all of the discovered error messages in an
 * indented structure under the sections that they happened in.
 * This is called recursively as part of the structure traversal.
 * @param aValidationFailure the ValidationFailure that contains the error
 *		  messages to be reported and structures to be traversed. 
 * @param level a number that contains the amount to indent this entry.
 * @return the String that lists the errors for the passed ValidationFailure
 *		   as well as those for its nested ones.
 */
function _recordErrors(aValidationFailure, level)
{
	var buffer = "\n" + _PADDING.substring(0, level * _TAB_WIDTH) 
			 	  + aValidationFailure.getSourceName();
	var isFirst = true;

	if (aValidationFailure.hasFailureMessages())
	{
		for (var i=0; i &lt;aValidationFailure.getFailureMessages().length; i++)
		{
    		if (isFirst)
    		{
				isFirst = false;
				buffer += ": ";
    		}
    		else
    		{
				buffer += ", ";
    		}
			buffer += aValidationFailure.getFailureMessages()[i];
		}
	}

	if (aValidationFailure.hasNestedValidationFailures())
	{
		for (var k=0; 
			 k &lt; aValidationFailure.getNestedValidationFailures().length; k++)
		{
			buffer += _recordErrors(
					  aValidationFailure.getNestedValidationFailures()[k],
					  level + 1);
		}
		buffer += "\n";
	}
	return buffer;
}

</script>
               <script contentType="application/x-javascript" name="FormatValidatorInterface">//
/*******************************************************************************
 * This defines an Interface that is implemented by Objects that are responsible
 * for validating the format of Adobe Field values.
 *
 * Note that these must be implemented by custom Objects in the standard way;
 *	-The Class must contain a "createInstance" method.
 *	-The instance must contain a public "className" variable set to its name.
 *	-The instance must implement "asString()" to get descriptive information.
 */

var interfaceName = "FormatValidatorInterface"; //Required for all interfaces

/**
 * Gets whether the implementation of format validator supports the passed
 * format type.
 * @param formatType a String that contains the name (key) of the format
 *		  type in question.
 * @return a boolean - true if the passed format type is supported.
 * @throws an UnexpectedDataType Exception if formatType is undefined,
 *		   null, or isn't a String.
 */
function supportsFormatType(formatType){}

/**
 * Validates the format of the value of the passed Adobe Field.
 * @param aField the Adobe Field to validate.
 * @param formatType a String that contains the name (key) of the format
 *		  validation to apply to the field.
 * @return a String containing the internationalized error message for any
 *		   detected problem with the format of the value of the passed field.
 *		   Null if there were no problems.
 * @throws an UnexpectedDataType Exception if either of the parameters is
 *		   undefined, null, or isn't the expected data type.
 * @throws an UnsupportedFormatType Exception if the formatType is unrecognized
 *		   or unsupported by the implementation.
 */
function validateFieldFormat(aField, formatType){}
</script>
               <script contentType="application/x-javascript" name="NodeValidator">//
/*******************************************************************************
 * A class used to validate Adobe Nodes in this XFA form.
 */

//imports
var cCodeableInterface = script.core.model.CodeableInterface; 
var cConfigurationManager = script.core.util.ConfigurationManager;
var cException = script.core.util.Exception;
var cFormatValidatorInterface = script.core.validation.FormatValidatorInterface;
var cResourceManager = script.core.lang.ResourceManager;
var cTypeChecker = script.core.util.TypeChecker;
var cTypeEnforcer = script.core.util.TypeEnforcer;
var cUiUtil = script.core.util.UiUtil; 

var _FORMAT_VALIDATOR_KEY = "NodeValidator_formatValidator"; //Key to configuration entry

var formatValidator; //FormatValidatorInterface implementation

/**
 * Validates the value of the passed Adobe Field. This includes a check of
 * mandatory fields as well as performing a format validation if one has been
 * defined for the field.
 * @param aField the Adobe Field to validate.
 * @param formatType (optional) a String that contains the name (key) of a
 *		  format validation to apply to the field.
 * @return a String containing the internationalized error message for any
 *		   detected problem with the value of the passed field. Null if there
 *		   were no problems.
 * @throws an UnexpectedDataType Exception if aField is undefined, null, or
 *		   isn't an Adobe Field, or if formatType isn't a String.
 */
function validateField(aField, formatType)
{
	cTypeEnforcer.checkField(aField, "NodeValidator", "validateField",
							 "aField");
	cTypeEnforcer.checkString(formatType, "NodeValidator",
							  "validateField", "formatType", true);

	if (cUiUtil.isVisible(aField) &amp;&amp; !cUiUtil.isReadOnly(aField))
	{
		if(cTypeChecker.isCheckBox(aField) &amp;&amp; cUiUtil.isMandatory(aField)){
			if(! cUiUtil.isCheckBoxChecked(aField)){
				return cResourceManager.get("error_mandatoryField");
			}
		}
		else if (_isEmpty(aField))
		{
			if (cUiUtil.isMandatory(aField))
			{
				return cResourceManager.get("error_mandatoryField");
			}
		}
		else if (formatType != undefined)
		{
			return _getFormatValidator().validateFieldFormat(aField, formatType);
		}
	}
	return null;
}

/**
 * Validates the value of the passed Adobe ExclusionGroup (group of Radio
 * Buttons). This includes a check of its value if it is defined as mandatory.
 * @param aGroup the Adobe ExclusionGroup to validate.
 * @return a String containing the internationalized error message for any
 *		   detected problem with the value of the passed field. Null if there
 *		   were no problems.
 * @throws an UnexpectedDataType Exception if aGroup is undefined, null, or
 *		   isn't an Adobe ExclusionGroup.
 */
function validateGroup(aGroup)
{
	cTypeEnforcer.checkExclusionGroup(aGroup, "NodeValidator", "validateGroup",
									  "aGroup");

	if (cUiUtil.isVisible(aGroup) &amp;&amp; !_isGroupReadOnly(aGroup))
	{
		if (_isEmpty(aGroup))
		{
			if (cUiUtil.isMandatoryGroup(aGroup))
			{
				return cResourceManager.get("error_mandatoryField");
			}
		}
	}
	return null;
}

//===== PRIVATE ================================================================

/**
 * Gets the implementation of FormatValidatorInterface that is used to validate
 * the format of Adobe Field values when required.
 * This lazy loads a class named in the configuration.
 * @return an Object that implements the FormatValidatorInterface.
 * @throws an UnexpectedDataType Exception if there is a problem resolving the
 *		   configuration entry into an implementation of the interface.
 */
function _getFormatValidator()
{
	if (formatValidator == undefined)
	{
		var formatValidatorSom = cConfigurationManager.get(_FORMAT_VALIDATOR_KEY);

		cTypeEnforcer.checkString(formatValidatorSom, "NodeValidator", 
			"_getFormatValidator", "configuration." + _FORMAT_VALIDATOR_KEY);

		var formatValidatorClass = xfa.resolveNode(formatValidatorSom);

		if (formatValidatorClass == null)
		{
			throw cException.createInstance(
				"NodeValidator._getFormatValidator(): formatValidator '" 
				+ formatValidatorSom + "' cannot be resolved",
				"UnexpectedDataType");
		}
		cTypeEnforcer.checkCustomObjectFactory(formatValidatorClass,
			"NodeValidator", "_getFormatValidator", formatValidatorSom);

		formatValidator = formatValidatorClass.createInstance();

    	cTypeEnforcer.checkInterface(formatValidator, "NodeValidator",
    				  "_getFormatValidator", formatValidatorSom,
    				  cFormatValidatorInterface);
	}
	return formatValidator;
}

/**
 * Gets whether the passed node's value is considered empty (i.e. has no
 * current value).
 * @param aNode the Adobe Node instance to check.
 * @return a boolean - true if the value of the node is considered empty.
 */
function _isEmpty(aNode)
{
	return (aNode.rawValue == undefined
			|| aNode.rawValue == cCodeableInterface.NO_ENTRY_CODE
			|| aNode.rawValue == cResourceManager.get("listItem_userDefined")
			|| new String(aNode.rawValue).search(/[A-Za-z0-9%]/) == -1);
}

/**
 * Verifies if the passed Adobe ExclusionGroup (group of Radio Buttons) and
 * any of its children node is read only.
 * @param aGroup the Adobe ExclusionGroup to validate.
 * @return a boolean - true if the passed Adobe ExclusionGroup or any of its
 * 					   children node is read only.
 */
function _isGroupReadOnly(aGroup)
{
	for (var j = 0; j &lt; aGroup.nodes.length; j++)
	{
		if(cTypeChecker.isSpecificCustomObject(aGroup.nodes.item(j),
											   cTypeEnforcer.FIELD_CLASS) 
			&amp;&amp; !cUiUtil.isReadOnly(aGroup.nodes.item(j)))
		{
			return false;
		}
	}
	return true;
}
</script>
               <script contentType="application/x-javascript" name="ValidationFailure">//
/*******************************************************************************
 * This is a "value" object that contains the information about an object's
 * validation failures. These can be nested to support an object reporting its
 * child object's failures within its own (in a tree structure).
 *
 * In one scenario, these are generated by FormNodes. A field will generate a
 * single instance with a separate message for each way it is invalid (usually
 * only one). The subform that contains the field will generate a single
 * instance with all of its fields' failures in its nested failures collection.
 * If that subform has a parent subform, the parent will generate a single
 * instance with the child subform's instance as part of its nested failures
 * collection.
 *
 * All entries are intended to be localized strings so they can be displayed to
 * the user.
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;
var cLog = script.core.util.Log;
/**
 * Gets a new ValidationFailure. Adobe does not allow object instances to be
 * created outside of their packaging, so it must be done here.
 * @param sourceName a String that contains the name of the object that had
 *		  the validation failure.
 * @param failureMessage (optional) a String that contains the localized
 *		  validation failure message (reason this validation failed).
 * @return the new ValidationFailure instance.
 * @throws UnexpectedDataType Exception if any of the parameters aren't as
 *		   indicated.
 */
function createInstance(sourceName, failureMessage)
{
	return new ValidationFailureClass(sourceName, failureMessage);
}

/**
 * Class implementation
 */
function ValidationFailureClass(sourceName, failureMessage)
{
 	cTypeEnforcer.checkString(sourceName, "ValidationFailure", "constructor",
 							  "sourceName");
	cTypeEnforcer.checkString(failureMessage, "ValidationFailure", 
							  "constructor", "failureMessage", true);

	this.className = "ValidationFailure";

    this.failureMessages = new Array(); //Strings
    this.nestedFailures = new Array(); //ValidationFailures;
    this.nestedFailureMap = {}; //ValidationFailures keyed on name + index;
	this.sourceIndex = -1; //Number
	this.sourceName = sourceName; //String
	
	if (failureMessage != undefined)
	{
		this.failureMessages.push(failureMessage);
	}

	/**
	 * Adds a localized validation failure message (reason this validation
	 * failed) to the collection.
	 * @param aString a String containing a localized validation failure
	 *		  message. A null or undefined value is ignored.
	 * @throws an UnexpectedDataType Exception if aString isn't a String.
	 */
	this.addFailureMessage = function(aString)
	{
		if (aString != null)
		{
			cTypeEnforcer.checkString(aString, "ValidationFailure", 
									  "addFailureMessage", "aString");
			this.failureMessages.push(aString);
		}
	}

	/**
	 * Gets an Array of localized validation failure messages (reasons this
	 * validation failed) for the named source object.
	 * @return a String Array containing localized validation failure messages.
	 */
	this.getFailureMessages = function()
	{
		return this.failureMessages;
	}

	/**
	 * Gets whether there are any localized validation failure messages (reasons
	 * this validation failed) for the named source object.
	 * @return a boolean true if there are any localized validation failure
	 *         messages for the named source object.
	 */
	this.hasFailureMessages = function()
	{
		return this.getFailureMessages().length &gt; 0;
	}

	/**
	 * Adds a ValidationFailure for a nested object to the Array. Note that
	 * only one nested ValidationFailure with the same name and index is
	 * supported. Attempting to add another with the same name and index as an
	 * existing one will cause its error messages to be merged into those of
	 * the existing one.
	 * @param aValidationFailure a ValidationFailure representing the failures
	 *        that a particular nested object had. A null or undefined value is
	 *		  ignored.
	 * @throws an UnexpectedDataType Exception if aValidationFailure isn't a
	 *		   ValidationFailure.
	 */
	this.addNestedValidationFailure = function(aValidationFailure)
	{
		if (aValidationFailure != null)
		{
			cTypeEnforcer.checkSpecificCustomObject(aValidationFailure,
				"ValidationFailure", "addNestedValidationFailure",
				"aValidationFailure", "ValidationFailure");

			var failureKey = aValidationFailure.getSourceName() + "_" 
							 + aValidationFailure.getSourceIndex();				 
			
			//var existingNestedFailure = this.nestedFailureMap[failureKey];		
			var existingNestedFailure = null; //dkilty added to get duplicates
			if (existingNestedFailure == null)
			{
				this.nestedFailures.push(aValidationFailure);
				this.nestedFailureMap[failureKey] = aValidationFailure;
			}
			else
			{
				for (var i=0; 
					 i &lt; aValidationFailure.getFailureMessages().length;
					 i++)
				{
						existingNestedFailure.addFailureMessage(
						aValidationFailure.getFailureMessages()[i]);
				}
			}
		}
	}

	/**
	 * Gets an Array of ValidationFailures for nested objects.
	 * @return an Array of ValidationFailures for nested objects.
	 */
	this.getNestedValidationFailures = function()
	{
		return this.nestedFailures;
	}

	/**
	 * Gets whether there are any ValidationFailures for nested objects.
	 * @return true if there are any ValidationFailures for nested objects.
	 */
	this.hasNestedValidationFailures = function()
	{
		return this.nestedFailures.length &gt; 0;
	}
	
	/**
	 * Gets the index of the object that had the validation failure. Only used
	 * when that object is part of a collection.
	 * @return a Number containing the index of the object that had the
	 *		   validation failure. -1 if this is not applicable. Defaults to -1.
	 */
	this.getSourceIndex = function()
	{
		return this.sourceIndex;
	}
	
	/**
	 * Sets the index of the object that had the validation failure. Only used
	 * when that object is part of a collection.
	 * @param aNumber a Number containing the index of the object that had the
	 *		   validation failure. Defaults to -1.
	 * @throws an UnexpectedDataType Exception if aNumber isn't a Number.
	 */
	this.setSourceIndex = function(aNumber)
	{
 		cTypeEnforcer.checkNumber(aNumber, "ValidationFailure",
 								  "setSourceIndex", "aNumber");
		this.sourceIndex = aNumber;
	}
	
	/**
	 * Gets the name of the object that had the validation failure.
	 * @return a String containing the name of the object that had the
	 *		   validation failure.
	 */
	this.getSourceName = function()
	{
		return this.sourceName;
	}

	/**
	 * Gets whether there were any failures (failure messages or nested
	 * validation failures).
	 * @return a Boolean - true if there were any validation failures by the
	 *         source object, its fields, or its nested objects.
	 */
	this.hasAnyValidationFailures = function()
	{
		return this.hasFailureMessages() || this.hasNestedValidationFailures();
	}

    /**
     * Describes this object. This is implemented in all objects since their
     * toString() cannot be overridden!
     * @return the description of this object.
     */
    this.asString = function()
	{
		var buffer = this.className + "[";

		buffer += "sourceName = " + this.sourceName;
		if (this.sourceIndex != -1)
		{
			buffer += ", sourceIndex = " + this.sourceIndex;
		}
		buffer += ", failureMessages = " + this.failureMessages;

		if (this.hasNestedValidationFailures()) {
			buffer += ", \nnestedFailures:\n";
			for (var i=0; i &lt; this.nestedFailures.length; i++)
			{
				buffer += this.nestedFailures[i].asString() + "\n";
			}
		}
		buffer += "]";
		return buffer;
	}
}
</script>
               <?templateDesigner expand 1?></variables>
            <bind match="none"/>
            <?templateDesigner expand 1?></subform>
         <?templateDesigner isFragment yes?>
         <?templateDesigner fragmentTitle Core JavaScript?>
         <?templateDesigner fragmentDescription This fragment contains a library of reusable JavaScript code.?>
         <subform w="100mm" h="50mm" name="zip">
            <variables>
               <script contentType="application/x-javascript" name="DeflateCompressor">//
/*******************************************************************************
 * A class that compresses data based on the Deflate algorithm. This is the most
 * commonly used algorithm for compressing Zip file contents.
 *
 * Port of a script by Masanao Izumo.
 * http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
 * Copyright (C) 1999 Masanao Izumo &lt;iz@onicos.co.jp&gt;
 * Version: 1.0.1
 * LastModified: Dec 25 1999
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

/* constant parameters */
var zip_WSIZE = 32768;		// Sliding Window size
var zip_STORED_BLOCK = 0;
var zip_STATIC_TREES = 1;
var zip_DYN_TREES    = 2;

/* for deflate */
var zip_Buf_size = 16; // bit size of bi_buf
var zip_DEFAULT_LEVEL = 6;
var zip_FULL_SEARCH = true;
var zip_INBUFSIZ = 32768;	// Input buffer size
var zip_INBUF_EXTRA = 64;	// Extra buffer
var zip_OUTBUFSIZ = 1024 * 8;
var zip_window_size = 2 * zip_WSIZE;
var zip_MIN_MATCH = 3;
var zip_MAX_MATCH = 258;
var zip_BITS = 16;
// for SMALL_MEM
var zip_LIT_BUFSIZE = 0x2000;
var zip_HASH_BITS = 13;
// for MEDIUM_MEM
// var zip_LIT_BUFSIZE = 0x4000;
// var zip_HASH_BITS = 14;
// for BIG_MEM
// var zip_LIT_BUFSIZE = 0x8000;
// var zip_HASH_BITS = 15;
if(zip_LIT_BUFSIZE &gt; zip_INBUFSIZ)
    alert("error: zip_INBUFSIZ is too small");
if((zip_WSIZE&lt;&lt;1) &gt; (1&lt;&lt;zip_BITS))
    alert("error: zip_WSIZE is too large");
if(zip_HASH_BITS &gt; zip_BITS-1)
    alert("error: zip_HASH_BITS is too large");
if(zip_HASH_BITS &lt; 8 || zip_MAX_MATCH != 258)
    alert("error: Code too clever");
var zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;
var zip_HASH_SIZE = 1 &lt;&lt; zip_HASH_BITS;
var zip_HASH_MASK = zip_HASH_SIZE - 1;
var zip_WMASK = zip_WSIZE - 1;
var zip_NIL = 0; // Tail of hash chains
var zip_TOO_FAR = 4096;
var zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;
var zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;
var zip_SMALLEST = 1;
var zip_MAX_BITS = 15;
var zip_MAX_BL_BITS = 7;
var zip_LENGTH_CODES = 29;
var zip_LITERALS =256;
var zip_END_BLOCK = 256;
var zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;
var zip_D_CODES = 30;
var zip_BL_CODES = 19;
var zip_REP_3_6 = 16;
var zip_REPZ_3_10 = 17;
var zip_REPZ_11_138 = 18;
var zip_HEAP_SIZE = 2 * zip_L_CODES + 1;
var zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /
			   zip_MIN_MATCH);

/* objects (deflate) */
var zip_DeflateCT = function()
{
    this.fc = 0; // frequency count or bit string
    this.dl = 0; // father node in Huffman tree or length of bit string
}

var zip_DeflateTreeDesc = function()
{
    this.dyn_tree = null;	// the dynamic tree
    this.static_tree = null;	// corresponding static tree or NULL
    this.extra_bits = null;	// extra bits for each code or NULL
    this.extra_base = 0;	// base index for extra_bits
    this.elems = 0;		// max number of elements in the tree
    this.max_length = 0;	// max bit length for the codes
    this.max_code = 0;		// largest code with non zero frequency
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
var zip_DeflateConfiguration = function(a, b, c, d)
{
    this.good_length = a; // reduce lazy search above this match length
    this.max_lazy = b;    // do not perform lazy search above this match length
    this.nice_length = c; // quit search above this match length
    this.max_chain = d;
}

var zip_DeflateBuffer = function()
{
    this.next = null;
    this.len = 0;
    this.ptr = new Array(zip_OUTBUFSIZ);
    this.off = 0;
}

/* constant tables */
var zip_extra_lbits = new Array(
    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0);
var zip_extra_dbits = new Array(
    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13);
var zip_extra_blbits = new Array(
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7);
var zip_bl_order = new Array(
    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);
var zip_configuration_table = new Array(
	new zip_DeflateConfiguration(0,    0,   0,    0),
	new zip_DeflateConfiguration(4,    4,   8,    4),
	new zip_DeflateConfiguration(4,    5,  16,    8),
	new zip_DeflateConfiguration(4,    6,  32,   32),
	new zip_DeflateConfiguration(4,    4,  16,   16),
	new zip_DeflateConfiguration(8,   16,  32,   32),
	new zip_DeflateConfiguration(8,   16, 128,  128),
	new zip_DeflateConfiguration(8,   32, 128,  256),
	new zip_DeflateConfiguration(32, 128, 258, 1024),
	new zip_DeflateConfiguration(32, 258, 258, 4096));

/* variables */
var zip_free_queue;
var zip_qhead;
var zip_qtail;
var zip_initflag;
var zip_outbuf = null;
var zip_outcnt;
var zip_outoff;
var zip_complete;
var zip_window;
var zip_d_buf;
var zip_l_buf;
var zip_prev;
var zip_bi_buf;
var zip_bi_valid;
var zip_block_start;
var zip_ins_h;
var zip_hash_head;
var zip_prev_match;
var zip_match_available;
var zip_match_length;
var zip_prev_length;
var zip_strstart;
var zip_match_start;
var zip_eofile;
var zip_lookahead;
var zip_max_chain_length;
var zip_max_lazy_match;
var zip_compr_level;
var zip_good_match;
var zip_nice_match;
var zip_dyn_ltree;
var zip_dyn_dtree;
var zip_static_ltree;
var zip_static_dtree;
var zip_bl_tree;
var zip_l_desc;
var zip_d_desc;
var zip_bl_desc;
var zip_bl_count;
var zip_heap;
var zip_heap_len;
var zip_heap_max;
var zip_depth;
var zip_length_code;
var zip_dist_code;
var zip_base_length;
var zip_base_dist;
var zip_flag_buf;
var zip_last_lit;
var zip_last_dist;
var zip_last_flags;
var zip_flags;
var zip_flag_bit;
var zip_opt_len;
var zip_static_len;
var zip_deflate_data;
var zip_deflate_pos;

/**
 * Compresses the passed byte array.
 * @param byteArray a String that contains the byte array that is to be
 *		  compressed.
 * @param level(optional) a Number that indicates the level of compression. This
 *		  should be between 1 and 9, where 1 is minimal compression and 9 is the
 *		  maximum capability of the reference implementation. Note that this
 *		  governs the amount of time spent looking for matching strings (i.e
 *		  selects from a sliding scale of compression-level vs. speed of
 *		  encoding). Default is 6.
 * @return a String that contains the compressed byte array.
 * @throws an UnexpectedDataType Exception if byteArray is undefined, null, or
 *		   not a string or if level is not a number.
 */
function compress(byteArray, level)
{
	cTypeEnforcer.checkString(byteArray, "DeflateCompressor", "compress",
							  "byteArray");
	cTypeEnforcer.checkNumber(level, "DeflateCompressor", "compress", "level",
							  true);

    var i, j;

    zip_deflate_data = byteArray;
    zip_deflate_pos = 0;
	if(typeof level == "undefined")
		level = zip_DEFAULT_LEVEL;
    zip_deflate_start(level);

    var buff = new Array(1024);
    var aout = [];
    while((i = zip_deflate_internal(buff, 0, buff.length)) &gt; 0) {
	var cbuf = new Array(i);
	for(j = 0; j &lt; i; j++){
	    cbuf[j] = String.fromCharCode(buff[j]);
	}
	aout[aout.length] = cbuf.join("");
    }
    zip_deflate_data = null; // G.C.
    return aout.join("");
}

//===== PRIVATE ================================================================
function zip_deflate_start(level)
{
    var i;

    if(!level)
	level = zip_DEFAULT_LEVEL;
    else if(level &lt; 1)
	level = 1;
    else if(level &gt; 9)
	level = 9;

    zip_compr_level = level;
    zip_initflag = false;
    zip_eofile = false;
    if(zip_outbuf != null)
	return;

    zip_free_queue = zip_qhead = zip_qtail = null;
    zip_outbuf = new Array(zip_OUTBUFSIZ);
    zip_window = new Array(zip_window_size);
    zip_d_buf = new Array(zip_DIST_BUFSIZE);
    zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);
    zip_prev = new Array(1 &lt;&lt; zip_BITS);
    zip_dyn_ltree = new Array(zip_HEAP_SIZE);
    for(i = 0; i &lt; zip_HEAP_SIZE; i++)
	zip_dyn_ltree[i] = new zip_DeflateCT();
    zip_dyn_dtree = new Array(2*zip_D_CODES+1);
    for(i = 0; i &lt; 2*zip_D_CODES+1; i++)
	zip_dyn_dtree[i] = new zip_DeflateCT();
    zip_static_ltree = new Array(zip_L_CODES+2);
    for(i = 0; i &lt; zip_L_CODES+2; i++)
	zip_static_ltree[i] = new zip_DeflateCT();
    zip_static_dtree = new Array(zip_D_CODES);
    for(i = 0; i &lt; zip_D_CODES; i++)
	zip_static_dtree[i] = new zip_DeflateCT();
    zip_bl_tree = new Array(2*zip_BL_CODES+1);
    for(i = 0; i &lt; 2*zip_BL_CODES+1; i++)
	zip_bl_tree[i] = new zip_DeflateCT();
    zip_l_desc = new zip_DeflateTreeDesc();
    zip_d_desc = new zip_DeflateTreeDesc();
    zip_bl_desc = new zip_DeflateTreeDesc();
    zip_bl_count = new Array(zip_MAX_BITS+1);
    zip_heap = new Array(2*zip_L_CODES+1);
    zip_depth = new Array(2*zip_L_CODES+1);
    zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);
    zip_dist_code = new Array(512);
    zip_base_length = new Array(zip_LENGTH_CODES);
    zip_base_dist = new Array(zip_D_CODES);
    zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));
}

function zip_deflate_end()
{
    zip_free_queue = zip_qhead = zip_qtail = null;
    zip_outbuf = null;
    zip_window = null;
    zip_d_buf = null;
    zip_l_buf = null;
    zip_prev = null;
    zip_dyn_ltree = null;
    zip_dyn_dtree = null;
    zip_static_ltree = null;
    zip_static_dtree = null;
    zip_bl_tree = null;
    zip_l_desc = null;
    zip_d_desc = null;
    zip_bl_desc = null;
    zip_bl_count = null;
    zip_heap = null;
    zip_depth = null;
    zip_length_code = null;
    zip_dist_code = null;
    zip_base_length = null;
    zip_base_dist = null;
    zip_flag_buf = null;
}

function zip_reuse_queue(p)
{
    p.next = zip_free_queue;
    zip_free_queue = p;
}

function zip_new_queue()
{
    var p;

    if(zip_free_queue != null)
    {
	p = zip_free_queue;
	zip_free_queue = zip_free_queue.next;
    }
    else
	p = new zip_DeflateBuffer();
    p.next = null;
    p.len = p.off = 0;

    return p;
}

function zip_head1(i)
{
    return zip_prev[zip_WSIZE + i];
}

function zip_head2(i, val)
{
    return zip_prev[zip_WSIZE + i] = val;
}

/* put_byte is used for the compressed output, put_ubyte for the
 * uncompressed output. However unlzw() uses window for its
 * suffix table instead of its output buffer, so it does not use put_ubyte
 * (to be cleaned up).
 */
function zip_put_byte(c)
{
    zip_outbuf[zip_outoff + zip_outcnt++] = c;
    if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)
	zip_qoutbuf();
}

/* Output a 16 bit value, lsb first */
function zip_put_short(w)
{
    w &amp;= 0xffff;
    if(zip_outoff + zip_outcnt &lt; zip_OUTBUFSIZ - 2) {
	zip_outbuf[zip_outoff + zip_outcnt++] = (w &amp; 0xff);
	zip_outbuf[zip_outoff + zip_outcnt++] = (w &gt;&gt;&gt; 8);
    } else {
	zip_put_byte(w &amp; 0xff);
	zip_put_byte(w &gt;&gt;&gt; 8);
    }
}

/* ==========================================================================
 * Insert string s in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of s are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
function zip_INSERT_STRING()
{
    zip_ins_h = ((zip_ins_h &lt;&lt; zip_H_SHIFT)
		 ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] &amp; 0xff))
	&amp; zip_HASH_MASK;
    zip_hash_head = zip_head1(zip_ins_h);
    zip_prev[zip_strstart &amp; zip_WMASK] = zip_hash_head;
    zip_head2(zip_ins_h, zip_strstart);
}

/* Send a code of the given tree. c and tree must not have side effects */
function zip_SEND_CODE(c, tree)
{
    zip_send_bits(tree[c].fc, tree[c].dl);
}

/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. dist_code[256] and dist_code[257] are never
 * used.
 */
function zip_D_CODE(dist)
{
    return (dist &lt; 256 ? zip_dist_code[dist]
	    : zip_dist_code[256 + (dist&gt;&gt;7)]) &amp; 0xff;
}

/* ==========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function zip_SMALLER(tree, n, m)
{
    return tree[n].fc &lt; tree[m].fc ||
      (tree[n].fc == tree[m].fc &amp;&amp; zip_depth[n] &lt;= zip_depth[m]);
}

/* ==========================================================================
 * read string data
 */
function zip_read_buff(buff, offset, n)
{
    var i;
    for(i = 0; i &lt; n &amp;&amp; zip_deflate_pos &lt; zip_deflate_data.length; i++)
	buff[offset + i] =
	    zip_deflate_data.charCodeAt(zip_deflate_pos++) &amp; 0xff;
    return i;
}

/* ==========================================================================
 * Initialize the "longest match" routines for a new file
 */
function zip_lm_init()
{
    var j;

    /* Initialize the hash table. */
    for(j = 0; j &lt; zip_HASH_SIZE; j++)
//	zip_head2(j, zip_NIL);
	zip_prev[zip_WSIZE + j] = 0;
    /* prev will be initialized on the fly */

    /* Set the default configuration parameters:
     */
    zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;
    zip_good_match     = zip_configuration_table[zip_compr_level].good_length;
    if(!zip_FULL_SEARCH)
	zip_nice_match = zip_configuration_table[zip_compr_level].nice_length;
    zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;

    zip_strstart = 0;
    zip_block_start = 0;

    zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);
    if(zip_lookahead &lt;= 0) {
	zip_eofile = true;
	zip_lookahead = 0;
	return;
    }
    zip_eofile = false;
    /* Make sure that we always have enough lookahead. This is important
     * if input comes from a device such as a tty.
     */
    while(zip_lookahead &lt; zip_MIN_LOOKAHEAD &amp;&amp; !zip_eofile)
	zip_fill_window();

    /* If lookahead &lt; MIN_MATCH, ins_h is garbage, but this is
     * not important since only literal bytes will be emitted.
     */
    zip_ins_h = 0;
    for(j = 0; j &lt; zip_MIN_MATCH - 1; j++) {
//      UPDATE_HASH(ins_h, window[j]);
	zip_ins_h = ((zip_ins_h &lt;&lt; zip_H_SHIFT) ^ (zip_window[j] &amp; 0xff)) &amp; zip_HASH_MASK;
    }
}

/* ==========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
 */
function zip_longest_match(cur_match)
{
    var chain_length = zip_max_chain_length; // max hash chain length
    var scanp = zip_strstart; // current string
    var matchp;		// matched string
    var len;		// length of current match
    var best_len = zip_prev_length;	// best match length so far

    /* Stop when cur_match becomes &lt;= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    var limit = (zip_strstart &gt; zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);

    var strendp = zip_strstart + zip_MAX_MATCH;
    var scan_end1 = zip_window[scanp + best_len - 1];
    var scan_end  = zip_window[scanp + best_len];

    /* Do not waste too much time if we already have a good match: */
    if(zip_prev_length &gt;= zip_good_match)
	chain_length &gt;&gt;= 2;

//  Assert(encoder-&gt;strstart &lt;= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

    do {
//    Assert(cur_match &lt; encoder-&gt;strstart, "no future");
	matchp = cur_match;

	/* Skip to next match if the match length cannot increase
	    * or if the match length is less than 2:
	*/
	if(zip_window[matchp + best_len]	!= scan_end  ||
	   zip_window[matchp + best_len - 1]	!= scan_end1 ||
	   zip_window[matchp]			!= zip_window[scanp] ||
	   zip_window[++matchp]			!= zip_window[scanp + 1]) {
	    continue;
	}

	/* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS &gt;= 8.
         */
	scanp += 2;
	matchp++;

	/* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
	do {
	} while(zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		zip_window[++scanp] == zip_window[++matchp] &amp;&amp;
		scanp &lt; strendp);

      len = zip_MAX_MATCH - (strendp - scanp);
      scanp = strendp - zip_MAX_MATCH;

      if(len &gt; best_len) {
	  zip_match_start = cur_match;
	  best_len = len;
	  if(zip_FULL_SEARCH) {
	      if(len &gt;= zip_MAX_MATCH) break;
	  } else {
	      if(len &gt;= zip_nice_match) break;
	  }

	  scan_end1  = zip_window[scanp + best_len-1];
	  scan_end   = zip_window[scanp + best_len];
      }
    } while((cur_match = zip_prev[cur_match &amp; zip_WMASK]) &gt; limit
	    &amp;&amp; --chain_length != 0);

    return best_len;
}

/* ==========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead, and sets eofile if end of input file.
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD &amp;&amp; strstart + lookahead &gt; 0
 * OUT assertions: at least one byte has been read, or eofile is set;
 *    file reads are performed for at least two bytes (required for the
 *    translate_eol option).
 */
function zip_fill_window()
{
    var n, m;

    // Amount of free space at the end of the window.
    var more = zip_window_size - zip_lookahead - zip_strstart;

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if(more == -1) {
	/* Very unlikely, but possible on 16 bit machine if strstart == 0
         * and lookahead == 1 (input done one byte at time)
         */
	more--;
    } else if(zip_strstart &gt;= zip_WSIZE + zip_MAX_DIST) {
	/* By the IN assertion, the window is not empty so we can't confuse
         * more == 0 with more == 64K on a 16 bit machine.
         */
//	Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");

//	System.arraycopy(window, WSIZE, window, 0, WSIZE);
	for(n = 0; n &lt; zip_WSIZE; n++)
	    zip_window[n] = zip_window[n + zip_WSIZE];
      
	zip_match_start -= zip_WSIZE;
	zip_strstart    -= zip_WSIZE; /* we now have strstart &gt;= MAX_DIST: */
	zip_block_start -= zip_WSIZE;

	for(n = 0; n &lt; zip_HASH_SIZE; n++) {
	    m = zip_head1(n);
	    zip_head2(n, m &gt;= zip_WSIZE ? m - zip_WSIZE : zip_NIL);
	}
	for(n = 0; n &lt; zip_WSIZE; n++) {
	    /* If n is not on any hash chain, prev[n] is garbage but
	     * its value will never be used.
	     */
	    m = zip_prev[n];
	    zip_prev[n] = (m &gt;= zip_WSIZE ? m - zip_WSIZE : zip_NIL);
	}
	more += zip_WSIZE;
    }
    // At this point, more &gt;= 2
    if(!zip_eofile) {
	n = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);
	if(n &lt;= 0)
	    zip_eofile = true;
	else
	    zip_lookahead += n;
    }
}

/* ==========================================================================
 * Processes a new input file and return its compressed length. This
 * function does not perform lazy evaluationof matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function zip_deflate_fast()
{
    while(zip_lookahead != 0 &amp;&amp; zip_qhead == null) {
	var flush; // set if current block must be flushed

	/* Insert the string window[strstart .. strstart+2] in the
	 * dictionary, and set hash_head to the head of the hash chain:
	 */
	zip_INSERT_STRING();

	/* Find the longest match, discarding those &lt;= prev_length.
	 * At this point we have always match_length &lt; MIN_MATCH
	 */
	if(zip_hash_head != zip_NIL &amp;&amp;
	   zip_strstart - zip_hash_head &lt;= zip_MAX_DIST) {
	    /* To simplify the code, we prevent matches with the string
	     * of window index 0 (in particular we have to avoid a match
	     * of the string with itself at the start of the input file).
	     */
	    zip_match_length = zip_longest_match(zip_hash_head);
	    /* longest_match() sets match_start */
	    if(zip_match_length &gt; zip_lookahead)
		zip_match_length = zip_lookahead;
	}
	if(zip_match_length &gt;= zip_MIN_MATCH) {
//	    check_match(strstart, match_start, match_length);

	    flush = zip_ct_tally(zip_strstart - zip_match_start,
				 zip_match_length - zip_MIN_MATCH);
	    zip_lookahead -= zip_match_length;

	    /* Insert new strings in the hash table only if the match length
	     * is not too large. This saves time but degrades compression.
	     */
	    if(zip_match_length &lt;= zip_max_lazy_match) {
		zip_match_length--; // string at strstart already in hash table
		do {
		    zip_strstart++;
		    zip_INSERT_STRING();
		    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
		     * always MIN_MATCH bytes ahead. If lookahead &lt; MIN_MATCH
		     * these bytes are garbage, but it does not matter since
		     * the next lookahead bytes will be emitted as literals.
		     */
		} while(--zip_match_length != 0);
		zip_strstart++;
	    } else {
		zip_strstart += zip_match_length;
		zip_match_length = 0;
		zip_ins_h = zip_window[zip_strstart] &amp; 0xff;
//		UPDATE_HASH(ins_h, window[strstart + 1]);
		zip_ins_h = ((zip_ins_h&lt;&lt;zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] &amp; 0xff)) &amp; zip_HASH_MASK;

//#if MIN_MATCH != 3
//		Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif

	    }
	} else {
	    /* No match, output a literal byte */
	    flush = zip_ct_tally(0, zip_window[zip_strstart] &amp; 0xff);
	    zip_lookahead--;
	    zip_strstart++;
	}
	if(flush) {
	    zip_flush_block(0);
	    zip_block_start = zip_strstart;
	}

	/* Make sure that we always have enough lookahead, except
	 * at the end of the input file. We need MAX_MATCH bytes
	 * for the next match, plus MIN_MATCH bytes to insert the
	 * string following the next match.
	 */
	while(zip_lookahead &lt; zip_MIN_LOOKAHEAD &amp;&amp; !zip_eofile)
	    zip_fill_window();
    }
}

function zip_deflate_better()
{
    /* Process the input block. */
    while(zip_lookahead != 0 &amp;&amp; zip_qhead == null) {
	/* Insert the string window[strstart .. strstart+2] in the
	 * dictionary, and set hash_head to the head of the hash chain:
	 */
	zip_INSERT_STRING();

	/* Find the longest match, discarding those &lt;= prev_length.
	 */
	zip_prev_length = zip_match_length;
	zip_prev_match = zip_match_start;
	zip_match_length = zip_MIN_MATCH - 1;

	if(zip_hash_head != zip_NIL &amp;&amp;
	   zip_prev_length &lt; zip_max_lazy_match &amp;&amp;
	   zip_strstart - zip_hash_head &lt;= zip_MAX_DIST) {
	    /* To simplify the code, we prevent matches with the string
	     * of window index 0 (in particular we have to avoid a match
	     * of the string with itself at the start of the input file).
	     */
	    zip_match_length = zip_longest_match(zip_hash_head);
	    /* longest_match() sets match_start */
	    if(zip_match_length &gt; zip_lookahead)
		zip_match_length = zip_lookahead;

	    /* Ignore a length 3 match if it is too distant: */
	    if(zip_match_length == zip_MIN_MATCH &amp;&amp;
	       zip_strstart - zip_match_start &gt; zip_TOO_FAR) {
		/* If prev_match is also MIN_MATCH, match_start is garbage
		 * but we will ignore the current match anyway.
		 */
		zip_match_length--;
	    }
	}
	/* If there was a match at the previous step and the current
	 * match is not better, output the previous match:
	 */
	if(zip_prev_length &gt;= zip_MIN_MATCH &amp;&amp;
	   zip_match_length &lt;= zip_prev_length) {
	    var flush; // set if current block must be flushed

//	    check_match(strstart - 1, prev_match, prev_length);
	    flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,
				 zip_prev_length - zip_MIN_MATCH);

	    /* Insert in hash table all strings up to the end of the match.
	     * strstart-1 and strstart are already inserted.
	     */
	    zip_lookahead -= zip_prev_length - 1;
	    zip_prev_length -= 2;
	    do {
		zip_strstart++;
		zip_INSERT_STRING();
		/* strstart never exceeds WSIZE-MAX_MATCH, so there are
		 * always MIN_MATCH bytes ahead. If lookahead &lt; MIN_MATCH
		 * these bytes are garbage, but it does not matter since the
		 * next lookahead bytes will always be emitted as literals.
		 */
	    } while(--zip_prev_length != 0);
	    zip_match_available = 0;
	    zip_match_length = zip_MIN_MATCH - 1;
	    zip_strstart++;
	    if(flush) {
		zip_flush_block(0);
		zip_block_start = zip_strstart;
	    }
	} else if(zip_match_available != 0) {
	    /* If there was no match at the previous position, output a
	     * single literal. If there was a match but the current match
	     * is longer, truncate the previous match to a single literal.
	     */
	    if(zip_ct_tally(0, zip_window[zip_strstart - 1] &amp; 0xff)) {
		zip_flush_block(0);
		zip_block_start = zip_strstart;
	    }
	    zip_strstart++;
	    zip_lookahead--;
	} else {
	    /* There is no previous match to compare with, wait for
	     * the next step to decide.
	     */
	    zip_match_available = 1;
	    zip_strstart++;
	    zip_lookahead--;
	}

	/* Make sure that we always have enough lookahead, except
	 * at the end of the input file. We need MAX_MATCH bytes
	 * for the next match, plus MIN_MATCH bytes to insert the
	 * string following the next match.
	 */
	while(zip_lookahead &lt; zip_MIN_LOOKAHEAD &amp;&amp; !zip_eofile)
	    zip_fill_window();
    }
}

function zip_init_deflate()
{
    if(zip_eofile)
	return;
    zip_bi_buf = 0;
    zip_bi_valid = 0;
    zip_ct_init();
    zip_lm_init();

    zip_qhead = null;
    zip_outcnt = 0;
    zip_outoff = 0;

    if(zip_compr_level &lt;= 3)
    {
	zip_prev_length = zip_MIN_MATCH - 1;
	zip_match_length = 0;
    }
    else
    {
	zip_match_length = zip_MIN_MATCH - 1;
	zip_match_available = 0;
    }

    zip_complete = false;
}

/* ==========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function zip_deflate_internal(buff, off, buff_size)
{
    var n;

    if(!zip_initflag)
    {
	zip_init_deflate();
	zip_initflag = true;
	if(zip_lookahead == 0) { // empty
	    zip_complete = true;
	    return 0;
	}
    }

    if((n = zip_qcopy(buff, off, buff_size)) == buff_size)
	return buff_size;

    if(zip_complete)
	return n;

    if(zip_compr_level &lt;= 3) // optimized for speed
	zip_deflate_fast();
    else
	zip_deflate_better();
    if(zip_lookahead == 0) {
	if(zip_match_available != 0)
	    zip_ct_tally(0, zip_window[zip_strstart - 1] &amp; 0xff);
	zip_flush_block(1);
	zip_complete = true;
    }
    return n + zip_qcopy(buff, n + off, buff_size - n);
}

function zip_qcopy(buff, off, buff_size)
{
    var n, i, j;

    n = 0;
    while(zip_qhead != null &amp;&amp; n &lt; buff_size)
    {
	i = buff_size - n;
	if(i &gt; zip_qhead.len)
	    i = zip_qhead.len;
//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
	for(j = 0; j &lt; i; j++)
	    buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];
	
	zip_qhead.off += i;
	zip_qhead.len -= i;
	n += i;
	if(zip_qhead.len == 0) {
	    var p;
	    p = zip_qhead;
	    zip_qhead = zip_qhead.next;
	    zip_reuse_queue(p);
	}
    }

    if(n == buff_size)
	return n;

    if(zip_outoff &lt; zip_outcnt) {
	i = buff_size - n;
	if(i &gt; zip_outcnt - zip_outoff)
	    i = zip_outcnt - zip_outoff;
	// System.arraycopy(outbuf, outoff, buff, off + n, i);
	for(j = 0; j &lt; i; j++)
	    buff[off + n + j] = zip_outbuf[zip_outoff + j];
	zip_outoff += i;
	n += i;
	if(zip_outcnt == zip_outoff)
	    zip_outcnt = zip_outoff = 0;
    }
    return n;
}

/* ==========================================================================
 * Allocate the match buffer, initialize the various tables and save the
 * location of the internal file attribute (ascii/binary) and method
 * (DEFLATE/STORE).
 */
function zip_ct_init()
{
    var n;	// iterates over tree elements
    var bits;	// bit counter
    var length;	// length value
    var code;	// code value
    var dist;	// distance index

    if(zip_static_dtree[0].dl != 0) return; // ct_init already called

    zip_l_desc.dyn_tree		= zip_dyn_ltree;
    zip_l_desc.static_tree	= zip_static_ltree;
    zip_l_desc.extra_bits	= zip_extra_lbits;
    zip_l_desc.extra_base	= zip_LITERALS + 1;
    zip_l_desc.elems		= zip_L_CODES;
    zip_l_desc.max_length	= zip_MAX_BITS;
    zip_l_desc.max_code		= 0;

    zip_d_desc.dyn_tree		= zip_dyn_dtree;
    zip_d_desc.static_tree	= zip_static_dtree;
    zip_d_desc.extra_bits	= zip_extra_dbits;
    zip_d_desc.extra_base	= 0;
    zip_d_desc.elems		= zip_D_CODES;
    zip_d_desc.max_length	= zip_MAX_BITS;
    zip_d_desc.max_code		= 0;

    zip_bl_desc.dyn_tree	= zip_bl_tree;
    zip_bl_desc.static_tree	= null;
    zip_bl_desc.extra_bits	= zip_extra_blbits;
    zip_bl_desc.extra_base	= 0;
    zip_bl_desc.elems		= zip_BL_CODES;
    zip_bl_desc.max_length	= zip_MAX_BL_BITS;
    zip_bl_desc.max_code	= 0;

    // Initialize the mapping length (0..255) -&gt; length code (0..28)
    length = 0;
    for(code = 0; code &lt; zip_LENGTH_CODES-1; code++) {
	zip_base_length[code] = length;
	for(n = 0; n &lt; (1&lt;&lt;zip_extra_lbits[code]); n++)
	    zip_length_code[length++] = code;
    }
    // Assert (length == 256, "ct_init: length != 256");

    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    zip_length_code[length-1] = code;

    /* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */
    dist = 0;
    for(code = 0 ; code &lt; 16; code++) {
	zip_base_dist[code] = dist;
	for(n = 0; n &lt; (1&lt;&lt;zip_extra_dbits[code]); n++) {
	    zip_dist_code[dist++] = code;
	}
    }
    // Assert (dist == 256, "ct_init: dist != 256");
    dist &gt;&gt;= 7; // from now on, all distances are divided by 128
    for( ; code &lt; zip_D_CODES; code++) {
	zip_base_dist[code] = dist &lt;&lt; 7;
	for(n = 0; n &lt; (1&lt;&lt;(zip_extra_dbits[code]-7)); n++)
	    zip_dist_code[256 + dist++] = code;
    }
    // Assert (dist == 256, "ct_init: 256+dist != 512");

    // Construct the codes of the static literal tree
    for(bits = 0; bits &lt;= zip_MAX_BITS; bits++)
	zip_bl_count[bits] = 0;
    n = 0;
    while(n &lt;= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }
    while(n &lt;= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }
    while(n &lt;= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }
    while(n &lt;= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);

    /* The static distance tree is trivial: */
    for(n = 0; n &lt; zip_D_CODES; n++) {
	zip_static_dtree[n].dl = 5;
	zip_static_dtree[n].fc = zip_bi_reverse(n, 5);
    }

    // Initialize the first block of the first file:
    zip_init_block();
}

/* ==========================================================================
 * Initialize a new block.
 */
function zip_init_block()
{
    var n; // iterates over tree elements

    // Initialize the trees.
    for(n = 0; n &lt; zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;
    for(n = 0; n &lt; zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;
    for(n = 0; n &lt; zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;

    zip_dyn_ltree[zip_END_BLOCK].fc = 1;
    zip_opt_len = zip_static_len = 0;
    zip_last_lit = zip_last_dist = zip_last_flags = 0;
    zip_flags = 0;
    zip_flag_bit = 1;
}

/* ==========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function zip_pqdownheap(tree,	// the tree to restore
						k)	// node to move down
{
    var v = zip_heap[k];
    var j = k &lt;&lt; 1;	// left son of k

    while(j &lt;= zip_heap_len) {
	// Set j to the smallest of the two sons:
	if(j &lt; zip_heap_len &amp;&amp;
	   zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))
	    j++;

	// Exit if v is smaller than both sons
	if(zip_SMALLER(tree, v, zip_heap[j]))
	    break;

	// Exchange v with the smallest son
	zip_heap[k] = zip_heap[j];
	k = j;

	// And continue down the tree, setting j to the left son of k
	j &lt;&lt;= 1;
    }
    zip_heap[k] = v;
}

/* ==========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function zip_gen_bitlen(desc)
{ // the tree descriptor
    var tree		= desc.dyn_tree;
    var extra		= desc.extra_bits;
    var base		= desc.extra_base;
    var max_code	= desc.max_code;
    var max_length	= desc.max_length;
    var stree		= desc.static_tree;
    var h;		// heap index
    var n, m;		// iterate over the tree elements
    var bits;		// bit length
    var xbits;		// extra bits
    var f;		// frequency
    var overflow = 0;	// number of elements with bit length too large

    for(bits = 0; bits &lt;= zip_MAX_BITS; bits++)
	zip_bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap

    for(h = zip_heap_max + 1; h &lt; zip_HEAP_SIZE; h++) {
	n = zip_heap[h];
	bits = tree[tree[n].dl].dl + 1;
	if(bits &gt; max_length) {
	    bits = max_length;
	    overflow++;
	}
	tree[n].dl = bits;
	// We overwrite tree[n].dl which is no longer needed

	if(n &gt; max_code)
	    continue; // not a leaf node

	zip_bl_count[bits]++;
	xbits = 0;
	if(n &gt;= base)
	    xbits = extra[n - base];
	f = tree[n].fc;
	zip_opt_len += f * (bits + xbits);
	if(stree != null)
	    zip_static_len += f * (stree[n].dl + xbits);
    }
    if(overflow == 0)
	return;

    // This happens for example on obj2 and pic of the Calgary corpus

    // Find the first bit length which could increase:
    do {
	bits = max_length - 1;
	while(zip_bl_count[bits] == 0)
	    bits--;
	zip_bl_count[bits]--;		// move one leaf down the tree
	zip_bl_count[bits + 1] += 2;	// move one overflow item as its brother
	zip_bl_count[max_length]--;
	/* The brother of the overflow item also moves one step up,
	 * but this does not affect bl_count[max_length]
	 */
	overflow -= 2;
    } while(overflow &gt; 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for(bits = max_length; bits != 0; bits--) {
	n = zip_bl_count[bits];
	while(n != 0) {
	    m = zip_heap[--h];
	    if(m &gt; max_code)
		continue;
	    if(tree[m].dl != bits) {
		zip_opt_len += (bits - tree[m].dl) * tree[m].fc;
		tree[m].fc = bits;
	    }
	    n--;
	}
    }
}

  /* ==========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */
function zip_gen_codes(tree,	// the tree to decorate
					   max_code)	// largest code with non zero frequency
{
    var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length
    var code = 0;		// running code value
    var bits;			// bit index
    var n;			// code index

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for(bits = 1; bits &lt;= zip_MAX_BITS; bits++) {
	code = ((code + zip_bl_count[bits-1]) &lt;&lt; 1);
	next_code[bits] = code;
    }

    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
//    Assert (code + encoder-&gt;bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,
//	    "inconsistent bit counts");
//    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for(n = 0; n &lt;= max_code; n++) {
	var len = tree[n].dl;
	if(len == 0)
	    continue;
	// Now reverse the bits
	tree[n].fc = zip_bi_reverse(next_code[len]++, len);

//      Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
//	  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
    }
}

/* ==========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function zip_build_tree(desc)
{ // the tree descriptor
    var tree	= desc.dyn_tree;
    var stree	= desc.static_tree;
    var elems	= desc.elems;
    var n, m;		// iterate over heap elements
    var max_code = -1;	// largest code with non zero frequency
    var node = elems;	// next internal node of the tree

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    zip_heap_len = 0;
    zip_heap_max = zip_HEAP_SIZE;

    for(n = 0; n &lt; elems; n++) {
	if(tree[n].fc != 0) {
	    zip_heap[++zip_heap_len] = max_code = n;
	    zip_depth[n] = 0;
	} else
	    tree[n].dl = 0;
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while(zip_heap_len &lt; 2) {
	var xnew = zip_heap[++zip_heap_len] = (max_code &lt; 2 ? ++max_code : 0);
	tree[xnew].fc = 1;
	zip_depth[xnew] = 0;
	zip_opt_len--;
	if(stree != null)
	    zip_static_len -= stree[xnew].dl;
	// new is 0 or 1 so it does not have extra bits
    }
    desc.max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for(n = zip_heap_len &gt;&gt; 1; n &gt;= 1; n--)
	zip_pqdownheap(tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    do {
	n = zip_heap[zip_SMALLEST];
	zip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];
	zip_pqdownheap(tree, zip_SMALLEST);

	m = zip_heap[zip_SMALLEST];  // m = node of next least frequency

	// keep the nodes sorted by frequency
	zip_heap[--zip_heap_max] = n;
	zip_heap[--zip_heap_max] = m;

	// Create a new node father of n and m
	tree[node].fc = tree[n].fc + tree[m].fc;
//	depth[node] = (char)(MAX(depth[n], depth[m]) + 1);
	if(zip_depth[n] &gt; zip_depth[m] + 1)
	    zip_depth[node] = zip_depth[n];
	else
	    zip_depth[node] = zip_depth[m] + 1;
	tree[n].dl = tree[m].dl = node;

	// and insert the new node in the heap
	zip_heap[zip_SMALLEST] = node++;
	zip_pqdownheap(tree, zip_SMALLEST);

    } while(zip_heap_len &gt;= 2);

    zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    zip_gen_bitlen(desc);

    // The field len is now set, we can generate the bit codes
    zip_gen_codes(tree, max_code);
}

//================================================================&gt;&gt;&gt;&gt;&gt;

/* ==========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree. Updates opt_len to take into account the repeat
 * counts. (The contribution of the bit length codes will be added later
 * during the construction of bl_tree.)
 */
function zip_scan_tree(tree,// the tree to be scanned
		       		   max_code)  // and its largest code of non zero frequency
{
    var n;			// iterates over all tree elements
    var prevlen = -1;		// last emitted length
    var curlen;			// length of current code
    var nextlen = tree[0].dl;	// length of next code
    var count = 0;		// repeat count of the current code
    var max_count = 7;		// max repeat count
    var min_count = 4;		// min repeat count

    if(nextlen == 0) {
	max_count = 138;
	min_count = 3;
    }
    tree[max_code + 1].dl = 0xffff; // guard

    for(n = 0; n &lt;= max_code; n++) {
	curlen = nextlen;
	nextlen = tree[n + 1].dl;
	if(++count &lt; max_count &amp;&amp; curlen == nextlen)
	    continue;
	else if(count &lt; min_count)
	    zip_bl_tree[curlen].fc += count;
	else if(curlen != 0) {
	    if(curlen != prevlen)
		zip_bl_tree[curlen].fc++;
	    zip_bl_tree[zip_REP_3_6].fc++;
	} else if(count &lt;= 10)
	    zip_bl_tree[zip_REPZ_3_10].fc++;
	else
	    zip_bl_tree[zip_REPZ_11_138].fc++;
	count = 0; prevlen = curlen;
	if(nextlen == 0) {
	    max_count = 138;
	    min_count = 3;
	} else if(curlen == nextlen) {
	    max_count = 6;
	    min_count = 3;
	} else {
	    max_count = 7;
	    min_count = 4;
	}
    }
}

  /* ==========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */
function zip_send_tree(tree, // the tree to be scanned
					   max_code) // and its largest code of non zero frequency
{
    var n;			// iterates over all tree elements
    var prevlen = -1;		// last emitted length
    var curlen;			// length of current code
    var nextlen = tree[0].dl;	// length of next code
    var count = 0;		// repeat count of the current code
    var max_count = 7;		// max repeat count
    var min_count = 4;		// min repeat count

    /* tree[max_code+1].dl = -1; */  /* guard already set */
    if(nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }

    for(n = 0; n &lt;= max_code; n++) {
	curlen = nextlen;
	nextlen = tree[n+1].dl;
	if(++count &lt; max_count &amp;&amp; curlen == nextlen) {
	    continue;
	} else if(count &lt; min_count) {
	    do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);
	} else if(curlen != 0) {
	    if(curlen != prevlen) {
		zip_SEND_CODE(curlen, zip_bl_tree);
		count--;
	    }
	    // Assert(count &gt;= 3 &amp;&amp; count &lt;= 6, " 3_6?");
	    zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);
	    zip_send_bits(count - 3, 2);
	} else if(count &lt;= 10) {
	    zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);
	    zip_send_bits(count-3, 3);
	} else {
	    zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);
	    zip_send_bits(count-11, 7);
	}
	count = 0;
	prevlen = curlen;
	if(nextlen == 0) {
	    max_count = 138;
	    min_count = 3;
	} else if(curlen == nextlen) {
	    max_count = 6;
	    min_count = 3;
	} else {
	    max_count = 7;
	    min_count = 4;
	}
    }
}

/* ==========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function zip_build_bl_tree()
{
    var max_blindex;  // index of last bit length code of non zero freq

    // Determine the bit length frequencies for literal and distance trees
    zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);
    zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);

    // Build the bit length tree:
    zip_build_tree(zip_bl_desc);
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for(max_blindex = zip_BL_CODES-1; max_blindex &gt;= 3; max_blindex--) {
	if(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    zip_opt_len += 3*(max_blindex+1) + 5+5+4;
//    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
//	    encoder-&gt;opt_len, encoder-&gt;static_len));

    return max_blindex;
}

/* ==========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
 */
function zip_send_all_trees(lcodes, dcodes, blcodes)
{ // number of codes for each tree
    var rank; // index in bl_order

//    Assert (lcodes &gt;= 257 &amp;&amp; dcodes &gt;= 1 &amp;&amp; blcodes &gt;= 4, "not enough codes");
//    Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,
//	    "too many codes");
//    Tracev((stderr, "\nbl counts: "));
    zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt
    zip_send_bits(dcodes-1,   5);
    zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt
    for(rank = 0; rank &lt; blcodes; rank++) {
//      Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	zip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);
    }

    // send the literal tree
    zip_send_tree(zip_dyn_ltree,lcodes-1);

    // send the distance tree
    zip_send_tree(zip_dyn_dtree,dcodes-1);
}

/* ==========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function zip_flush_block(eof)
{ // true if this is the last block for a file
    var opt_lenb, static_lenb; // opt_len and static_len in bytes
    var max_blindex;	// index of last bit length code of non zero freq
    var stored_len;	// length of input block

    stored_len = zip_strstart - zip_block_start;
    zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items

    // Construct the literal and distance trees
    zip_build_tree(zip_l_desc);
//    Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
//	    encoder-&gt;opt_len, encoder-&gt;static_len));

    zip_build_tree(zip_d_desc);
//    Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
//	    encoder-&gt;opt_len, encoder-&gt;static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = zip_build_bl_tree();

    // Determine the best encoding. Compute first the block length in bytes
    opt_lenb	= (zip_opt_len   +3+7)&gt;&gt;3;
    static_lenb = (zip_static_len+3+7)&gt;&gt;3;

//    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
//	   opt_lenb, encoder-&gt;opt_len,
//	   static_lenb, encoder-&gt;static_len, stored_len,
//	   encoder-&gt;last_lit, encoder-&gt;last_dist));

    if(static_lenb &lt;= opt_lenb)
	opt_lenb = static_lenb;
    if(stored_len + 4 &lt;= opt_lenb // 4: two words for the lengths
       &amp;&amp; zip_block_start &gt;= 0) {
	var i;

	/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
	 * Otherwise we can't have processed more than WSIZE input bytes since
	 * the last block flush, because compression would have been
	 * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
	 * transform a block into a stored block.
	 */
	zip_send_bits((zip_STORED_BLOCK&lt;&lt;1)+eof, 3);  /* send block type */
	zip_bi_windup();		 /* align on byte boundary */
	zip_put_short(stored_len);
	zip_put_short(~stored_len);

      // copy block
/*
      p = &amp;window[block_start];
      for(i = 0; i &lt; stored_len; i++)
	put_byte(p[i]);
*/
	for(i = 0; i &lt; stored_len; i++)
	    zip_put_byte(zip_window[zip_block_start + i]);

    } else if(static_lenb == opt_lenb) {
	zip_send_bits((zip_STATIC_TREES&lt;&lt;1)+eof, 3);
	zip_compress_block(zip_static_ltree, zip_static_dtree);
    } else {
	zip_send_bits((zip_DYN_TREES&lt;&lt;1)+eof, 3);
	zip_send_all_trees(zip_l_desc.max_code+1,
			   zip_d_desc.max_code+1,
			   max_blindex+1);
	zip_compress_block(zip_dyn_ltree, zip_dyn_dtree);
    }

    zip_init_block();

    if(eof != 0)
	zip_bi_windup();
}

/* ==========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function zip_ct_tally(dist, // distance of matched string
					  lc) // match length-MIN_MATCH or unmatched char (if dist==0)
{
    zip_l_buf[zip_last_lit++] = lc;
    if(dist == 0) {
	// lc is the unmatched char
	zip_dyn_ltree[lc].fc++;
    } else {
	// Here, lc is the match length - MIN_MATCH
	dist--;		    // dist = match distance - 1
//      Assert((ush)dist &lt; (ush)MAX_DIST &amp;&amp;
//	     (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;
//	     (ush)D_CODE(dist) &lt; (ush)D_CODES,  "ct_tally: bad match");

	zip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;
	zip_dyn_dtree[zip_D_CODE(dist)].fc++;

	zip_d_buf[zip_last_dist++] = dist;
	zip_flags |= zip_flag_bit;
    }
    zip_flag_bit &lt;&lt;= 1;

    // Output the flags if they fill a byte
    if((zip_last_lit &amp; 7) == 0) {
	zip_flag_buf[zip_last_flags++] = zip_flags;
	zip_flags = 0;
	zip_flag_bit = 1;
    }
    // Try to guess if it is profitable to stop the current block here
    if(zip_compr_level &gt; 2 &amp;&amp; (zip_last_lit &amp; 0xfff) == 0) {
	// Compute an upper bound for the compressed length
	var out_length = zip_last_lit * 8;
	var in_length = zip_strstart - zip_block_start;
	var dcode;

	for(dcode = 0; dcode &lt; zip_D_CODES; dcode++) {
	    out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);
	}
	out_length &gt;&gt;= 3;
//      Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
//	     encoder-&gt;last_lit, encoder-&gt;last_dist, in_length, out_length,
//	     100L - out_length*100L/in_length));
	if(zip_last_dist &lt; parseInt(zip_last_lit/2) &amp;&amp;
	   out_length &lt; parseInt(in_length/2))
	    return true;
    }
    return (zip_last_lit == zip_LIT_BUFSIZE-1 ||
	    zip_last_dist == zip_DIST_BUFSIZE);
    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

  /* ==========================================================================
   * Send the block data compressed using the given Huffman trees
   */
function zip_compress_block(ltree,	// literal tree
							dtree)	// distance tree
{
    var dist;		// distance of matched string
    var lc;		// match length or unmatched char (if dist == 0)
    var lx = 0;		// running index in l_buf
    var dx = 0;		// running index in d_buf
    var fx = 0;		// running index in flag_buf
    var flag = 0;	// current flags
    var code;		// the code to send
    var extra;		// number of extra bits to send

    if(zip_last_lit != 0) do {
	if((lx &amp; 7) == 0)
	    flag = zip_flag_buf[fx++];
	lc = zip_l_buf[lx++] &amp; 0xff;
	if((flag &amp; 1) == 0) {
	    zip_SEND_CODE(lc, ltree); /* send a literal byte */
//	Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	} else {
	    // Here, lc is the match length - MIN_MATCH
	    code = zip_length_code[lc];
	    zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code
	    extra = zip_extra_lbits[code];
	    if(extra != 0) {
		lc -= zip_base_length[code];
		zip_send_bits(lc, extra); // send the extra length bits
	    }
	    dist = zip_d_buf[dx++];
	    // Here, dist is the match distance - 1
	    code = zip_D_CODE(dist);
//	Assert (code &lt; D_CODES, "bad d_code");

	    zip_SEND_CODE(code, dtree);	  // send the distance code
	    extra = zip_extra_dbits[code];
	    if(extra != 0) {
		dist -= zip_base_dist[code];
		zip_send_bits(dist, extra);   // send the extra distance bits
	    }
	} // literal or match pair ?
	flag &gt;&gt;= 1;
    } while(lx &lt; zip_last_lit);

    zip_SEND_CODE(zip_END_BLOCK, ltree);
}

/* ==========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */
function zip_send_bits(value,	// value to send
					   length)	// number of bits
{
    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if(zip_bi_valid &gt; zip_Buf_size - length) {
	zip_bi_buf |= (value &lt;&lt; zip_bi_valid);
	zip_put_short(zip_bi_buf);
	zip_bi_buf = (value &gt;&gt; (zip_Buf_size - zip_bi_valid));
	zip_bi_valid += length - zip_Buf_size;
    } else {
	zip_bi_buf |= value &lt;&lt; zip_bi_valid;
	zip_bi_valid += length;
    }
}

/* ==========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */
function zip_bi_reverse(code,	// the value to invert
						len)	// its bit length
{
    var res = 0;
    do {
	res |= code &amp; 1;
	code &gt;&gt;= 1;
	res &lt;&lt;= 1;
    } while(--len &gt; 0);
    return res &gt;&gt; 1;
}

/* ==========================================================================
 * Write out any remaining bits in an incomplete byte.
 */
function zip_bi_windup()
{
    if(zip_bi_valid &gt; 8) {
	zip_put_short(zip_bi_buf);
    } else if(zip_bi_valid &gt; 0) {
	zip_put_byte(zip_bi_buf);
    }
    zip_bi_buf = 0;
    zip_bi_valid = 0;
}

function zip_qoutbuf()
{
    if(zip_outcnt != 0) {
	var q, i;
	q = zip_new_queue();
	if(zip_qhead == null)
	    zip_qhead = zip_qtail = q;
	else
	    zip_qtail = zip_qtail.next = q;
	q.len = zip_outcnt - zip_outoff;
//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);
	for(i = 0; i &lt; q.len; i++)
	    q.ptr[i] = zip_outbuf[zip_outoff + i];
	zip_outcnt = zip_outoff = 0;
	}
}
</script>
               <script contentType="application/x-javascript" name="JsZip">//
/*******************************************************************************
 * An object used to generate Zip archives.
 * Create an instance based on the desired compression algorithm (if any), add
 * items to it, then get it to generate a Zip.
 *
 * Based on JSZip &lt;http://jszip.stuartk.co.uk&gt;
 * (c) 2009 Stuart Knightley &lt;stuart [at] stuartk.co.uk&gt;
 * Licenced under the GPLv3 and the MIT licences
 */

//imports
var cBase64Encoder = script.core.encode.Base64Encoder;
var cDeflateCompressor = script.core.zip.DeflateCompressor;
var cException = script.core.util.Exception;
var cLog = script.core.util.Log;
var cLzwCompressor = script.core.zip.LzwCompressor;
var cTypeEnforcer = script.core.util.TypeEnforcer;
var cUtf8Encoder = script.core.encode.Utf8Encoder;

//Available compression types
var DEFLATE = "Deflate"; //Deflate compression
var LZW = "LZW"; 		 //LZW compression
var STORE = "Store";	 //No compression

/**
 * Gets a new JSZip. Adobe does not allow object instances to be created outside
 * of their packaging, so it must be done here.
 * @param compressionName(optional) the desired compression - one of the class
 *		  constants. Defaults to STORE (no compression).
 * @return the new JsZip instance.
 * @throws an UnexpectedDataType Exception if compression is not a string.
 * @throws an IllegalArgument Exception if compression is not a supported Zip
 *		   compression method.
 */
function createInstance(compressionName)
{
	return new JsZipClass(compressionName);
}

/**
 * Class implementation
 */
function JsZipClass(compressionName)
{
	cTypeEnforcer.checkString(compressionName, "JsZip", "constructor",
							 "compressionName", true);

	if (compressionName == undefined)
	{
		compressionName = STORE;
	}
	this.compressions = {
		Deflate : {
			magic : "\x08\x00", //the 2 bytes identifying the compression method
			compress : function (content)
			{
				cLog.trace("using Deflate compress");
				return cDeflateCompressor.compress(content);
			}
		},
		LZW : {
			magic : "\x08\x00", //the 2 bytes identifying the compression method
			compress : function (content)
			{
				cLog.trace("using Lzw compress");
				sData = String.fromCharCode(74) + content;
				return cLzwCompressor.compress(content);
			}
		},
		Store : {
			magic : "\x00\x00",
			compress : function (content)
			{
				return content; // no compression
			}
		}
	};
	this.compression = this.compressions[compressionName];
	if (this.compression == null) {
		throw  cException.createInstance(
			   compressionName + " is not a supported Zip compression method.",
			   "IllegalArgument");
	}
	this.files = [];
	this.root = ""; //Where we are in the hierarchy

	/**
	 * Add a file or directory entry to the zip file.
	 * @param name a String that contains the name of the file.
	 * @param data a String that contains the contents of the file. This may be
	 *		  text or a byte array.
	 * @param dir(optional) a boolean that indicates whether this is a file or a
	 *		  directory. True if this is a directory. Defaults to false.
	 * @param binary(optional) a boolean that indicates whether the file
	 *		  contains binary data or text. Text files will be automatically
	 *		  converted to UTF-8. Defaults to false.
	 * @param date(optional) the last update Date of the file. Defaults to now.
	 */
	this.add = function(name, data, dir, binary, date)
	{
		cTypeEnforcer.checkString(name, "JsZip", "add", "name");
		cTypeEnforcer.checkString(data, "JsZip", "add", "data");
		dir = cTypeEnforcer.checkBoolean(dir, "JsZip", "add", "dir", true);
		binary = cTypeEnforcer.checkBoolean(binary, "JsZip", "add", "binary",
										   true);
		date = cTypeEnforcer.checkDate(date, "JsZip", "add", "date", true);

		var compressedData;
		var dosDate;
		var dosTime;
		var header = "";

		name = this.root + name;
		if(!binary)
		{
			data = cUtf8Encoder.encode(data);
		}	
		compressedData = this.compression.compress(data);
		cLog.trace("compressed from : " + data.length + " to: " + compressedData.length);

		// http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
		dosTime = date.getHours();
		dosTime = dosTime &lt;&lt; 6;
		dosTime = dosTime | date.getMinutes();
		dosTime = dosTime &lt;&lt; 5;
		dosTime = dosTime | date.getSeconds() / 2;
	
		dosDate = date.getFullYear() - 1980;
		dosDate = dosDate &lt;&lt; 4;
		dosDate = dosDate | (date.getMonth() + 1);
		dosDate = dosDate &lt;&lt; 5;
		dosDate = dosDate | date.getDate();

		// version needed to extract
		header += "\x0A\x00";
		// general purpose bit flag
		header += "\x00\x00";
		// compression method
		header += this.compression.magic;
		// last mod file time
		header += this.decToHex(dosTime, 2);
		// last mod file date
		header += this.decToHex(dosDate, 2);
		// crc-32
		header += this.decToHex(this.crc32(data), 4);
		// compressed size
		header += this.decToHex(compressedData.length, 4);
		// uncompressed size
		header += this.decToHex(data.length, 4);
		// file name length
		header += this.decToHex(name.length, 2);
		// extra field length
		header += "\x00\x00";
	
		this.files[name] = {header: header, data: compressedData, dir: dir};
	}

	/**
	 * Generate the complete zip file based on the structures that have been
	 * added.
	 * @param asBytes(optional) a boolean that indicates whether the result
	 *		  should be left in binary form or converted to a Base 64 string. If
	 *		  true, the result will be a byte array. Defaults to false.
	 * @return a String containing a base64 encoded string, or a byte array, of
	 *		   the zip file.
	 */
	this.generate = function(asBytes)
	{
		asBytes = cTypeEnforcer.checkBoolean(asBytes, "JsZip", "generate",
											"asBytes", true);

		var directory = [];
		var dirRecord;
		var fileOffset = 0;
		var fileRecord;
		var files = [];

		for (var name in this.files)
		{
			if(!this.files.hasOwnProperty(name))
			{
				continue;
			}
	
			fileRecord = "\x50\x4b\x03\x04" + this.files[name].header + name
						 + this.files[name].data;
			dirRecord = "\x50\x4b\x01\x02"
						// version made by (00: DOS)
						+ "\x14\x00"
						// file header (common to file and central directory)
						+ this.files[name].header
						// file comment length
						+ "\x00\x00"
						// disk number start
						+ "\x00\x00"
						// internal file attributes TODO
						+ "\x00\x00"
						// external file attributes
						+ (this.files[name].dir===true ? "\x10\x00\x00\x00"
													  : "\x00\x00\x00\x00")
						// relative offset of local header
						+ this.decToHex(fileOffset, 4)
						// file name
						+ name;
			fileOffset += fileRecord.length;
			files.push(fileRecord);
			directory.push(dirRecord);
		}
	
		var fileData = files.join("");
		var dirData = directory.join("");
		var dirEnd = "\x50\x4b\x05\x06" // end of central dir signature
					// number of this disk
					+ "\x00\x00"
					// number of the disk with the start of the central directory
					+ "\x00\x00"
					// total number of entries in the central directory on this disk
					+ this.decToHex(files.length, 2)
					// total number of entries in the central directory
					+ this.decToHex(files.length, 2)
					// size of the central directory   4 bytes
					+ this.decToHex(dirData.length, 4)
					// offset of start of central directory with respect to the starting disk number
					+ this.decToHex(fileData.length, 4)
					// .ZIP file comment length
					+ "\x00\x00";
		var zip = fileData + dirData + dirEnd;

		cLog.trace("zip size: " + zip.length);
		if (asBytes)
		{
			return zip;
		}
		return cBase64Encoder.encode(zip);
	}

	//===== UNSUPPORTED =======================================================
	//The following are public APIs that have not been tested for use here

	/**
	 * Compare a string or regular expression against all of the filenames and
	 * return an informational object for each that matches.
	 * @param   string/regex The regular expression to test against
	 * @return  An array of objects representing the matched files. In the form
	 *          {name: "filename", data: "file data", dir: true/false}
	 */
	this.find = function(needle)
	{
	   var result = [], re;
	   if (typeof needle === "string")
	   {
	      re = new RegExp("^"+needle+"$");
	   }
	   else
	   {
	      re = needle;
	   }
	
	   for (var filename in this.files)
	   {
	      if (re.test(filename))
	      {
	         var file = this.files[filename];
	         result.push({name: filename, data: file.data, dir: !!file.dir});
	      }
	   }
	
	   return result;
	}

	/**
	 * Add a directory to the zip file
	 * @param   name  The name of the directory to add
	 * @return  JSZip object with the new directory as the root
	 */
	this.folder = function(name)
	{
		// Check the name ends with a /
		if (name.substr(-1) != "/")
		{
			name += "/";
		}

		// Does this folder already exist?
		if (typeof this.files[name] === "undefined")
		{
			this.add(name, '', true);
		}

		// Allow chaining by returning a new object with this folder as the root
		var ret = this.clone();

		ret.root = this.root + name;
		return ret;
	}

	/**
	 * Delete a file, or a directory and all sub-files, from the zip
	 * @param   name  the name of the file to delete
	 * @return  this JSZip object
	 */
	this.remove = function(name)
	{
	   var file = this.files[name];
	   if (!file)
	   {
	      // Look for any folders
	      if (name.substr(-1) != "/") name += "/";
	      file = this.files[name];
	   }
	
	   if (file)
	   {
	      if (name.match("/") === null)
	      {
	         // file
	         delete this.files[name];
	      }
	      else
	      {
	         // folder
	         var kids = this.find(new RegExp("^"+name));
	         for (var i = 0; i &lt; kids.length; i++)
	         {
	            if (kids[i].name == name)
	            {
	               // Delete this folder
	               delete this.files[name];
	            }
	            else
	            {
	               // Remove a child of this folder
	               this.remove(kids[i].name);
	            }
	         }
	      }
	   }
	
	   return this;
	}

	//===== PRIVATE ===========================================================
	/**
	 * Inspired by http://my.opera.com/GreyWyvern/blog/show.dml/1725165
	 */
	this.clone = function()
	{
	   var newObj = new JSZip();
	   for (var i in this)
	   {
	      if (typeof this[i] !== "function")
	      {
	         newObj[i] = this[i];
	      }
	   }
	   return newObj;
	}

	/**
	 * Javascript crc32 http://www.webtoolkit.info/
	 */
	this.crc32 = function(str, crc)
	{
	
	   if (str === "") return "\x00\x00\x00\x00";
	
	   var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
	
	   if (typeof(crc) == "undefined") { crc = 0; }
	   var x = 0;
	   var y = 0;
	
	   crc = crc ^ (-1);
	   for( var i = 0, iTop = str.length; i &lt; iTop; i++ ) {
	      y = ( crc ^ str.charCodeAt( i ) ) &amp; 0xFF;
	      x = "0x" + table.substr( y * 9, 8 );
	      crc = ( crc &gt;&gt;&gt; 8 ) ^ x;
	   }
	
	   return crc ^ (-1);
	
	}

	this.decToHex = function(dec, bytes)
	{
	   var hex = "";
	   for(var i=0;i&lt;bytes;i++) {
	      hex += String.fromCharCode(dec&amp;0xff);
	      dec=dec&gt;&gt;&gt;8;
	   }
	   return hex;
	}
}
</script>
               <script contentType="application/x-javascript" name="LzwCompressor">//
/*******************************************************************************
 * A class that compresses data based on the Lempel-Ziv-Welch (LZW) algorithm.
 *
 * source: https://gist.github.com/843889
 */

//imports
var cTypeEnforcer = script.core.util.TypeEnforcer;

/**
 * Compresses the passed byte array.
 * @param byteArray a String that contains the byte array that is to be
 *		  compressed.
 * @return a String that contains the compressed byte array.
 * @throws an UnexpectedDataType Exception if byteArray is undefined, null, or
 *		   not a string.
 */
function compress(byteArray) {
	cTypeEnforcer.checkString(byteArray, "LzwCompressor", "compress",
							  "byteArray");

    var dict = {};
    var data = (byteArray + "").split("");
    var out = [];
    var currChar;
    var phrase = data[0];
    var code = 256;
    for (var i=1; i&lt;data.length; i++) {
        currChar=data[i];
        if (dict[phrase + currChar] != null) {
            phrase += currChar;
        }
        else {
            out.push(phrase.length &gt; 1 ? dict[phrase] : phrase.charCodeAt(0));
            dict[phrase + currChar] = code;
            code++;
            phrase=currChar;
        }
    }
    out.push(phrase.length &gt; 1 ? dict[phrase] : phrase.charCodeAt(0));
    for (var i=0; i&lt;out.length; i++) {
        out[i] = String.fromCharCode(out[i]);
    }
    return out.join("");
}
</script>
               <?templateDesigner expand 1?></variables>
            <bind match="none"/>
            <?templateDesigner expand 0?></subform>
         <?templateDesigner expand 1?></subform>
      <?templateDesigner expand 1?>
   </subform>
   <?originalXFAVersion http://www.xfa.org/schema/xfa-template/3.0/?>
   <?templateDesigner ValidationMessaging noMessages?>
   <?templateDesigner DefaultLanguage JavaScript?>
   <?templateDesigner DefaultRunAt client?>
   <?acrobat JavaScript strictScoping?>
   <?PDFPrintOptions embedViewerPrefs 0?>
   <?PDFPrintOptions embedPrintOnFormOpen 0?>
   <?PDFPrintOptions scalingPrefs 0?>
   <?PDFPrintOptions enforceScalingPrefs 0?>
   <?PDFPrintOptions paperSource 0?>
   <?PDFPrintOptions duplexMode 0?>
   <?templateDesigner DefaultPreviewType interactive?>
   <?templateDesigner DefaultPreviewPagination simplex?>
   <?templateDesigner XDPPreviewFormat 19?>
   <?templateDesigner SaveTaggedPDF 1?>
   <?templateDesigner SavePDFWithEmbeddedFonts 1?>
   <?templateDesigner FormTargetVersion 30?>
   <?templateDesigner Rulers horizontal:1, vertical:1, guidelines:1, crosshairs:0?>
   <?templateDesigner Zoom 114?></template>
<config xmlns="http://www.xfa.org/schema/xci/3.0/">
   <agent name="designer">
      <!--  [0..n]  -->
      <destination>pdf</destination>
      <pdf>
         <!--  [0..n]  -->
         <fontInfo/>
      </pdf>
   </agent>
   <present>
      <!--  [0..n]  -->
      <destination>pdf</destination>
      <pdf>
         <!--  [0..n]  -->
         <fontInfo/>
         <version>1.7</version>
         <adobeExtensionLevel>5</adobeExtensionLevel>
      </pdf>
      <cache>
         <macroCache/>
      </cache>
      <xdp>
         <packets>*</packets>
      </xdp>
   </present>
   <acrobat>
      <common>
         <validationMessaging>noMessages</validationMessaging>
      </common>
   </acrobat>
   <psMap>
      <font typeface="Lucida Fax" psName="LucidaFax-Demi" weight="bold" posture="normal"/>
   </psMap>
</config>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 4.2.1-c041 52.337767, 2008/04/13-15:41:00        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description xmlns:xmp="http://ns.adobe.com/xap/1.0/" rdf:about="">
         <xmp:MetadataDate>2013-06-18T18:39:10Z</xmp:MetadataDate>
         <xmp:CreatorTool>Adobe LiveCycle Designer ES 10.0</xmp:CreatorTool>
      </rdf:Description>
      <rdf:Description xmlns:pdf="http://ns.adobe.com/pdf/1.3/" rdf:about="">
         <pdf:Producer>Adobe LiveCycle Designer ES 10.0</pdf:Producer>
      </rdf:Description>
      <rdf:Description xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" rdf:about="">
         <xmpMM:DocumentID>uuid:100133b1-1e09-443d-b19b-7a7e1a0c152c</xmpMM:DocumentID>
      </rdf:Description>
      <rdf:Description xmlns:lcd="http://ns.adobe.com/livecycle/designer/" xmlns:dc="http://purl.org/dc/elements/1.1/" rdf:about="">
         <lcd:fragmentCatalog>
            <rdf:Seq>
               <rdf:li rdf:parseType="Resource">
                  <dc:title>
                     <rdf:Alt>
                        <rdf:li xml:lang="x-default">Core JavaScript</rdf:li>
                     </rdf:Alt>
                  </dc:title>
                  <dc:description>
                     <rdf:Alt>
                        <rdf:li xml:lang="x-default">This fragment contains a library of reusable JavaScript code.</rdf:li>
                     </rdf:Alt>
                  </dc:description>
                  <dc:identifier>$template.script.core</dc:identifier>
                  <lcd:fragmentRole>Subform</lcd:fragmentRole>
               </rdf:li>
            </rdf:Seq>
         </lcd:fragmentCatalog>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
<localeSet xmlns="http://www.xfa.org/schema/xfa-locale-set/2.7/">
   <locale name="en_CA" desc="English (Canada)">
      <calendarSymbols name="gregorian">
         <monthNames>
            <month>January</month>
            <month>February</month>
            <month>March</month>
            <month>April</month>
            <month>May</month>
            <month>June</month>
            <month>July</month>
            <month>August</month>
            <month>September</month>
            <month>October</month>
            <month>November</month>
            <month>December</month>
         </monthNames>
         <monthNames abbr="1">
            <month>Jan</month>
            <month>Feb</month>
            <month>Mar</month>
            <month>Apr</month>
            <month>May</month>
            <month>Jun</month>
            <month>Jul</month>
            <month>Aug</month>
            <month>Sep</month>
            <month>Oct</month>
            <month>Nov</month>
            <month>Dec</month>
         </monthNames>
         <dayNames>
            <day>Sunday</day>
            <day>Monday</day>
            <day>Tuesday</day>
            <day>Wednesday</day>
            <day>Thursday</day>
            <day>Friday</day>
            <day>Saturday</day>
         </dayNames>
         <dayNames abbr="1">
            <day>Sun</day>
            <day>Mon</day>
            <day>Tue</day>
            <day>Wed</day>
            <day>Thu</day>
            <day>Fri</day>
            <day>Sat</day>
         </dayNames>
         <meridiemNames>
            <meridiem>AM</meridiem>
            <meridiem>PM</meridiem>
         </meridiemNames>
         <eraNames>
            <era>BC</era>
            <era>AD</era>
         </eraNames>
      </calendarSymbols>
      <datePatterns>
         <datePattern name="full">EEEE, MMMM D, YYYY</datePattern>
         <datePattern name="long">MMMM D, YYYY</datePattern>
         <datePattern name="med">D-MMM-YY</datePattern>
         <datePattern name="short">DD/MM/YY</datePattern>
      </datePatterns>
      <timePatterns>
         <timePattern name="full">h:MM:SS A Z</timePattern>
         <timePattern name="long">h:MM:SS A Z</timePattern>
         <timePattern name="med">h:MM:SS A</timePattern>
         <timePattern name="short">h:MM A</timePattern>
      </timePatterns>
      <dateTimeSymbols>GyMdkHmsSEDFwWahKzZ</dateTimeSymbols>
      <numberPatterns>
         <numberPattern name="numeric">z,zz9.zzz</numberPattern>
         <numberPattern name="currency">$z,zz9.99</numberPattern>
         <numberPattern name="percent">z,zz9%</numberPattern>
      </numberPatterns>
      <numberSymbols>
         <numberSymbol name="decimal">.</numberSymbol>
         <numberSymbol name="grouping">,</numberSymbol>
         <numberSymbol name="percent">%</numberSymbol>
         <numberSymbol name="minus">-</numberSymbol>
         <numberSymbol name="zero">0</numberSymbol>
      </numberSymbols>
      <currencySymbols>
         <currencySymbol name="symbol">$</currencySymbol>
         <currencySymbol name="isoname">CAD</currencySymbol>
         <currencySymbol name="decimal">.</currencySymbol>
      </currencySymbols>
      <typefaces>
         <typeface name="Myriad Pro"/>
         <typeface name="Minion Pro"/>
         <typeface name="Courier Std"/>
         <typeface name="Adobe Pi Std"/>
         <typeface name="Adobe Hebrew"/>
         <typeface name="Adobe Arabic"/>
         <typeface name="Adobe Thai"/>
         <typeface name="Kozuka Gothic Pro-VI M"/>
         <typeface name="Kozuka Mincho Pro-VI R"/>
         <typeface name="Adobe Ming Std L"/>
         <typeface name="Adobe Song Std L"/>
         <typeface name="Adobe Myungjo Std M"/>
      </typefaces>
   </locale>
</localeSet></xdp:xdp>
